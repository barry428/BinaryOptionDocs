# 定时任务监控使用说明

## 概述

本系统实现了基于Redis的分布式定时任务监控机制，可以追踪任务执行状态、性能指标和失败情况。本文档为运维人员提供监控使用指南。

## 监控架构

### 技术实现
- **注解驱动**: 使用`@DistributedScheduled`注解配置任务监控参数
- **AOP切面**: `DistributedLockAspect`自动拦截和监控任务执行
- **Redis存储**: 监控数据存储在Redis中，支持集群模式
- **实时监控**: `ScheduledTaskMonitor`提供实时监控数据记录

### 监控功能
- ✅ 任务执行次数统计
- ✅ 任务失败次数统计
- ✅ 任务执行时间跟踪
- ✅ 任务超时警告
- ✅ 分布式锁获取失败监控
- ✅ 任务重试机制监控
- ✅ 优先级任务特殊告警

## 当前监控的定时任务

### 1. 订单结算任务 (executeSettlementTask)
```yaml
任务名称: com.binaryoption.orderservice.service.ScheduledTaskService.executeSettlementTask
执行频率: 每分钟第1秒 (cron: "1 * * * * ?")
锁超时: 4分钟
任务优先级: 10 (最高)
重试配置: 启用, 最大2次, 间隔5秒
超时警告: 3分钟
功能说明: 处理已完成的交易轮次结算
```

### 2. 对冲补偿任务 (executeHedgeCompensationTask)
```yaml
任务名称: com.binaryoption.orderservice.service.ScheduledTaskService.executeHedgeCompensationTask
执行频率: 每5秒 (fixedRate = 5000)
锁超时: 4秒
任务优先级: 8 (高)
重试配置: 启用, 最大3次, 间隔1秒
超时警告: 3秒
功能说明: 处理失败的对冲操作补偿
```

### 3. 轮次维护任务 (executeTradingRoundMaintenanceTask)
```yaml
任务名称: com.binaryoption.orderservice.service.ScheduledTaskService.executeTradingRoundMaintenanceTask
执行频率: 每5分钟第1秒 (cron: "0 */5 * * * ?")
锁超时: 4分钟
任务优先级: 7 (较高)
重试配置: 启用, 最大2次, 间隔10秒
超时警告: 2分钟
功能说明: 确保所有交易对轮次正常创建和状态更新
```

### 4. 用户风控统计重置任务 (executeUserRiskStatsResetTask)
```yaml
任务名称: com.binaryoption.orderservice.service.ScheduledTaskService.executeUserRiskStatsResetTask
执行频率: 每天凌晨1点 (cron: "0 0 1 * * ?")
锁超时: 20分钟
任务优先级: 6 (中等)
重试配置: 启用, 最大3次, 间隔30秒
超时警告: 15分钟
功能说明: 重置过期的用户风控统计数据
```

## Redis监控Key结构

### 监控数据Key格式
```
# 任务基本信息
BO:Monitor:ScheduledTask:{taskName}:info

# 执行次数统计
BO:Monitor:Task:ExecutionCount:{taskName}

# 失败次数统计
BO:Monitor:Task:FailureCount:{taskName}

# 最后执行时间
BO:Monitor:Task:LastExecution:{taskName}

# 最后成功时间
BO:Monitor:Task:LastSuccess:{taskName}
```

### 任务信息字段
```json
{
  "description": "任务描述",
  "priority": "优先级(1-10)",
  "lastStartTime": "最后开始时间",
  "lastSuccessTime": "最后成功时间", 
  "lastFailureTime": "最后失败时间",
  "lastExecutionTime": "最后执行耗时(ms)",
  "status": "任务状态(SUCCESS/FAILED/LOCK_FAILED)",
  "lastError": "最后错误信息",
  "timeoutWarning": "超时警告信息",
  "lastLockFailureTime": "最后获取锁失败时间"
}
```

## 监控脚本

### 1. 任务状态查询脚本

创建 `scripts/monitor-tasks.sh`:
```bash
#!/bin/bash

# Redis连接配置
REDIS_HOST="127.0.0.1"
REDIS_PORT="6379"
REDIS_CMD="redis-cli -h $REDIS_HOST -p $REDIS_PORT"

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo "=============================================="
echo "          定时任务监控状态报告"
echo "=============================================="

# 定义任务列表
TASKS=(
    "com.binaryoption.orderservice.service.ScheduledTaskService.executeSettlementTask"
    "com.binaryoption.orderservice.service.ScheduledTaskService.executeHedgeCompensationTask"
    "com.binaryoption.orderservice.service.ScheduledTaskService.executeTradingRoundMaintenanceTask"
    "com.binaryoption.orderservice.service.ScheduledTaskService.executeUserRiskStatsResetTask"
)

for task in "${TASKS[@]}"; do
    echo ""
    echo -e "${BLUE}任务: ${task##*.}${NC}"
    echo "----------------------------------------"
    
    # 获取基本信息
    info_key="BO:Monitor:ScheduledTask:${task}:info"
    exec_key="BO:Monitor:Task:ExecutionCount:${task}"
    fail_key="BO:Monitor:Task:FailureCount:${task}"
    last_success_key="BO:Monitor:Task:LastSuccess:${task}"
    
    # 查询任务信息
    description=$($REDIS_CMD HGET "$info_key" "description" 2>/dev/null)
    priority=$($REDIS_CMD HGET "$info_key" "priority" 2>/dev/null)
    status=$($REDIS_CMD HGET "$info_key" "status" 2>/dev/null)
    last_success=$($REDIS_CMD GET "$last_success_key" 2>/dev/null)
    exec_count=$($REDIS_CMD GET "$exec_key" 2>/dev/null)
    fail_count=$($REDIS_CMD GET "$fail_key" 2>/dev/null)
    
    # 设置默认值
    [[ -z "$description" ]] && description="未知"
    [[ -z "$priority" ]] && priority="0"
    [[ -z "$status" ]] && status="未执行"
    [[ -z "$last_success" ]] && last_success="从未成功"
    [[ -z "$exec_count" ]] && exec_count="0"
    [[ -z "$fail_count" ]] && fail_count="0"
    
    # 显示信息
    echo "描述: $description"
    echo "优先级: $priority"
    
    # 根据状态显示不同颜色
    case "$status" in
        "SUCCESS")
            echo -e "状态: ${GREEN}$status${NC}"
            ;;
        "FAILED")
            echo -e "状态: ${RED}$status${NC}"
            ;;
        "LOCK_FAILED")
            echo -e "状态: ${YELLOW}$status${NC}"
            ;;
        *)
            echo "状态: $status"
            ;;
    esac
    
    echo "执行次数: $exec_count"
    echo "失败次数: $fail_count"
    echo "最后成功: $last_success"
    
    # 计算成功率
    if [[ "$exec_count" -gt 0 ]]; then
        success_rate=$(( (exec_count - fail_count) * 100 / exec_count ))
        if [[ "$success_rate" -ge 95 ]]; then
            echo -e "成功率: ${GREEN}${success_rate}%${NC}"
        elif [[ "$success_rate" -ge 80 ]]; then
            echo -e "成功率: ${YELLOW}${success_rate}%${NC}"
        else
            echo -e "成功率: ${RED}${success_rate}%${NC}"
        fi
    fi
done

echo ""
echo "=============================================="
echo "监控报告生成完成 - $(date)"
echo "=============================================="
```

### 2. 任务告警检查脚本

创建 `scripts/check-task-alerts.sh`:
```bash
#!/bin/bash

# Redis连接配置
REDIS_HOST="127.0.0.1"
REDIS_PORT="6379"
REDIS_CMD="redis-cli -h $REDIS_HOST -p $REDIS_PORT"

# 告警阈值配置
MAX_FAILURE_RATE=10  # 最大失败率 10%
MAX_NO_SUCCESS_HOURS=2  # 最大无成功执行时间 2小时

echo "=============================================="
echo "          定时任务告警检查"
echo "=============================================="

# 高优先级任务列表 (priority >= 8)
HIGH_PRIORITY_TASKS=(
    "com.binaryoption.orderservice.service.ScheduledTaskService.executeSettlementTask"
    "com.binaryoption.orderservice.service.ScheduledTaskService.executeHedgeCompensationTask"
)

ALERT_COUNT=0

for task in "${HIGH_PRIORITY_TASKS[@]}"; do
    echo "检查任务: ${task##*.}"
    
    # 获取统计信息
    exec_key="BO:Monitor:Task:ExecutionCount:${task}"
    fail_key="BO:Monitor:Task:FailureCount:${task}"
    last_success_key="BO:Monitor:Task:LastSuccess:${task}"
    info_key="BO:Monitor:ScheduledTask:${task}:info"
    
    exec_count=$($REDIS_CMD GET "$exec_key" 2>/dev/null)
    fail_count=$($REDIS_CMD GET "$fail_key" 2>/dev/null)
    last_success=$($REDIS_CMD GET "$last_success_key" 2>/dev/null)
    priority=$($REDIS_CMD HGET "$info_key" "priority" 2>/dev/null)
    
    [[ -z "$exec_count" ]] && exec_count="0"
    [[ -z "$fail_count" ]] && fail_count="0"
    
    # 检查失败率
    if [[ "$exec_count" -gt 10 ]]; then
        failure_rate=$(( fail_count * 100 / exec_count ))
        if [[ "$failure_rate" -gt "$MAX_FAILURE_RATE" ]]; then
            echo "🚨 告警: 任务失败率过高 - $failure_rate% (阈值: $MAX_FAILURE_RATE%)"
            ALERT_COUNT=$((ALERT_COUNT + 1))
        fi
    fi
    
    # 检查最后成功时间
    if [[ -n "$last_success" && "$last_success" != "从未成功" ]]; then
        last_success_timestamp=$(date -d "$last_success" +%s 2>/dev/null)
        if [[ $? -eq 0 ]]; then
            current_timestamp=$(date +%s)
            hours_since_success=$(( (current_timestamp - last_success_timestamp) / 3600 ))
            
            if [[ "$hours_since_success" -gt "$MAX_NO_SUCCESS_HOURS" ]]; then
                echo "🚨 告警: 任务长时间无成功执行 - ${hours_since_success}小时 (阈值: ${MAX_NO_SUCCESS_HOURS}小时)"
                ALERT_COUNT=$((ALERT_COUNT + 1))
            fi
        fi
    elif [[ "$last_success" == "从未成功" && "$exec_count" -gt 0 ]]; then
        echo "🚨 告警: 任务从未成功执行过"
        ALERT_COUNT=$((ALERT_COUNT + 1))
    fi
    
    echo "✅ 检查完成"
    echo ""
done

echo "=============================================="
if [[ "$ALERT_COUNT" -eq 0 ]]; then
    echo "✅ 所有高优先级任务运行正常"
else
    echo "🚨 发现 $ALERT_COUNT 个告警项，需要关注！"
fi
echo "检查完成时间: $(date)"
echo "=============================================="

exit $ALERT_COUNT
```

### 3. 任务性能统计脚本

创建 `scripts/task-performance.sh`:
```bash
#!/bin/bash

# Redis连接配置
REDIS_HOST="127.0.0.1"
REDIS_PORT="6379"
REDIS_CMD="redis-cli -h $REDIS_HOST -p $REDIS_PORT"

echo "=============================================="
echo "          定时任务性能统计报告"
echo "=============================================="

# 获取所有任务的性能信息
TASKS=(
    "com.binaryoption.orderservice.service.ScheduledTaskService.executeSettlementTask"
    "com.binaryoption.orderservice.service.ScheduledTaskService.executeHedgeCompensationTask"
    "com.binaryoption.orderservice.service.ScheduledTaskService.executeTradingRoundMaintenanceTask"
    "com.binaryoption.orderservice.service.ScheduledTaskService.executeUserRiskStatsResetTask"
)

for task in "${TASKS[@]}"; do
    echo ""
    echo "任务: ${task##*.}"
    echo "----------------------------------------"
    
    info_key="BO:Monitor:ScheduledTask:${task}:info"
    
    # 获取性能信息
    last_execution_time=$($REDIS_CMD HGET "$info_key" "lastExecutionTime" 2>/dev/null)
    timeout_warning=$($REDIS_CMD HGET "$info_key" "timeoutWarning" 2>/dev/null)
    last_error=$($REDIS_CMD HGET "$info_key" "lastError" 2>/dev/null)
    
    [[ -z "$last_execution_time" ]] && last_execution_time="未知"
    
    echo "最后执行耗时: ${last_execution_time}ms"
    
    if [[ -n "$timeout_warning" ]]; then
        echo "⚠️  超时警告: $timeout_warning"
    fi
    
    if [[ -n "$last_error" && "$last_error" != "" ]]; then
        echo "❌ 最后错误: $last_error"
    fi
done

echo ""
echo "=============================================="
echo "性能报告生成完成 - $(date)"
echo "=============================================="
```

## 使用说明

### 1. 赋予脚本执行权限
```bash
chmod +x scripts/monitor-tasks.sh
chmod +x scripts/check-task-alerts.sh
chmod +x scripts/task-performance.sh
```

### 2. 手动监控检查
```bash
# 查看任务状态
./scripts/monitor-tasks.sh

# 检查告警
./scripts/check-task-alerts.sh

# 查看性能统计
./scripts/task-performance.sh
```

### 3. 设置定期监控 (crontab)
```bash
# 编辑crontab
crontab -e

# 添加监控任务
# 每5分钟检查一次告警
*/5 * * * * /path/to/scripts/check-task-alerts.sh >> /var/log/task-alerts.log 2>&1

# 每小时生成状态报告
0 * * * * /path/to/scripts/monitor-tasks.sh >> /var/log/task-monitor.log 2>&1

# 每天早上8点发送性能报告
0 8 * * * /path/to/scripts/task-performance.sh | mail -s "定时任务性能报告" admin@example.com
```

## 告警规则

### 自动告警触发条件
1. **高优先级任务失败率 > 10%**
2. **任务连续2小时无成功执行**
3. **任务从未成功执行过**
4. **任务执行超时 (根据配置的taskTimeout)**

### 告警级别
- 🚨 **严重**: 优先级≥8的任务出现问题
- ⚠️ **警告**: 优先级5-7的任务出现问题
- ℹ️ **信息**: 优先级<5的任务出现问题

## 故障处理

### 常见问题诊断

1. **任务获取锁失败**
   - 检查Redis连接状态
   - 检查是否有多个实例同时运行
   - 查看锁过期时间设置是否合理

2. **任务执行超时**
   - 检查数据库连接池状态
   - 查看任务处理的数据量
   - 考虑调整超时时间或优化任务逻辑

3. **任务重试失败**
   - 查看具体错误日志
   - 检查外部依赖服务状态
   - 考虑增加重试次数或调整重试间隔

### 应急处理步骤

1. **立即响应** (5分钟内)
   - 确认告警真实性
   - 检查系统整体状态
   - 查看相关日志

2. **问题定位** (15分钟内)
   - 使用监控脚本获取详细信息
   - 检查Redis和数据库状态
   - 分析错误模式

3. **修复措施** (30分钟内)
   - 重启相关服务 (临时措施)
   - 修复配置问题
   - 调整任务参数

4. **后续跟踪**
   - 持续监控修复效果
   - 更新告警阈值
   - 完善监控覆盖

## 联系方式

如遇紧急问题，请联系:
- **开发团队**: dev-team@example.com
- **系统管理员**: sysadmin@example.com
- **24小时热线**: xxx-xxxx-xxxx

---

*文档更新时间: 2025-09-18*
*维护人员: Binary Option 运维团队*