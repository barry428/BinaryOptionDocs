# 二元期权平台基础框架补充计划

**日期**: 2025-07-23  
**当前状态**: 基础微服务架构已完成，需要补充生产环境必需组件

## 📋 已完成工作回顾

### ✅ 核心架构搭建
- [x] Maven多模块项目结构
- [x] Spring Boot 2.7.18 + Spring Cloud 微服务架构
- [x] 5个核心服务启动并运行正常
- [x] Nacos服务发现与配置中心集成
- [x] Redis集群配置 (7001-7006端口)
- [x] MySQL数据库连接和MyBatis集成
- [x] 基础实体类和Mapper创建

### ✅ 运维脚本
- [x] 服务启动脚本 (start-all.sh)
- [x] 服务停止脚本 (stop-all.sh)  
- [x] 服务状态检查脚本 (status.sh)

### ✅ 基础框架完善 (2025-07-22/23)
- [x] **统一异常处理框架** - 所有服务使用统一的ApiResponse格式和异常处理机制
- [x] **国际化支持框架** - 支持中英日繁四种语言，完整的i18n架构
  - 国际化配置类 (I18nConfig) 和消息工具 (MessageUtils)
  - Gateway语言检测过滤器 (LocaleFilter)
  - 全局异常处理器国际化支持
  - 业务异常类 (BusinessException) 支持消息代码
  - 所有服务消息资源文件 (messages*.properties)
- [x] **Gateway依赖冲突修复** - 解决WebFlux与Spring MVC冲突问题

---

## 🔥 高优先级补充计划 (必须完成)

### 1. 国际化支持 ✅ **已完成**

**状态**: 已完成完整的国际化支持框架
**完成日期**: 2025-07-23

#### 1.1 多语言消息资源配置 ✅
**目标**: 支持中文、英文、日文等多语言界面和错误提示
**适用场景**: 二元期权平台面向全球用户，需要支持多国语言

**具体步骤**:
```xml
<!-- 添加国际化依赖到父POM -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

```yaml
# application.yml 国际化配置
spring:
  messages:
    basename: i18n/messages
    encoding: UTF-8
    cache-duration: 3600
  web:
    locale: zh_CN
    locale-resolver: fixed  # 或 accept_header, cookie, session
```

```properties
# src/main/resources/i18n/messages.properties (默认英文)
user.create.success=User created successfully
user.create.failed=Failed to create user
user.not.found=User not found
order.create.success=Order created successfully
order.insufficient.balance=Insufficient balance
order.invalid.amount=Invalid order amount
validation.username.required=Username is required
validation.email.invalid=Invalid email format
validation.password.min.length=Password must be at least 8 characters

# src/main/resources/i18n/messages_zh_CN.properties (中文)
user.create.success=用户创建成功
user.create.failed=用户创建失败
user.not.found=用户未找到
order.create.success=订单创建成功
order.insufficient.balance=余额不足
order.invalid.amount=订单金额无效
validation.username.required=用户名不能为空
validation.email.invalid=邮箱格式无效
validation.password.min.length=密码至少需要8个字符

# src/main/resources/i18n/messages_ja.properties (日文)
user.create.success=ユーザーが正常に作成されました
user.create.failed=ユーザーの作成に失敗しました
user.not.found=ユーザーが見つかりません
order.create.success=注文が正常に作成されました
order.insufficient.balance=残高不足
order.invalid.amount=無効な注文金額
validation.username.required=ユーザー名は必須です
validation.email.invalid=無効なメール形式
validation.password.min.length=パスワードは8文字以上である必要があります

# src/main/resources/i18n/messages_en.properties (英文)
user.create.success=User created successfully
user.create.failed=Failed to create user
user.not.found=User not found
order.create.success=Order created successfully
order.insufficient.balance=Insufficient balance
order.invalid.amount=Invalid order amount
validation.username.required=Username is required
validation.email.invalid=Invalid email format
validation.password.min.length=Password must be at least 8 characters
```

#### 1.2 国际化配置类和工具
**具体步骤**:
```java
// 国际化配置类
@Configuration
public class I18nConfig {
    
    @Bean
    public LocaleResolver localeResolver() {
        // 1. 接受Header方式 (推荐用于API)
        AcceptHeaderLocaleResolver resolver = new AcceptHeaderLocaleResolver();
        resolver.setDefaultLocale(Locale.SIMPLIFIED_CHINESE);
        resolver.setSupportedLocales(Arrays.asList(
            Locale.SIMPLIFIED_CHINESE,    // zh_CN
            Locale.ENGLISH,               // en
            Locale.JAPANESE,              // ja
            Locale.TRADITIONAL_CHINESE    // zh_TW
        ));
        return resolver;
        
        // 2. 或使用Session方式
        // SessionLocaleResolver resolver = new SessionLocaleResolver();
        // resolver.setDefaultLocale(Locale.SIMPLIFIED_CHINESE);
        // return resolver;
    }
    
    @Bean
    public LocaleChangeInterceptor localeChangeInterceptor() {
        LocaleChangeInterceptor interceptor = new LocaleChangeInterceptor();
        interceptor.setParamName("lang"); // ?lang=en
        return interceptor;
    }
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(localeChangeInterceptor());
    }
}

// 国际化消息工具类
@Component
@RequiredArgsConstructor
public class MessageUtils {
    
    private final MessageSource messageSource;
    
    public String getMessage(String code) {
        return getMessage(code, null);
    }
    
    public String getMessage(String code, Object[] args) {
        return getMessage(code, args, LocaleContextHolder.getLocale());
    }
    
    public String getMessage(String code, Object[] args, Locale locale) {
        try {
            return messageSource.getMessage(code, args, locale);
        } catch (NoSuchMessageException e) {
            return code; // 降级处理，返回code本身
        }
    }
    
    public String getMessage(String code, Object[] args, String defaultMessage) {
        return messageSource.getMessage(code, args, defaultMessage, LocaleContextHolder.getLocale());
    }
}
```

#### 1.3 Gateway国际化处理
**具体步骤**:
```java
// Gateway语言检测过滤器
@Component
@Slf4j
public class LocaleFilter implements GlobalFilter, Ordered {
    
    private static final String LANG_HEADER = "Accept-Language";
    private static final String LANG_PARAM = "lang";
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        
        // 1. 从请求参数获取语言
        String lang = request.getQueryParams().getFirst(LANG_PARAM);
        
        // 2. 从Header获取语言
        if (StringUtils.isEmpty(lang)) {
            lang = request.getHeaders().getFirst(LANG_HEADER);
        }
        
        // 3. 解析和标准化语言代码
        String standardLang = parseAndStandardizeLocale(lang);
        
        // 4. 将标准化的语言代码传递给下游服务
        ServerHttpRequest newRequest = request.mutate()
            .header("X-Client-Locale", standardLang)
            .build();
        
        return chain.filter(exchange.mutate().request(newRequest).build());
    }
    
    private String parseAndStandardizeLocale(String lang) {
        if (StringUtils.isEmpty(lang)) {
            return "zh_CN"; // 默认中文
        }
        
        // 处理常见的语言代码格式
        lang = lang.toLowerCase().replace("-", "_");
        
        switch (lang) {
            case "zh":
            case "zh_cn":
            case "cn":
                return "zh_CN";
            case "zh_tw":
            case "tw":
                return "zh_TW";
            case "en":
            case "en_us":
                return "en";
            case "ja":
            case "jp":
                return "ja";
            default:
                return "zh_CN";
        }
    }
    
    @Override
    public int getOrder() {
        return -100; // 高优先级
    }
}
```

#### 1.4 错误响应国际化
**具体步骤**:
```java
// 更新全局异常处理器支持国际化
@RestControllerAdvice
@Slf4j
@RequiredArgsConstructor
public class GlobalExceptionHandler {
    
    private final MessageUtils messageUtils;
    
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ApiResponse<Void>> handleBusinessException(BusinessException e, HttpServletRequest request) {
        // 从请求头获取语言设置
        String locale = request.getHeader("X-Client-Locale");
        
        String message = messageUtils.getMessage(e.getMessageCode(), e.getArgs(), 
            parseLocale(locale));
        
        log.warn("Business exception: {} (locale: {})", e.getMessage(), locale);
        return ResponseEntity.ok(ApiResponse.error(e.getCode(), message));
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse<Map<String, String>>> handleValidationException(
            MethodArgumentNotValidException e, HttpServletRequest request) {
        
        String locale = request.getHeader("X-Client-Locale");
        Map<String, String> errors = new HashMap<>();
        
        e.getBindingResult().getFieldErrors().forEach(error -> {
            String fieldName = error.getField();
            String errorMessage = messageUtils.getMessage(
                "validation." + fieldName + "." + error.getCode(),
                error.getArguments(),
                parseLocale(locale)
            );
            errors.put(fieldName, errorMessage);
        });
        
        String message = messageUtils.getMessage("validation.failed", null, parseLocale(locale));
        return ResponseEntity.badRequest().body(ApiResponse.error(400, message, errors));
    }
    
    private Locale parseLocale(String localeStr) {
        if (StringUtils.isEmpty(localeStr)) {
            return Locale.SIMPLIFIED_CHINESE;
        }
        
        String[] parts = localeStr.split("_");
        if (parts.length == 2) {
            return new Locale(parts[0], parts[1]);
        } else {
            return new Locale(parts[0]);
        }
    }
}

// 业务异常类支持国际化
public class BusinessException extends RuntimeException {
    private final Integer code;
    private final String messageCode;  // 消息代码，用于国际化
    private final Object[] args;       // 消息参数
    
    public BusinessException(Integer code, String messageCode) {
        this(code, messageCode, null);
    }
    
    public BusinessException(Integer code, String messageCode, Object[] args) {
        super(messageCode);
        this.code = code;
        this.messageCode = messageCode;
        this.args = args;
    }
    
    // getters...
}
```

#### 1.5 数据验证国际化
**具体步骤**:
```java
// 自定义验证注解支持国际化
public class CreateUserRequest {
    
    @NotBlank(message = "validation.username.required")
    @Size(min = 3, max = 50, message = "validation.username.size")
    private String username;
    
    @NotBlank(message = "validation.email.required")
    @Email(message = "validation.email.invalid")
    private String email;
    
    @NotBlank(message = "validation.password.required")
    @Size(min = 8, message = "validation.password.min.length")
    private String password;
    
    // getters and setters...
}

// 控制器中使用国际化
@RestController
@RequestMapping("/api/v1/users")
@RequiredArgsConstructor
public class UserController {
    
    private final UserService userService;
    private final MessageUtils messageUtils;
    
    @PostMapping
    public ResponseEntity<ApiResponse<User>> createUser(
            @Valid @RequestBody CreateUserRequest request,
            HttpServletRequest httpRequest) {
        
        try {
            User user = userService.createUser(request);
            
            String successMessage = messageUtils.getMessage("user.create.success");
            return ResponseEntity.ok(ApiResponse.success(user, successMessage));
            
        } catch (UserAlreadyExistsException e) {
            throw new BusinessException(409, "user.already.exists", new Object[]{request.getUsername()});
        }
    }
}
```

**已完成文件清单**:
- ✅ `option-common-utils/src/main/java/com/binaryoption/commonutils/i18n/I18nConfig.java`
- ✅ `option-common-utils/src/main/java/com/binaryoption/commonutils/i18n/MessageUtils.java`
- ✅ `option-gateway/src/main/java/com/binaryoption/gateway/filter/LocaleFilter.java`
- ✅ 每个服务添加 `src/main/resources/i18n/messages*.properties` 文件
  - ✅ common-service: messages.properties, messages_zh_CN.properties, messages_en.properties, messages_ja.properties
  - ✅ order-service: messages_zh_CN.properties, messages_en.properties, messages_ja.properties
  - ✅ admin-service: messages_zh_CN.properties, messages_en.properties
- ✅ 更新 `GlobalExceptionHandler` 支持国际化
- ✅ 更新 `BusinessException` 支持国际化消息代码
- ✅ 更新控制器使用国际化消息：UserController、OrderController、UserRpcController

#### 1.6 前端API国际化支持
**API设计规范**:
```http
# 1. 通过Header传递语言 (推荐)
GET /api/v1/users
Accept-Language: zh-CN

# 2. 通过查询参数传递语言
GET /api/v1/users?lang=en

# 3. 标准化的错误响应格式
{
  "code": 400,
  "message": "用户名不能为空",
  "data": null,
  "traceId": "abc123",
  "timestamp": 1642678900000,
  "locale": "zh_CN"
}

# 4. 支持的语言列表API
GET /api/v1/system/locales
{
  "code": 200,
  "message": "success",
  "data": [
    {
      "code": "zh_CN",
      "name": "简体中文",
      "nativeName": "简体中文"
    },
    {
      "code": "en",
      "name": "English",
      "nativeName": "English"
    },
    {
      "code": "ja",
      "name": "Japanese",
      "nativeName": "日本語"
    },
    {
      "code": "zh_TW",
      "name": "Traditional Chinese",
      "nativeName": "繁體中文"
    }
  ]
}
```

### 2. 异常处理体系 ✅ **已完成**

#### 2.1 全局异常处理器 ✅
**状态**: 已完成所有服务的异常处理框架统一
**完成日期**: 2025-07-22

**已实现功能**:
- ✅ 统一的`ApiResponse<T>`响应格式，支持泛型数据类型
- ✅ `BusinessException`业务异常类，支持自定义错误码和消息
- ✅ `GlobalExceptionHandler`全局异常处理器，处理所有异常类型
- ✅ 所有服务继承统一异常处理：OrderService、CommonService、AdminService
- ✅ 支持参数验证异常、类型转换异常、HTTP方法不支持异常等

**已创建文件**:
- ✅ `option-common-utils/src/main/java/com/binaryoption/commonutils/response/ApiResponse.java`
- ✅ `option-common-utils/src/main/java/com/binaryoption/commonutils/exception/BusinessException.java`
- ✅ `option-common-utils/src/main/java/com/binaryoption/commonutils/exception/GlobalExceptionHandler.java`
- ✅ `option-order-service/.../exception/OrderServiceExceptionHandler.java`
- ✅ `option-common-service/.../exception/CommonServiceExceptionHandler.java`
- ✅ `option-admin-service/.../exception/AdminServiceExceptionHandler.java`

**已更新控制器**:
- ✅ `OrderController.java` - 统一使用ApiResponse格式
- ✅ `UserController.java` - 统一使用ApiResponse格式和异常抛出
- ✅ `UserRpcController.java` - 统一使用ApiResponse格式
- ✅ `AdminUserController.java` - 统一使用ApiResponse格式
- ✅ `AdminOrderController.java` - 统一使用ApiResponse格式

**验证结果**: ✅ 所有服务编译成功，异常处理框架运行正常

#### 2.2 日志体系优化
**目标**: 结构化日志记录和追踪

**具体步骤**:
```xml
<!-- logback-spring.xml -->
<configuration>
    <springProfile name="dev">
        <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
            <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder">
                <providers>
                    <timestamp/>
                    <logLevel/>
                    <loggerName/>
                    <mdc/>
                    <message/>
                    <stackTrace/>
                </providers>
            </encoder>
        </appender>
    </springProfile>
    
    <springProfile name="prod">
        <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <file>logs/${spring.application.name}.log</file>
            <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
                <fileNamePattern>logs/${spring.application.name}.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
                <maxFileSize>100MB</maxFileSize>
                <maxHistory>30</maxHistory>
            </rollingPolicy>
            <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder">
                <providers>
                    <timestamp/>
                    <logLevel/>
                    <loggerName/>
                    <mdc/>
                    <message/>
                    <stackTrace/>
                </providers>
            </encoder>
        </appender>
    </springProfile>
    
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/>
    </root>
</configuration>
```

**文件创建**:
- [ ] 每个服务添加 `src/main/resources/logback-spring.xml`
- [ ] 添加logback-json依赖到父POM
- [ ] 创建TraceId生成器和MDC设置

### 3. 基础测试支持 🧪

#### 3.1 简单接口测试
**目标**: 确保核心接口可用

**具体步骤**:
```bash
# 简单的curl测试脚本
#!/bin/bash
echo "Testing Order Service..."
curl -X GET http://localhost:8082/order/list
curl -X GET http://localhost:8081/user/list
curl -X GET http://localhost:8080/actuator/health
echo "Basic API tests completed"
```

**任务**:
- [ ] 创建基础的API测试脚本
- [ ] 确保所有服务health检查正常
- [ ] 验证服务间调用正常

---


---

## 📅 实施时间表

### 第一周 (高优先级核心功能) 
- ✅ Day 1: 全局异常处理器和API响应格式统一 (2025-07-22 完成)
- ✅ Day 2: 国际化支持框架搭建 (2025-07-23 完成)
  - ✅ 消息资源文件创建
  - ✅ 国际化配置类和工具
  - ✅ Gateway语言检测过滤器
  - ✅ 异常处理国际化
  - ✅ 控制器国际化更新
- [ ] Day 3-5: 日志体系优化 (结构化日志、追踪ID)

### 第二周 (基础完善)  
- [ ] Day 1-2: 基础的接口测试和冒烟测试
- [ ] Day 3-7: 文档完善和部署准备

---

## 📋 验收标准

### 国际化检查 ✅
- ✅ 支持中文、英文、日文、繁体中文四种语言
- ✅ 错误消息正确国际化显示
- ✅ Gateway过滤器传递语言设置到下游服务 (X-Client-Locale)
- ✅ 语言切换功能正常工作 (支持Accept-Language Header和?lang=参数)

### 异常处理检查 ✅
- ✅ 全局异常处理覆盖所有场景
- ✅ 错误响应格式统一标准化 (ApiResponse<T>)
- ✅ 异常日志记录完整清晰
- ✅ 业务异常和系统异常正确区分

### 基础测试检查
- [ ] 所有服务接口可正常访问
- [ ] 服务间RPC调用正常
- [ ] 健康检查端点响应正确

### 日志体系检查
- [ ] 结构化日志正常输出
- [ ] 追踪ID在请求链路中正确传递
- [ ] 日志格式统一且便于分析
- [ ] 关键业务操作日志完整

---

## 🔗 相关文档

- [技术方案文档](../2.%20设计类/202_技术方案.md)
- [开发规范文档](../2.%20设计类/203_后端开发规范与接口约定.md)
- [数据库设计](../database/init.sql)
- [项目计划](../3.%20计划与管理类/301_MVP项目计划.md)

---

## 📝 今日完成总结 (2025-07-23)

### 完成的主要工作：

1. **国际化框架实施** 🌍
   - 创建了完整的国际化支持架构
   - 实现了4种语言的消息资源文件（中英日繁）
   - Gateway智能语言检测和传递机制
   - 所有异常和响应消息支持多语言

2. **技术问题解决** 🔧
   - 修复了Gateway的Spring MVC依赖冲突
   - 完善了异常处理框架的国际化支持
   - 更新了所有控制器使用国际化消息

3. **文档更新** 📄
   - 更新了设计文档中的异常处理框架章节
   - 完善了TODO文档的完成状态记录

### 下一步计划：
- 实现日志体系优化（结构化日志、链路追踪）
- 创建基础测试脚本
- 进一步完善生产环境配置

---

**备注**: 此计划聚焦于MVP阶段的核心需求，去除了中低优先级功能，确保在有限时间内交付最有价值的基础框架组件。所有功能都有明确的验收标准和可验证的交付成果。