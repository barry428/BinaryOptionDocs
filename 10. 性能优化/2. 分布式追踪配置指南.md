# 分布式追踪配置指南

## 概述

本文档说明如何配置和使用分布式追踪系统，通过trace-id关联不同服务的日志。

## 1. 核心组件

### 1.1 已实现组件
- ✅ **LoggingMDCFilter** - 设置MDC上下文
- ✅ **TraceIdGlobalFilter** - Gateway生成和传递trace-id
- ✅ **FeignTraceInterceptor** - Feign调用传递trace-id
- ✅ **AsyncMDCConfig** - 异步任务传递MDC上下文

### 1.2 追踪ID说明
- **trace-id**: 贯穿整个请求链路的唯一标识
- **call-id**: 单次服务调用的唯一标识
- **user-name**: 用户标识，用于关联用户操作

## 2. 服务间追踪示例

### 2.1 请求流程
```
用户请求 
  → Gateway (生成trace-id: abc123)
    → Common Service (继承trace-id: abc123)
      → Order Service (继承trace-id: abc123)
        → Market Service (继承trace-id: abc123)
```

### 2.2 日志关联示例
```log
# Gateway日志
2025-09-10T17:31:40.439+08:00 INFO [gateway] [call-001] [abc123] [user123] : 收到用户请求 /api/borc/order/create

# Common Service日志  
2025-09-10T17:31:40.450+08:00 INFO [common-service] [call-002] [abc123] [user123] : 验证用户账户余额

# Order Service日志
2025-09-10T17:31:40.465+08:00 INFO [order-service] [call-003] [abc123] [user123] : 创建订单 OrderID=12345

# Market Service日志
2025-09-10T17:31:40.478+08:00 INFO [market-service] [call-004] [abc123] [user123] : 获取最新行情 BTCUSDT=50000
```

## 3. 使用指南

### 3.1 在代码中使用trace-id
```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

@Service
public class OrderService {
    private static final Logger log = LoggerFactory.getLogger(OrderService.class);
    
    public Order createOrder(OrderRequest request) {
        // trace-id会自动包含在日志中
        log.info("开始创建订单，用户ID: {}, 金额: {}", 
                request.getUserId(), request.getAmount());
        
        // 获取当前trace-id（如需要）
        String traceId = MDC.get("trace-id");
        
        // 异步任务使用mdcTaskExecutor保持trace-id
        CompletableFuture.runAsync(() -> {
            log.info("异步处理订单通知"); // 仍包含相同的trace-id
        }, mdcTaskExecutor);
        
        return order;
    }
}
```

### 3.2 手动设置trace-id（定时任务等场景）
```java
@Scheduled(cron = "0 0/5 * * * ?")
public void scheduledTask() {
    // 为定时任务生成trace-id
    String traceId = UUID.randomUUID().toString().replace("-", "");
    MDC.put("trace-id", traceId);
    MDC.put("user-name", "system-scheduler");
    
    try {
        log.info("开始执行定时任务");
        // 任务逻辑
    } finally {
        MDC.clear();
    }
}
```

## 4. 日志查询

### 4.1 通过trace-id查询完整请求链路
```bash
# 查询特定trace-id的所有日志
grep "abc123" /logs/*.log | sort -t'T' -k1

# 使用jq格式化JSON日志（如果使用JSON格式）
grep "abc123" /logs/*.log | jq '.'
```

### 4.2 ELK查询示例
```json
{
  "query": {
    "match": {
      "trace-id": "abc123"
    }
  },
  "sort": [
    { "@timestamp": { "order": "asc" } }
  ]
}
```

## 5. 监控和告警

### 5.1 链路耗时监控
```java
@Component
public class TraceMetricsCollector {
    
    @EventListener
    public void handleRequestComplete(RequestCompleteEvent event) {
        String traceId = MDC.get("trace-id");
        long duration = event.getDuration();
        
        // 记录链路耗时
        if (duration > 1000) { // 超过1秒
            log.warn("请求链路耗时过长: trace-id={}, duration={}ms", 
                    traceId, duration);
        }
    }
}
```

### 5.2 异常链路追踪
```java
@ControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(Exception.class)
    public Result<Void> handleException(Exception e) {
        String traceId = MDC.get("trace-id");
        log.error("请求处理异常: trace-id={}", traceId, e);
        
        // 返回trace-id给前端，方便问题排查
        return Result.error("系统异常，追踪ID: " + traceId);
    }
}
```

## 6. 测试验证

### 6.1 验证trace-id传递
```bash
# 发起测试请求
curl -H "X-Trace-ID: test-trace-123" \
     http://localhost:8080/api/borc/order/list

# 检查各服务日志是否包含相同的trace-id
grep "test-trace-123" /logs/option-gateway*.log
grep "test-trace-123" /logs/option-common-service*.log
grep "test-trace-123" /logs/option-order-service*.log
```

### 6.2 验证脚本
```bash
#!/bin/bash
# test-trace-id.sh

TRACE_ID="test-$(date +%s)"
echo "Testing with trace-id: $TRACE_ID"

# 发起请求
curl -H "X-Trace-ID: $TRACE_ID" \
     -H "X-Username: test-user" \
     http://localhost:8080/api/borc/account/balance

# 等待日志写入
sleep 2

# 统计各服务日志中的trace-id出现次数
echo "Trace-id occurrences:"
for service in gateway common-service order-service market-service; do
    count=$(grep -c "$TRACE_ID" /logs/option-${service}*.log 2>/dev/null || echo 0)
    echo "  $service: $count"
done
```

## 7. 最佳实践

### 7.1 日志记录规范
- ✅ 在服务入口记录请求开始
- ✅ 在服务出口记录请求完成和耗时
- ✅ 在关键业务节点记录状态变化
- ✅ 在异常处记录详细错误信息

### 7.2 trace-id生成规则
- 使用UUID去除横线，32位字符
- 客户端可预先生成并传递
- Gateway负责补充缺失的trace-id

### 7.3 性能考虑
- MDC操作是线程本地的，性能开销很小
- 及时清理MDC防止内存泄漏
- 异步任务需要显式传递MDC上下文

## 8. 故障排查

### 8.1 trace-id丢失
**问题**: 下游服务日志中没有trace-id
**解决**: 
1. 检查FeignTraceInterceptor是否被加载
2. 确认LoggingMDCFilter在所有服务中生效
3. 验证Gateway的TraceIdGlobalFilter是否工作

### 8.2 异步任务trace-id丢失
**问题**: 异步任务日志中trace-id为空
**解决**:
1. 使用mdcTaskExecutor替代默认线程池
2. 在@Async注解中指定executor名称

### 8.3 定时任务没有trace-id
**问题**: 定时任务日志缺少追踪信息
**解决**:
1. 在任务开始时手动生成trace-id
2. 任务结束时清理MDC

## 总结

通过以上配置，系统已具备完整的分布式追踪能力：
- ✅ 自动生成和传递trace-id
- ✅ 服务间调用保持trace-id
- ✅ 异步任务继承trace-id
- ✅ 日志自动包含追踪信息
- ✅ 支持链路问题排查