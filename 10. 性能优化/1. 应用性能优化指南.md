# Binary Option 应用性能优化指南

## 1. 数据库优化

### 1.1 连接池优化
```yaml
# application-btsedev.yml 优化配置
spring:
  datasource:
    hikari:
      maximum-pool-size: 30        # 增加最大连接数
      minimum-idle: 10              # 增加最小空闲连接
      connection-timeout: 20000     # 减少连接超时
      idle-timeout: 300000         # 减少空闲超时
      max-lifetime: 1200000        # 减少连接生命周期
      connection-test-query: SELECT 1
      leak-detection-threshold: 60000  # 连接泄漏检测
```

### 1.2 查询优化
```java
// 批量查询优化示例
@Repository
public class OrderRepositoryOptimized {
    
    // 使用批量查询替代循环查询
    @Select("SELECT * FROM orders WHERE user_id = #{userId} AND status IN ('ACTIVE', 'PENDING') LIMIT 100")
    List<Order> findActiveOrdersBatch(@Param("userId") Long userId);
    
    // 添加合适的索引
    // CREATE INDEX idx_user_status ON orders(user_id, status);
    // CREATE INDEX idx_created_at ON orders(created_at DESC);
}
```

### 1.3 数据库索引建议
```sql
-- 关键索引添加
CREATE INDEX idx_orders_user_round ON orders(user_id, round_id);
CREATE INDEX idx_orders_symbol_time ON orders(symbol, created_at DESC);
CREATE INDEX idx_account_trans_user ON account_transactions(user_id, created_at DESC);
CREATE INDEX idx_trading_rounds_symbol ON trading_rounds(symbol, status, start_time);

-- 分析慢查询
EXPLAIN ANALYZE SELECT * FROM orders WHERE user_id = ? AND created_at > ?;
```

## 2. Redis缓存优化

### 2.1 缓存策略优化
```java
@Service
public class CacheOptimizationService {
    
    // 使用Pipeline批量操作
    public void batchSetCache(Map<String, Object> data) {
        redisTemplate.executePipelined((RedisCallback<Object>) connection -> {
            data.forEach((key, value) -> {
                connection.set(key.getBytes(), serialize(value));
                connection.expire(key.getBytes(), 3600);
            });
            return null;
        });
    }
    
    // 使用本地缓存减少Redis调用
    @Cacheable(value = "symbols", cacheManager = "caffeineCacheManager")
    public List<Symbol> getActiveSymbols() {
        return symbolMapper.findActiveSymbols();
    }
}
```

### 2.2 Caffeine本地缓存配置
```java
@Configuration
public class CaffeineConfig {
    
    @Bean
    public CacheManager caffeineCacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(Caffeine.newBuilder()
            .maximumSize(10000)
            .expireAfterWrite(5, TimeUnit.MINUTES)
            .recordStats());
        return cacheManager;
    }
}
```

## 3. 线程池优化

### 3.1 异步任务配置
```java
@Configuration
@EnableAsync
public class AsyncConfig {
    
    @Bean(name = "taskExecutor")
    public TaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);           // 核心线程数
        executor.setMaxPoolSize(50);            // 最大线程数
        executor.setQueueCapacity(500);         // 队列容量
        executor.setKeepAliveSeconds(60);       // 线程空闲时间
        executor.setThreadNamePrefix("Async-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
    
    @Bean(name = "orderProcessExecutor")
    public TaskExecutor orderProcessExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(20);           // 订单处理需要更多线程
        executor.setMaxPoolSize(100);
        executor.setQueueCapacity(1000);
        executor.setThreadNamePrefix("Order-");
        executor.initialize();
        return executor;
    }
}
```

## 4. WebSocket优化

### 4.1 连接管理优化
```java
@Configuration
@EnableWebSocket
public class WebSocketOptimization implements WebSocketConfigurer {
    
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(marketHandler(), "/ws/market")
            .setAllowedOrigins("*")
            .addInterceptors(new HttpSessionHandshakeInterceptor())
            .withSockJS()
            .setStreamBytesLimit(512 * 1024)    // 限制流大小
            .setHttpMessageCacheSize(1000)      // 消息缓存
            .setDisconnectDelay(30 * 1000);     // 断开延迟
    }
    
    @Bean
    public ServletServerContainerFactoryBean createWebSocketContainer() {
        ServletServerContainerFactoryBean container = new ServletServerContainerFactoryBean();
        container.setMaxTextMessageBufferSize(32768);
        container.setMaxBinaryMessageBufferSize(32768);
        container.setMaxSessionIdleTimeout(60000L);
        container.setAsyncSendTimeout(15000L);
        return container;
    }
}
```

## 5. API接口优化

### 5.1 分页查询优化
```java
@RestController
public class OrderController {
    
    // 使用游标分页替代offset分页
    @GetMapping("/orders/cursor")
    public PageResult<Order> getOrdersByCursor(
            @RequestParam(required = false) Long cursor,
            @RequestParam(defaultValue = "20") int size) {
        
        // 基于ID的游标分页，性能更好
        List<Order> orders = orderMapper.findByCursor(cursor, size + 1);
        
        boolean hasNext = orders.size() > size;
        if (hasNext) {
            orders = orders.subList(0, size);
        }
        
        Long nextCursor = hasNext ? orders.get(orders.size() - 1).getId() : null;
        return new PageResult<>(orders, nextCursor, hasNext);
    }
}
```

### 5.2 响应压缩
```yaml
server:
  compression:
    enabled: true
    mime-types: text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/json
    min-response-size: 1024
```

## 6. 监控和诊断

### 6.1 性能监控端点
```java
@RestController
@RequestMapping("/actuator/custom")
public class CustomMetricsController {
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    @GetMapping("/performance")
    public Map<String, Object> getPerformanceMetrics() {
        Map<String, Object> metrics = new HashMap<>();
        
        // JVM内存
        metrics.put("heap_used", Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory());
        metrics.put("heap_max", Runtime.getRuntime().maxMemory());
        
        // 线程信息
        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
        metrics.put("thread_count", threadBean.getThreadCount());
        metrics.put("peak_thread_count", threadBean.getPeakThreadCount());
        
        // GC信息
        List<GarbageCollectorMXBean> gcBeans = ManagementFactory.getGarbageCollectorMXBeans();
        for (GarbageCollectorMXBean gcBean : gcBeans) {
            metrics.put("gc_" + gcBean.getName() + "_count", gcBean.getCollectionCount());
            metrics.put("gc_" + gcBean.getName() + "_time", gcBean.getCollectionTime());
        }
        
        return metrics;
    }
}
```

## 7. 代码级优化

### 7.1 对象池化
```java
@Component
public class OrderObjectPool {
    
    private final GenericObjectPool<Order> pool;
    
    public OrderObjectPool() {
        GenericObjectPoolConfig<Order> config = new GenericObjectPoolConfig<>();
        config.setMaxTotal(100);
        config.setMaxIdle(50);
        config.setMinIdle(10);
        
        this.pool = new GenericObjectPool<>(new OrderFactory(), config);
    }
    
    public Order borrowOrder() throws Exception {
        return pool.borrowObject();
    }
    
    public void returnOrder(Order order) {
        order.reset(); // 重置对象状态
        pool.returnObject(order);
    }
}
```

### 7.2 避免频繁的字符串拼接
```java
// 使用StringBuilder替代String拼接
public String buildOrderKey(Order order) {
    StringBuilder sb = new StringBuilder(64);
    sb.append("order:")
      .append(order.getUserId())
      .append(":")
      .append(order.getId());
    return sb.toString();
}

// 使用String.format缓存
private static final String ORDER_KEY_FORMAT = "order:%d:%d";
public String buildOrderKeyOptimized(Order order) {
    return String.format(ORDER_KEY_FORMAT, order.getUserId(), order.getId());
}
```

## 8. 部署优化建议

### 8.1 容器资源限制
```yaml
# docker-compose.yml
services:
  option-order-service:
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 3G
        reservations:
          cpus: '1.0'
          memory: 2G
```

### 8.2 健康检查优化
```yaml
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
  interval: 30s
  timeout: 10s
  retries: 3
  start_period: 40s
```

## 性能优化检查清单

- [ ] JVM参数已按建议调整
- [ ] 数据库索引已创建
- [ ] 连接池参数已优化
- [ ] Redis Pipeline批量操作已实施
- [ ] 本地缓存Caffeine已配置
- [ ] 异步线程池已优化
- [ ] API分页已改为游标分页
- [ ] 响应压缩已启用
- [ ] 监控端点已配置
- [ ] 代码级优化已实施

## 预期效果

实施以上优化后，预期达到：
- **GC暂停时间**: < 50ms (当前123ms)
- **API响应时间**: P99 < 200ms (当前约500ms)
- **数据库查询**: P99 < 100ms
- **Redis操作**: P99 < 10ms
- **内存使用**: 降低20-30%
- **CPU使用**: 降低15-20%