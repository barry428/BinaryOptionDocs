# 二元期权平台 SQL优化和索引设计

## 文档概述
基于SQL查询整理文档中的查询模式，本文档提供具体的性能优化建议和索引设计方案。

## 索引设计策略

### 1. 超高频查询优化 (每秒数百次)

#### 1.1 account表索引优化
```sql
-- 复合查询索引 (user_id + account_type + currency)
CREATE INDEX idx_account_user_type_currency ON account (user_id, account_type, currency);

-- 账户类型统计索引
CREATE INDEX idx_account_type_for_stats ON account (account_type, total_deposit, total_withdraw, balance, frozen_balance, total_profit, total_loss);

-- 覆盖索引 (包含常用查询字段)
CREATE INDEX idx_account_covering ON account (user_id, account_type, currency) 
INCLUDE (id, balance, frozen_balance, total_deposit, total_withdraw, total_profit, total_loss);
```

#### 1.2 trading_round表索引优化
```sql
-- 当前轮次查询优化索引
CREATE INDEX idx_trading_round_current ON trading_round (symbol_id, duration_minutes, status, start_time, end_time);

-- 结算查询索引
CREATE INDEX idx_trading_round_settlement ON trading_round (status, end_time);

-- 轮次维护索引
CREATE INDEX idx_trading_round_maintenance ON trading_round (status, lock_time);

-- 复合唯一索引 (防止重复轮次)
CREATE UNIQUE INDEX uk_trading_round_key ON trading_round (symbol_id, start_time, duration_minutes);
```

#### 1.3 option_order表索引优化
```sql
-- 用户订单列表索引
CREATE INDEX idx_order_user_type_time ON option_order (user_id, account_type, create_time DESC);

-- 轮次结算索引
CREATE INDEX idx_order_round_status ON option_order (round_id, status);

-- 订单状态索引
CREATE INDEX idx_order_status_time ON option_order (status, create_time);

-- 覆盖索引 (用户订单查询)
CREATE INDEX idx_order_user_covering ON option_order (user_id, account_type, create_time DESC) 
INCLUDE (id, symbol_id, round_id, direction, amount, odds, expected_profit, status, profit, fee);
```

### 2. 高频查询优化 (每分钟数十次)

#### 2.1 btse_transfer_log表索引优化
```sql
-- 超时处理查询索引
CREATE INDEX idx_btse_transfer_timeout ON btse_transfer_log (direction, status, create_time);

-- 订单转账记录索引
CREATE INDEX idx_btse_transfer_order ON btse_transfer_log (order_id, direction, status, create_time DESC);

-- 用户转账记录索引
CREATE INDEX idx_btse_transfer_user ON btse_transfer_log (user_id, direction, status, create_time DESC);
```

#### 2.2 account_transaction表索引优化
```sql
-- 用户流水分页索引
CREATE INDEX idx_transaction_user_time ON account_transaction (user_id, create_time DESC);

-- 账户类型流水索引 (支持JOIN查询)
CREATE INDEX idx_transaction_account_time ON account_transaction (account_id, create_time DESC);

-- 类型聚合索引
CREATE INDEX idx_transaction_type_amount ON account_transaction (type, amount, frozen_amount);
```

### 3. 中频查询优化 (每小时数次)

#### 3.1 风控相关索引
```sql
-- 黑名单查询索引
CREATE INDEX idx_blacklist_user_status_time ON blacklist (user_id, status, start_time, end_time);

-- 风控日志查询索引
CREATE INDEX idx_risk_log_user_time ON risk_log (user_id, create_time DESC);
CREATE INDEX idx_risk_log_type_time ON risk_log (risk_type, create_time DESC);
CREATE INDEX idx_risk_log_action_time ON risk_log (action_taken, create_time DESC);
CREATE INDEX idx_risk_log_time_range ON risk_log (create_time DESC);

-- 风控配置索引
CREATE UNIQUE INDEX uk_risk_config_key ON risk_config (config_key);
CREATE INDEX idx_risk_config_type_enabled ON risk_config (config_type, enabled);
```

#### 3.2 全局配置和交易对索引
```sql
-- 全局配置索引
CREATE UNIQUE INDEX uk_global_config_key ON global_config (config_key);
CREATE INDEX idx_global_config_enabled ON global_config (enabled, config_group);

-- 交易对配置索引
CREATE UNIQUE INDEX uk_symbol_config_symbol ON symbol_config (symbol);
CREATE INDEX idx_symbol_config_enabled ON symbol_config (enabled, sort_order);
```

#### 3.3 用户管理索引
```sql
-- OAuth认证索引
CREATE UNIQUE INDEX uk_user_external_id ON "user" (external_id);

-- 时间范围统计索引
CREATE INDEX idx_user_create_time ON "user" (create_time DESC);
CREATE INDEX idx_user_status_time ON "user" (status, create_time DESC);
```

## 查询优化建议

### 1. 超高频查询优化

#### 问题：account表多SUM聚合查询
```sql
-- 原始查询 (性能问题)
SELECT COALESCE(SUM(total_deposit) - SUM(total_withdraw) - SUM(balance) - SUM(frozen_balance) + SUM(total_profit) - SUM(total_loss), 0) 
FROM account 
WHERE account_type = #{accountType}
```

**优化方案：**
1. **创建物化视图** (PostgreSQL)
```sql
CREATE MATERIALIZED VIEW account_stats_by_type AS
SELECT 
    account_type,
    SUM(total_deposit) as sum_deposit,
    SUM(total_withdraw) as sum_withdraw,
    SUM(balance) as sum_balance,
    SUM(frozen_balance) as sum_frozen,
    SUM(total_profit) as sum_profit,
    SUM(total_loss) as sum_loss,
    COUNT(*) as account_count
FROM account 
GROUP BY account_type;

-- 创建刷新函数
CREATE OR REPLACE FUNCTION refresh_account_stats()
RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY account_stats_by_type;
END;
$$ LANGUAGE plpgsql;
```

2. **Redis缓存优化**
```java
@Cacheable(value = "accountStats", key = "#accountType", unless = "#result == null")
public BigDecimal getAccountTypeBalance(AccountType accountType) {
    // 原始查询逻辑
}
```

#### 问题：复杂EXISTS子查询
```sql
-- 原始查询 (性能瓶颈)
SELECT * FROM option_order o 
WHERE o.account_type = 'REAL' 
  AND o.status = 'WIN' 
  AND NOT EXISTS (
    SELECT 1 FROM btse_transfer_log b 
    WHERE b.order_id = o.id 
      AND b.direction = 'OUT' 
      AND b.status = 'SUCCESS'
  )
```

**优化方案：**
1. **LEFT JOIN重写**
```sql
SELECT o.* 
FROM option_order o 
LEFT JOIN btse_transfer_log b ON (b.order_id = o.id AND b.direction = 'OUT' AND b.status = 'SUCCESS')
WHERE o.account_type = 'REAL' 
  AND o.status = 'WIN' 
  AND b.id IS NULL
```

2. **专用索引**
```sql
CREATE INDEX idx_btse_transfer_order_direction_status ON btse_transfer_log (order_id, direction, status);
```

### 2. 历史查询优化 (PostgreSQL窗口函数)

#### 问题：复杂分组查询
```sql
-- MySQL版本 (性能较差)
SELECT DISTINCT round_id 
FROM option_order o 
WHERE o.user_id = #{userId} 
  AND o.status IN ('WIN', 'LOSE') 
GROUP BY round_id 
ORDER BY MAX(o.settle_time) DESC
```

**PostgreSQL优化版本已实现：**
```sql
SELECT round_id 
FROM (
  SELECT round_id, 
         ROW_NUMBER() OVER (PARTITION BY round_id ORDER BY settle_time DESC) as rn,
         MAX(settle_time) OVER (PARTITION BY round_id) as max_settle_time
  FROM option_order 
  WHERE user_id = #{userId} 
    AND status IN ('WIN', 'LOSE')
) t 
WHERE rn = 1 
ORDER BY max_settle_time DESC
```

**配套索引：**
```sql
CREATE INDEX idx_order_user_status_settle ON option_order (user_id, status, settle_time DESC);
```

### 3. 分页查询优化

#### 深度分页问题
**问题识别：**
- `LIMIT #{limit} OFFSET #{offset}` 在大数据量时性能急剧下降
- OFFSET越大，扫描行数越多

**优化方案：**
1. **游标分页 (Cursor Pagination)**
```sql
-- 替代 OFFSET 分页
SELECT * FROM option_order 
WHERE user_id = #{userId} 
  AND create_time < #{lastCreateTime}  -- 游标条件
ORDER BY create_time DESC 
LIMIT #{limit}
```

2. **ID范围分页**
```sql
-- 基于ID的分页
SELECT * FROM option_order 
WHERE user_id = #{userId} 
  AND id < #{lastId}  -- 游标条件
ORDER BY id DESC 
LIMIT #{limit}
```

## 数据库特定优化

### MySQL优化配置
```sql
-- 查询缓存 (适用于读多写少场景)
SET GLOBAL query_cache_type = ON;
SET GLOBAL query_cache_size = 268435456; -- 256MB

-- InnoDB优化
SET GLOBAL innodb_buffer_pool_size = 1073741824; -- 1GB
SET GLOBAL innodb_log_file_size = 268435456; -- 256MB

-- 慢查询日志
SET GLOBAL slow_query_log = ON;
SET GLOBAL long_query_time = 0.1; -- 100ms
```

### PostgreSQL优化配置
```sql
-- 共享缓冲区
ALTER SYSTEM SET shared_buffers = '256MB';

-- 工作内存
ALTER SYSTEM SET work_mem = '4MB';

-- 维护工作内存
ALTER SYSTEM SET maintenance_work_mem = '64MB';

-- 统计信息收集
ALTER SYSTEM SET default_statistics_target = 100;

-- 预写日志
ALTER SYSTEM SET wal_buffers = '16MB';
```

## 关键表索引DDL

### 核心业务表索引
```sql
-- ======================
-- account 表索引 (核心)
-- ======================
ALTER TABLE account ADD PRIMARY KEY (id);
CREATE UNIQUE INDEX uk_account_user_type_currency ON account (user_id, account_type, currency);
CREATE INDEX idx_account_user_id ON account (user_id);
CREATE INDEX idx_account_type ON account (account_type);
CREATE INDEX idx_account_balance ON account (balance) WHERE balance > 0;
CREATE INDEX idx_account_update_time ON account (update_time DESC);

-- ======================
-- option_order 表索引 (核心)
-- ======================
ALTER TABLE option_order ADD PRIMARY KEY (id);
CREATE INDEX idx_order_user_account_time ON option_order (user_id, account_type, create_time DESC);
CREATE INDEX idx_order_round_status ON option_order (round_id, status);
CREATE INDEX idx_order_status_time ON option_order (status, create_time DESC);
CREATE INDEX idx_order_settle_time ON option_order (settle_time DESC) WHERE settle_time IS NOT NULL;
CREATE INDEX idx_order_user_profit ON option_order (user_id, account_type, profit) WHERE profit IS NOT NULL;
CREATE INDEX idx_order_time_range ON option_order (user_id, account_type, create_time);

-- ======================
-- trading_round 表索引 (高频)
-- ======================
ALTER TABLE trading_round ADD PRIMARY KEY (id);
CREATE UNIQUE INDEX uk_trading_round_no ON trading_round (round_no);
CREATE UNIQUE INDEX uk_trading_round_symbol_time ON trading_round (symbol_id, start_time, duration_minutes);
CREATE INDEX idx_trading_round_current ON trading_round (symbol_id, duration_minutes, status, start_time, end_time);
CREATE INDEX idx_trading_round_settlement ON trading_round (status, end_time);
CREATE INDEX idx_trading_round_lock ON trading_round (status, lock_time);

-- ======================
-- account_transaction 表索引
-- ======================
ALTER TABLE account_transaction ADD PRIMARY KEY (id);
CREATE INDEX idx_transaction_user_time ON account_transaction (user_id, create_time DESC);
CREATE INDEX idx_transaction_account_time ON account_transaction (account_id, create_time DESC);
CREATE INDEX idx_transaction_type ON account_transaction (type);
CREATE INDEX idx_transaction_ref ON account_transaction (ref_type, ref_id);

-- ======================
-- btse_transfer_log 表索引
-- ======================
ALTER TABLE btse_transfer_log ADD PRIMARY KEY (id);
CREATE INDEX idx_btse_transfer_timeout ON btse_transfer_log (direction, status, create_time);
CREATE INDEX idx_btse_transfer_order ON btse_transfer_log (order_id, direction, status, create_time DESC);
CREATE INDEX idx_btse_transfer_user ON btse_transfer_log (user_id, direction, create_time DESC);
CREATE INDEX idx_btse_transfer_id ON btse_transfer_log (transfer_id);
CREATE INDEX idx_btse_transfer_trace ON btse_transfer_log (trace_id);
```

### 风控和配置表索引
```sql
-- ======================
-- blacklist 表索引
-- ======================
ALTER TABLE blacklist ADD PRIMARY KEY (id);
CREATE INDEX idx_blacklist_user_status_time ON blacklist (user_id, status, start_time, end_time);
CREATE INDEX idx_blacklist_time_range ON blacklist (start_time, end_time);

-- ======================
-- risk_log 表索引
-- ======================
ALTER TABLE risk_log ADD PRIMARY KEY (id);
CREATE INDEX idx_risk_log_user_time ON risk_log (user_id, create_time DESC);
CREATE INDEX idx_risk_log_order ON risk_log (order_id, create_time DESC);
CREATE INDEX idx_risk_log_type_time ON risk_log (risk_type, create_time DESC);
CREATE INDEX idx_risk_log_action_time ON risk_log (action_taken, create_time DESC);
CREATE INDEX idx_risk_log_time_range ON risk_log (create_time DESC);

-- ======================
-- risk_config 表索引
-- ======================
ALTER TABLE risk_config ADD PRIMARY KEY (id);
CREATE UNIQUE INDEX uk_risk_config_key ON risk_config (config_key);
CREATE INDEX idx_risk_config_type_enabled ON risk_config (config_type, enabled);

-- ======================
-- global_config 表索引
-- ======================
ALTER TABLE global_config ADD PRIMARY KEY (id);
CREATE UNIQUE INDEX uk_global_config_key ON global_config (config_key);
CREATE INDEX idx_global_config_enabled ON global_config (enabled, config_group);

-- ======================
-- symbol_config 表索引
-- ======================
ALTER TABLE symbol_config ADD PRIMARY KEY (id);
CREATE UNIQUE INDEX uk_symbol_config_symbol ON symbol_config (symbol);
CREATE INDEX idx_symbol_config_enabled ON symbol_config (enabled, sort_order);

-- ======================
-- user 表索引
-- ======================
ALTER TABLE "user" ADD PRIMARY KEY (id);
CREATE UNIQUE INDEX uk_user_external_id ON "user" (external_id);
CREATE INDEX idx_user_create_time ON "user" (create_time DESC);
CREATE INDEX idx_user_status ON "user" (status);
```

## 查询性能优化建议

### 1. 批量操作优化

#### 批量插入优化
```sql
-- 风控日志批量插入 (已实现)
INSERT INTO risk_log (user_id, order_id, risk_type, ...) VALUES
  (?, ?, ?, ...),
  (?, ?, ?, ...),
  (?, ?, ?, ...);
```

**建议：**
- 批量大小控制在500-1000条
- 使用事务包装批量操作
- 考虑使用LOAD DATA INFILE (MySQL) 或 COPY (PostgreSQL)

### 2. 时间范围查询优化

#### 分区表策略 (大数据量场景)
```sql
-- account_transaction 按月分区 (PostgreSQL)
CREATE TABLE account_transaction (
    id BIGSERIAL,
    user_id BIGINT NOT NULL,
    create_time TIMESTAMP NOT NULL,
    ...
) PARTITION BY RANGE (create_time);

-- 创建月度分区
CREATE TABLE account_transaction_202501 PARTITION OF account_transaction
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

CREATE TABLE account_transaction_202502 PARTITION OF account_transaction
    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');
```

#### 时间范围查询索引策略
```sql
-- 基于时间的复合索引 (覆盖查询条件)
CREATE INDEX idx_order_user_time_status ON option_order (user_id, create_time, status);
CREATE INDEX idx_transaction_time_type ON account_transaction (create_time, type);
```

### 3. 聚合查询优化

#### 统计表策略
```sql
-- 创建每日统计表
CREATE TABLE daily_order_stats (
    stat_date DATE PRIMARY KEY,
    account_type VARCHAR(10) NOT NULL,
    total_orders BIGINT DEFAULT 0,
    total_amount DECIMAL(20,8) DEFAULT 0,
    total_profit DECIMAL(20,8) DEFAULT 0,
    win_orders BIGINT DEFAULT 0,
    lose_orders BIGINT DEFAULT 0,
    win_rate DECIMAL(5,4) DEFAULT 0,
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_daily_stats_type_date ON daily_order_stats (account_type, stat_date DESC);
```

#### 增量统计更新
```java
// 触发器或定时任务更新统计
@Scheduled(cron = "0 1 0 * * ?") // 每天凌晨1点
public void updateDailyStats() {
    // 计算昨日统计数据
    // 更新daily_order_stats表
}
```

## 数据库版本差异优化

### MySQL专用优化
```sql
-- 分区表 (基于时间)
ALTER TABLE account_transaction 
PARTITION BY RANGE (YEAR(create_time)) (
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);

-- 全文索引 (描述字段)
ALTER TABLE risk_log ADD FULLTEXT(description);
```

### PostgreSQL专用优化
```sql
-- 部分索引 (条件索引)
CREATE INDEX idx_order_active ON option_order (user_id, create_time DESC) 
WHERE status = 'ACTIVE';

CREATE INDEX idx_account_positive_balance ON account (user_id, account_type) 
WHERE balance > 0;

-- 表达式索引
CREATE INDEX idx_user_lower_email ON "user" (LOWER(email));

-- GIN索引 (JSON字段，如果有)
CREATE INDEX idx_transfer_request_data ON btse_transfer_log USING GIN (request_data);
```

## 监控和维护建议

### 1. 性能监控
```sql
-- MySQL慢查询监控
SELECT 
    query_time,
    lock_time,
    rows_examined,
    rows_sent,
    sql_text
FROM mysql.slow_log 
WHERE start_time > DATE_SUB(NOW(), INTERVAL 1 DAY)
ORDER BY query_time DESC;

-- PostgreSQL慢查询监控
SELECT 
    query,
    calls,
    total_time,
    mean_time,
    max_time
FROM pg_stat_statements 
WHERE total_time > 1000  -- 超过1秒的查询
ORDER BY total_time DESC;
```

### 2. 索引维护
```sql
-- MySQL索引使用率检查
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    CARDINALITY,
    SEQ_IN_INDEX,
    COLUMN_NAME
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = 'binary_option'
ORDER BY TABLE_NAME, INDEX_NAME;

-- PostgreSQL索引使用统计
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE idx_tup_read > 0
ORDER BY idx_tup_read DESC;
```

### 3. 定期维护任务
```sql
-- MySQL表优化
OPTIMIZE TABLE account, option_order, trading_round;

-- PostgreSQL统计信息更新
ANALYZE account;
ANALYZE option_order;
ANALYZE trading_round;

-- 重建索引 (必要时)
REINDEX INDEX idx_order_user_account_time;
```

## 缓存策略建议

### 1. Redis缓存层次
```yaml
# 应用层缓存配置
cache:
  redis:
    # L1: 热点数据 (1分钟)
    hot-data-ttl: 60
    # L2: 配置数据 (1小时)  
    config-ttl: 3600
    # L3: 统计数据 (5分钟)
    stats-ttl: 300
```

### 2. 缓存失效策略
```java
@CacheEvict(value = "accountStats", allEntries = true)
public void evictAccountStatsCache() {
    // 账户操作后清理缓存
}

@CachePut(value = "symbolConfig", key = "#symbol")
public SymbolConfig updateSymbolConfig(String symbol, SymbolConfig config) {
    // 更新后刷新缓存
}
```

## 总结和实施优先级

### 🔴 第一优先级 (立即实施)
1. **account表复合索引**: `idx_account_user_type_currency`
2. **option_order用户索引**: `idx_order_user_account_time`
3. **trading_round当前轮次索引**: `idx_trading_round_current`
4. **btse_transfer_log超时索引**: `idx_btse_transfer_timeout`

### 🟡 第二优先级 (1周内实施)
1. 覆盖索引优化高频查询
2. 分区表策略 (历史数据)
3. 物化视图 (聚合查询)
4. Redis缓存集成

### 🟢 第三优先级 (1月内实施)
1. 深度分页游标优化
2. 全文索引 (搜索功能)
3. 表达式索引 (PostgreSQL)
4. 监控和告警系统

### 预期性能提升
- **查询响应时间**: 减少60-80%
- **并发处理能力**: 提升3-5倍
- **数据库CPU使用率**: 降低40-60%
- **磁盘I/O**: 减少50-70%

---

*最后更新: 2025-09-01*
*文档版本: v1.0*