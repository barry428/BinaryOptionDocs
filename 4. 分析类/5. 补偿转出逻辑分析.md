# 补偿转出逻辑分析

## 当前补偿机制分析

### 1. 补偿触发条件
```java
// 定时任务：每5秒执行一次
// 处理超时5分钟的PENDING转出记录
@Scheduled(fixedRate = 5000)
List<BtseTransferLog> pendingRecords = btseTransferLogMapper.findTimeoutPendingTransfers(
    BusinessConstants.BtseTransferDirection.OUT, 
    timeoutTime,  // 5分钟前
    BusinessConstants.BtseTransferStatus.PENDING,
    maxRecords    // 最多100条
);
```

### 2. 补偿处理逻辑
```java
// 查询BTSE实际状态 → 根据实际状态进行补偿
BtseTransferStatusDTO actualStatus = queryTransferStatus(transferLog.getTraceId());

if (actualStatus.getStatus().equals("SUCCESS")) {
    // 实际成功：清除frozen_balance
    handleSuccessfulTransferOutCompensation();
} else if (actualStatus.getStatus().equals("FAILED")) {
    // 实际失败：frozen_balance → balance（退回资金）
    handleFailedTransferOutCompensation();
} else {
    // 状态未确定：继续等待
    return false;
}
```

### 3. 当前关联字段
```java
// btse_transfer_log表字段
private Long orderId;  // 关联订单ID - 将删除
```

## 新方案下的调整需求

### 1. 表结构调整
```sql
-- 删除字段
ALTER TABLE btse_transfer_log DROP COLUMN order_id;

-- 新增字段
ALTER TABLE btse_transfer_log ADD COLUMN transfer_type VARCHAR(20) NOT NULL DEFAULT 'MANUAL_OUT';
ALTER TABLE btse_transfer_log ADD COLUMN refer_id BIGINT;

-- 更新现有数据
UPDATE btse_transfer_log SET 
    transfer_type = CASE 
        WHEN direction = 'IN' THEN 'ORDER_IN'
        WHEN direction = 'OUT' THEN 'MANUAL_OUT'
    END,
    refer_id = order_id
WHERE order_id IS NOT NULL;
```

### 2. 补偿逻辑调整

#### 原方案补偿逻辑（保持不变）
```java
// ✅ 转入补偿：ORDER_IN类型，refer_id为订单ID
compensateTransferInRecord(transferLog) {
    // 逻辑保持不变：
    // 1. 查询BTSE实际状态
    // 2. 成功→更新余额+取消订单+退还
    // 3. 失败→更新状态为FAILED
}

// ✅ 原转出补偿：MANUAL_OUT类型，refer_id为空或其他
compensateTransferOutRecord(transferLog) {
    // 逻辑保持不变：
    // 1. 查询BTSE实际状态  
    // 2. 成功→清除frozen_balance
    // 3. 失败→frozen_balance回到balance
}
```

#### 新增补偿逻辑
```java
// 🆕 轮次转出补偿：ROUND_OUT类型，refer_id为轮次ID
compensateRoundTransferOutRecord(transferLog) {
    // 新逻辑：
    // 1. 查询BTSE实际状态
    // 2. 成功→清除frozen_balance
    // 3. 失败→frozen_balance回到balance
    // 4. 特殊处理：可能需要更新user_round表状态
}
```

### 3. 定时任务调整

#### 现有定时任务（保持不变）
```java
@Scheduled(fixedRate = 5000)
public void executeTransferInCompensationTask() {
    // ✅ 处理ORDER_IN类型的补偿
    compensatePendingTransferIn(5, 100);
}

@Scheduled(fixedRate = 5000) 
public void executeTransferOutCompensationTask() {
    // ✅ 处理MANUAL_OUT和ROUND_OUT类型的补偿
    compensatePendingTransferOut(5, 100);
}
```

#### 补偿查询需要调整
```java
// 原查询：按direction查询
List<BtseTransferLog> findTimeoutPendingTransfers(direction, timeoutTime, status, maxRecords)

// 新查询：按transfer_type查询（可选）
List<BtseTransferLog> findTimeoutPendingTransfersByType(transferType, timeoutTime, status, maxRecords)
```

## 影响评估

### 1. 无需调整的部分 ✅
- **补偿触发机制**：定时任务频率和超时时间保持不变
- **BTSE状态查询**：使用traceId查询实际状态的逻辑不变
- **资金处理逻辑**：成功清除frozen_balance，失败退回balance的逻辑不变
- **重试机制**：3次重试+递增延迟的策略保持不变

### 2. 需要调整的部分 📝
- **表结构**：删除order_id，增加transfer_type和refer_id
- **实体字段**：BtseTransferLog实体对应调整
- **Mapper查询**：支持按transfer_type筛选（可选）
- **日志记录**：转出时设置正确的transfer_type和refer_id

### 3. 新增补偿逻辑 🆕
- **轮次转出补偿**：处理ROUND_OUT类型的转出记录
- **user_round状态**：转出失败时可能需要标记user_round表

## 推荐调整方案

### 第一阶段：表结构迁移
1. 增加新字段：transfer_type, refer_id
2. 数据迁移：将order_id映射到refer_id
3. 删除旧字段：order_id

### 第二阶段：代码调整
1. 更新BtseTransferLog实体
2. 调整转账记录方法，设置正确的transfer_type
3. 补偿逻辑保持不变（按direction处理即可）

### 第三阶段：轮次转出实现
1. 实现轮次级合并转出
2. 设置transfer_type为ROUND_OUT，refer_id为轮次ID
3. 现有补偿逻辑自动覆盖新类型

## 结论

**补偿逻辑基本不需要调整**，现有的补偿机制已经很完善：
- ✅ 定时任务自动处理超时记录
- ✅ 查询BTSE实际状态进行精确补偿  
- ✅ 资金处理逻辑正确（成功清除，失败退回）
- ✅ 重试和异常处理机制完善

**只需要做表结构调整**，补偿逻辑自动适配新的转出类型。