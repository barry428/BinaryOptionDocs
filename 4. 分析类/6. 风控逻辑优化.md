# 风控逻辑优化方案 - 预计算统计表实现

## 文档概述
本文档描述二元期权交易平台的风控逻辑优化方案，采用预计算统计表方案解决性能瓶颈问题。

## 现有问题分析

### 1. 性能瓶颈
根据SQL查询分析，风控查询是系统的主要压力点之一：
- **查询频率**：每秒51次（1000用户场景）
- **查询类型**：3个时间维度（1天、1周、1月）的订单金额统计
- **触发时机**：每次下单前都需要查询
- **性能影响**：每次下单需要执行3个聚合查询，延迟较高

### 2. 现有查询方式
```sql
-- 查询用户1天内订单总额
SELECT SUM(amount) FROM option_order 
WHERE user_id = ? AND account_type = ? 
AND create_time >= NOW() - INTERVAL '1 DAY';

-- 查询用户1周内订单总额
SELECT SUM(amount) FROM option_order 
WHERE user_id = ? AND account_type = ? 
AND create_time >= NOW() - INTERVAL '7 DAY';

-- 查询用户1月内订单总额
SELECT SUM(amount) FROM option_order 
WHERE user_id = ? AND account_type = ? 
AND create_time >= NOW() - INTERVAL '30 DAY';
```

### 3. 问题总结
- **重复计算**：相同数据多次聚合计算
- **实时查询**：每次都是实时统计，无缓存
- **响应延迟**：影响下单体验
- **数据库压力**：高频聚合查询占用大量资源

---

## 预计算统计表实现方案

### 1. 设计思路
创建专门的用户风控统计表，维护每个用户的实时统计数据，避免每次下单时的重复聚合查询。

### 2. PostgreSQL建表语句

```sql
-- 用户风控统计表
CREATE TABLE user_risk_stats (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    account_type VARCHAR(16) NOT NULL,
    
    -- 今日统计（每日0点重置）
    today_order_count INTEGER DEFAULT 0 NOT NULL,
    today_order_amount NUMERIC(32,16) DEFAULT 0.0000000000000000 NOT NULL,
    today_win_count INTEGER DEFAULT 0 NOT NULL,
    today_loss_count INTEGER DEFAULT 0 NOT NULL,
    today_profit NUMERIC(32,16) DEFAULT 0.0000000000000000 NOT NULL,
    
    -- 本周统计（每周一0点重置）
    week_order_count INTEGER DEFAULT 0 NOT NULL,
    week_order_amount NUMERIC(32,16) DEFAULT 0.0000000000000000 NOT NULL,
    week_win_count INTEGER DEFAULT 0 NOT NULL,
    week_loss_count INTEGER DEFAULT 0 NOT NULL,
    week_profit NUMERIC(32,16) DEFAULT 0.0000000000000000 NOT NULL,
    
    -- 本月统计（每月1日0点重置）
    month_order_count INTEGER DEFAULT 0 NOT NULL,
    month_order_amount NUMERIC(32,16) DEFAULT 0.0000000000000000 NOT NULL,
    month_win_count INTEGER DEFAULT 0 NOT NULL,
    month_loss_count INTEGER DEFAULT 0 NOT NULL,
    month_profit NUMERIC(32,16) DEFAULT 0.0000000000000000 NOT NULL,
    
    -- 累计统计（永不重置）
    total_order_count INTEGER DEFAULT 0 NOT NULL,
    total_order_amount NUMERIC(32,16) DEFAULT 0.0000000000000000 NOT NULL,
    total_win_count INTEGER DEFAULT 0 NOT NULL,
    total_loss_count INTEGER DEFAULT 0 NOT NULL,
    total_profit NUMERIC(32,16) DEFAULT 0.0000000000000000 NOT NULL,
    
    -- 时间标记
    last_order_time TIMESTAMP WITHOUT TIME ZONE,
    last_reset_date DATE,
    last_reset_week DATE,
    last_reset_month DATE,
    
    create_time TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,
    update_time TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,
    
    CONSTRAINT uk_user_risk_stats_user_account UNIQUE (user_id, account_type)
);

-- 创建索引
CREATE INDEX idx_user_risk_stats_user_id ON user_risk_stats (user_id);
CREATE INDEX idx_user_risk_stats_update_time ON user_risk_stats (update_time);
CREATE INDEX idx_user_risk_stats_user_account ON user_risk_stats (user_id, account_type);

-- 创建更新时间触发器
CREATE OR REPLACE FUNCTION update_user_risk_stats_time()
RETURNS TRIGGER AS $$
BEGIN
    NEW.update_time = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_user_risk_stats_time
    BEFORE UPDATE ON user_risk_stats
    FOR EACH ROW
    EXECUTE FUNCTION update_user_risk_stats_time();

-- 添加表注释
COMMENT ON TABLE user_risk_stats IS '用户风控统计表 - 预计算各时间维度的交易统计';
COMMENT ON COLUMN user_risk_stats.id IS '主键ID';
COMMENT ON COLUMN user_risk_stats.user_id IS '用户ID';
COMMENT ON COLUMN user_risk_stats.account_type IS '账户类型 DEMO/REAL';
COMMENT ON COLUMN user_risk_stats.today_order_count IS '今日订单数量';
COMMENT ON COLUMN user_risk_stats.today_order_amount IS '今日订单金额';
COMMENT ON COLUMN user_risk_stats.last_order_time IS '最后下单时间';
COMMENT ON COLUMN user_risk_stats.last_reset_date IS '最后日重置时间';
COMMENT ON COLUMN user_risk_stats.last_reset_week IS '最后周重置时间';
COMMENT ON COLUMN user_risk_stats.last_reset_month IS '最后月重置时间';
```

### 3. 涉及修改的代码文件结构

```
option-order-service/
├── src/main/java/com/binaryoption/orderservice/
│   ├── domain/
│   │   └── UserRiskStats.java                    # 新增：统计表实体类
│   ├── mapper/
│   │   └── UserRiskStatsMapper.java             # 新增：Mapper接口  
│   ├── service/
│   │   ├── UserRiskStatsService.java            # 新增：统计服务类
│   │   ├── OrderService.java                    # 修改：集成统计更新
│   │   └── OrderSettlementService.java          # 修改：结算时更新统计
│   ├── dto/
│   │   └── RiskCheckResult.java                 # 新增：风控检查结果DTO
│   └── scheduled/
│       └── RiskStatsResetTask.java              # 新增：定时重置任务
├── src/main/resources/mapper/
│   └── UserRiskStatsMapper.xml                  # 新增：MyBatis映射文件
└── src/test/java/com/binaryoption/orderservice/service/
    └── UserRiskStatsServiceTest.java            # 新增：单元测试

option-common-dto/
└── src/main/java/com/binaryoption/commondto/risk/
    ├── UserRiskStatsDTO.java                    # 新增：统计数据DTO
    └── RiskCheckResultDTO.java                  # 新增：风控结果DTO

sql/
└── migration/
    └── 2025-09-09-create-user-risk-stats.sql   # 新增：数据库迁移脚本
```

### 4. 核心实现逻辑

#### 4.1 下单时实时更新
```java
@Transactional
public void updateRiskStatsOnOrder(Long userId, String accountType, BigDecimal amount) {
    // 1. 获取或创建统计记录
    UserRiskStats stats = getOrCreateUserRiskStats(userId, accountType);
    
    // 2. 检查并重置周期数据
    checkAndResetPeriodStats(stats);
    
    // 3. 更新统计数据
    stats.setTodayOrderCount(stats.getTodayOrderCount() + 1);
    stats.setTodayOrderAmount(stats.getTodayOrderAmount().add(amount));
    stats.setWeekOrderCount(stats.getWeekOrderCount() + 1);
    stats.setWeekOrderAmount(stats.getWeekOrderAmount().add(amount));
    stats.setMonthOrderCount(stats.getMonthOrderCount() + 1);
    stats.setMonthOrderAmount(stats.getMonthOrderAmount().add(amount));
    stats.setTotalOrderCount(stats.getTotalOrderCount() + 1);
    stats.setTotalOrderAmount(stats.getTotalOrderAmount().add(amount));
    stats.setLastOrderTime(new Date());
    
    // 4. 保存更新
    userRiskStatsMapper.updateByPrimaryKeySelective(stats);
}
```

#### 4.2 结算时统计更新
```java
@Transactional
public void updateRiskStatsOnSettle(Long userId, String accountType, 
                                   String result, BigDecimal profit) {
    UserRiskStats stats = getUserRiskStats(userId, accountType);
    if (stats == null) return;
    
    // 检查并重置周期数据
    checkAndResetPeriodStats(stats);
    
    // 更新输赢统计
    if ("WIN".equals(result)) {
        stats.setTodayWinCount(stats.getTodayWinCount() + 1);
        stats.setWeekWinCount(stats.getWeekWinCount() + 1);
        stats.setMonthWinCount(stats.getMonthWinCount() + 1);
        stats.setTotalWinCount(stats.getTotalWinCount() + 1);
    } else if ("LOSS".equals(result)) {
        stats.setTodayLossCount(stats.getTodayLossCount() + 1);
        stats.setWeekLossCount(stats.getWeekLossCount() + 1);
        stats.setMonthLossCount(stats.getMonthLossCount() + 1);
        stats.setTotalLossCount(stats.getTotalLossCount() + 1);
    }
    
    // 更新盈亏
    stats.setTodayProfit(stats.getTodayProfit().add(profit));
    stats.setWeekProfit(stats.getWeekProfit().add(profit));
    stats.setMonthProfit(stats.getMonthProfit().add(profit));
    stats.setTotalProfit(stats.getTotalProfit().add(profit));
    
    userRiskStatsMapper.updateByPrimaryKeySelective(stats);
}
```

#### 4.3 周期重置逻辑
```java
private void checkAndResetPeriodStats(UserRiskStats stats) {
    LocalDate today = LocalDate.now();
    
    // 检查日重置
    if (stats.getLastResetDate() == null || 
        !stats.getLastResetDate().equals(today)) {
        stats.setTodayOrderCount(0);
        stats.setTodayOrderAmount(BigDecimal.ZERO);
        stats.setTodayWinCount(0);
        stats.setTodayLossCount(0);
        stats.setTodayProfit(BigDecimal.ZERO);
        stats.setLastResetDate(today);
    }
    
    // 检查周重置（每周一）
    LocalDate weekStart = today.with(DayOfWeek.MONDAY);
    if (stats.getLastResetWeek() == null || 
        stats.getLastResetWeek().isBefore(weekStart)) {
        stats.setWeekOrderCount(0);
        stats.setWeekOrderAmount(BigDecimal.ZERO);
        stats.setWeekWinCount(0);
        stats.setWeekLossCount(0);
        stats.setWeekProfit(BigDecimal.ZERO);
        stats.setLastResetWeek(weekStart);
    }
    
    // 检查月重置（每月1日）
    LocalDate monthStart = today.withDayOfMonth(1);
    if (stats.getLastResetMonth() == null || 
        stats.getLastResetMonth().isBefore(monthStart)) {
        stats.setMonthOrderCount(0);
        stats.setMonthOrderAmount(BigDecimal.ZERO);
        stats.setMonthWinCount(0);
        stats.setMonthLossCount(0);
        stats.setMonthProfit(BigDecimal.ZERO);
        stats.setLastResetMonth(monthStart);
    }
}
```

#### 4.4 优化后的风控检查
```java
public RiskCheckResult checkUserRisk(Long userId, String accountType, 
                                    BigDecimal orderAmount) {
    // 1. 直接查询统计表（单次查询）
    UserRiskStats stats = getUserRiskStats(userId, accountType);
    if (stats == null) {
        return RiskCheckResult.pass(); // 新用户直接通过
    }
    
    // 2. 检查并重置周期数据
    checkAndResetPeriodStats(stats);
    
    // 3. 检查各项限制
    RiskConfig config = getRiskConfig();
    
    // 日限额检查
    if (stats.getTodayOrderAmount().add(orderAmount)
            .compareTo(config.getDailyLimit()) > 0) {
        return RiskCheckResult.reject("超过日限额");
    }
    
    // 周限额检查
    if (stats.getWeekOrderAmount().add(orderAmount)
            .compareTo(config.getWeeklyLimit()) > 0) {
        return RiskCheckResult.reject("超过周限额");
    }
    
    // 月限额检查
    if (stats.getMonthOrderAmount().add(orderAmount)
            .compareTo(config.getMonthlyLimit()) > 0) {
        return RiskCheckResult.reject("超过月限额");
    }
    
    // 连续亏损检查
    BigDecimal winRate = calculateWinRate(stats);
    if (winRate.compareTo(config.getMinWinRate()) < 0 && 
        stats.getTodayLossCount() > config.getMaxContinuousLoss()) {
        return RiskCheckResult.warning("连续亏损过多，建议休息");
    }
    
    return RiskCheckResult.pass();
}
```

### 5. 性能对比

| 指标 | 优化前 | 优化后 | 提升 |
|-----|--------|--------|------|
| 查询次数 | 3次聚合查询 | 1次简单查询 | -67% |
| 响应时间 | 30-50ms | 1-3ms | -94% |
| 数据库负载 | 高（聚合计算） | 低（简单查询） | -80% |
| 缓存友好度 | 差（实时变化） | 好（可缓存） | - |

### 6. 实施计划

#### 第一阶段：基础实现（2-3天）
1. 创建数据库表和索引
2. 实现Domain、Mapper、Service基础代码
3. 集成到OrderService和OrderSettlementService
4. 基础单元测试

#### 第二阶段：完善功能（2-3天）
1. 实现周期重置逻辑
2. 添加定时任务和监控
3. 数据迁移和初始化脚本
4. 完整测试覆盖

#### 第三阶段：优化调试（1-2天）
1. 性能测试和调优
2. 数据一致性验证
3. 生产环境部署
4. 监控和报警配置

### 7. 风险控制和监控

#### 7.1 数据一致性保障
- 统计更新与订单操作在同一事务中
- 定期对账脚本验证数据准确性
- 异常数据自动修复机制

#### 7.2 监控指标
- 风控查询响应时间 < 5ms
- 统计更新成功率 > 99.9%
- 周期重置执行成功率
- 数据准确性偏差 < 0.1%

---

*文档版本：v1.0*  
*创建日期：2025-09-09*  
*最后更新：2025-09-09*