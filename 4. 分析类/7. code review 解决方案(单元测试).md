# Code Review 解决方案 - 单元测试

## 一、问题概述

### 单元测试缺失问题 🔶 中等优先级

**问题描述**：
- 核心服务没有对应的单元测试
- 代码质量无法保证
- 重构风险高

**影响范围**：
- OrderService - 订单核心业务逻辑
- AccountService - 账户资金管理
- BtseTransferService - BTSE转账集成
- UserService - 用户管理
- 其他核心业务服务

**当前测试覆盖率**：基本为0%（仅有少量集成测试）

## 二、单元测试方案设计

### 2.1 测试框架选择

**推荐技术栈**：
- **JUnit 5** - 现代化的测试框架
- **Mockito** - Mock对象和依赖注入
- **Spring Boot Test** - Spring上下文测试支持
- **Testcontainers** - 集成测试数据库
- **WireMock** - HTTP服务Mock

**Maven依赖配置**：
```xml
<dependencies>
    <!-- JUnit 5 -->
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter</artifactId>
        <scope>test</scope>
    </dependency>
    
    <!-- Spring Boot Test -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    
    <!-- Testcontainers for database testing -->
    <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>junit-jupiter</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>postgresql</artifactId>
        <scope>test</scope>
    </dependency>
    
    <!-- WireMock for HTTP mocking -->
    <dependency>
        <groupId>com.github.tomakehurst</groupId>
        <artifactId>wiremock-jre8</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

### 2.2 测试分层策略

#### 层级1：单元测试（Unit Tests）
**目标**：测试单个类的逻辑，隔离所有外部依赖

**测试范围**：
- Service层业务逻辑
- Util工具类方法
- Domain对象业务方法
- Converter转换器逻辑

**示例**：
```java
@ExtendWith(MockitoExtension.class)
class OrderServiceTest {
    
    @Mock
    private OrderMapper orderMapper;
    
    @Mock
    private AccountService accountService;
    
    @Mock
    private BtseTransferService btseTransferService;
    
    @InjectMocks
    private OrderService orderService;
    
    @Test
    @DisplayName("创建DEMO订单 - 成功场景")
    void createDemoOrder_Success() {
        // Given
        CreateOrderRequest request = CreateOrderRequest.builder()
            .userId(1L)
            .accountType(BusinessConstants.AccountType.DEMO)
            .amount(BigDecimal.valueOf(100))
            .direction(BusinessConstants.OrderDirection.UP)
            .build();
            
        Account mockAccount = Account.builder()
            .id(1L)
            .userId(1L)
            .balance(BigDecimal.valueOf(1000))
            .build();
            
        when(accountService.getAccountByUserIdAndType(1L, BusinessConstants.AccountType.DEMO))
            .thenReturn(mockAccount);
        when(orderMapper.insert(any(Order.class))).thenReturn(1);
        
        // When
        OrderDTO result = orderService.createOrder(request);
        
        // Then
        assertThat(result).isNotNull();
        assertThat(result.getAmount()).isEqualTo(BigDecimal.valueOf(100));
        assertThat(result.getStatus()).isEqualTo(BusinessConstants.OrderStatus.ACTIVE);
        
        verify(accountService).freezeAmount(1L, BusinessConstants.AccountType.DEMO, BigDecimal.valueOf(100));
        verify(orderMapper).insert(any(Order.class));
    }
    
    @Test
    @DisplayName("创建DEMO订单 - 余额不足")
    void createDemoOrder_InsufficientBalance() {
        // Given
        CreateOrderRequest request = CreateOrderRequest.builder()
            .userId(1L)
            .accountType(BusinessConstants.AccountType.DEMO)
            .amount(BigDecimal.valueOf(2000))
            .build();
            
        Account mockAccount = Account.builder()
            .balance(BigDecimal.valueOf(1000))
            .build();
            
        when(accountService.getAccountByUserIdAndType(anyLong(), anyString()))
            .thenReturn(mockAccount);
        
        // When & Then
        assertThatThrownBy(() -> orderService.createOrder(request))
            .isInstanceOf(BusinessException.class)
            .hasMessageContaining("Insufficient balance");
    }
}
```

#### 层级2：集成测试（Integration Tests）
**目标**：测试组件间的交互，使用真实的数据库

**测试范围**：
- Service与Mapper的集成
- 数据库事务行为
- 复杂业务流程

**示例**：
```java
@SpringBootTest
@Testcontainers
@TestPropertySource(properties = {
    "spring.datasource.url=jdbc:tc:postgresql:13:///test",
    "spring.jpa.hibernate.ddl-auto=create-drop"
})
class OrderServiceIntegrationTest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:13")
            .withDatabaseName("test")
            .withUsername("test")
            .withPassword("test");
    
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private AccountService accountService;
    
    @Autowired
    private TestEntityManager testEntityManager;
    
    @Test
    @Transactional
    @DisplayName("订单结算流程 - 端到端测试")
    void orderSettlement_EndToEnd() {
        // Given - 准备测试数据
        User user = createTestUser();
        Account demoAccount = createTestAccount(user.getId(), BusinessConstants.AccountType.DEMO, BigDecimal.valueOf(1000));
        TradingRound round = createTestTradingRound();
        
        CreateOrderRequest request = CreateOrderRequest.builder()
            .userId(user.getId())
            .accountType(BusinessConstants.AccountType.DEMO)
            .roundId(round.getId())
            .amount(BigDecimal.valueOf(100))
            .direction(BusinessConstants.OrderDirection.UP)
            .build();
        
        // When - 执行业务流程
        OrderDTO order = orderService.createOrder(request);
        orderService.settleOrder(order.getId(), BigDecimal.valueOf(110000), true); // 盈利结算
        
        // Then - 验证结果
        Order settledOrder = testEntityManager.find(Order.class, order.getId());
        assertThat(settledOrder.getStatus()).isEqualTo(BusinessConstants.OrderStatus.WIN);
        assertThat(settledOrder.getProfit()).isGreaterThan(BigDecimal.ZERO);
        
        Account updatedAccount = accountService.getAccountByUserIdAndType(user.getId(), BusinessConstants.AccountType.DEMO);
        assertThat(updatedAccount.getBalance()).isGreaterThan(BigDecimal.valueOf(1000)); // 余额增加
    }
}
```

#### 层级3：合约测试（Contract Tests）
**目标**：测试RPC接口的输入输出合约

**测试范围**：
- RPC Controller接口
- DTO序列化/反序列化
- 参数验证

**示例**：
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class OrderRpcControllerTest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @MockBean
    private OrderService orderService;
    
    @Test
    @DisplayName("RPC接口 - 获取订单统计")
    void getOrderStats_ValidRequest() {
        // Given
        OrderStatsDTO mockStats = OrderStatsDTO.builder()
            .totalOrders(100)
            .winOrders(60)
            .winRate(BigDecimal.valueOf(0.6))
            .build();
            
        when(orderService.getOrderStats(anyLong(), anyString()))
            .thenReturn(mockStats);
        
        GetOrderStatsRequest request = GetOrderStatsRequest.builder()
            .userId(1L)
            .accountType(BusinessConstants.AccountType.DEMO)
            .build();
        
        // When
        ResponseEntity<ApiResponse<OrderStatsDTO>> response = restTemplate.postForEntity(
            "/rpc/order/stats", 
            request, 
            new ParameterizedTypeReference<ApiResponse<OrderStatsDTO>>() {}
        );
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody().getCode()).isEqualTo("SUCCESS");
        assertThat(response.getBody().getData().getTotalOrders()).isEqualTo(100);
    }
}
```

### 2.3 核心服务测试计划

#### OrderService 测试计划
**测试场景**：
- ✅ DEMO订单创建（成功、余额不足、参数验证）
- ✅ REAL订单创建（BTSE转账集成、超时处理）
- ✅ 订单结算（盈利、亏损、平局）
- ✅ 订单取消（PENDING状态、已生效订单）
- ✅ 订单查询（分页、筛选、统计）

#### AccountService 测试计划
**测试场景**：
- ✅ 账户余额操作（冻结、解冻、扣减）
- ✅ 账户统计更新（盈亏、充提记录）
- ✅ 并发安全性（原子操作验证）
- ✅ DEMO账户重置（余额重置、统计清零）

#### BtseTransferService 测试计划
**测试场景**：
- ✅ 转账请求构建（不同类型转账）
- ✅ 响应处理（成功、失败、超时）
- ✅ 补偿机制（超时重试、失败处理）
- ✅ Mock API集成测试

## 三、测试实施计划

### 阶段一：核心服务单元测试（1周）
1. **OrderService** - 优先级最高
   - 订单创建流程测试
   - 订单状态流转测试
   - 边界条件和异常场景

2. **AccountService** - 资金安全关键
   - 余额操作测试
   - 并发安全测试
   - 数据一致性验证

### 阶段二：集成测试和RPC测试（1周）
1. **数据库集成测试**
   - 使用Testcontainers
   - 事务回滚验证
   - 数据完整性检查

2. **RPC接口测试**
   - Controller层测试
   - 参数验证测试
   - 错误处理测试

### 阶段三：测试工具和CI集成（3天）
1. **测试覆盖率**
   - JaCoCo配置
   - 覆盖率目标：80%
   - 覆盖率报告生成

2. **CI/CD集成**
   - Maven test阶段
   - 测试失败阻断构建
   - 测试报告发布

## 四、测试工具配置

### 4.1 JaCoCo 覆盖率配置

```xml
<plugin>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>0.8.7</version>
    <executions>
        <execution>
            <goals>
                <goal>prepare-agent</goal>
            </goals>
        </execution>
        <execution>
            <id>report</id>
            <phase>test</phase>
            <goals>
                <goal>report</goal>
            </goals>
        </execution>
    </executions>
    <configuration>
        <rules>
            <rule>
                <element>BUNDLE</element>
                <limits>
                    <limit>
                        <counter>LINE</counter>
                        <value>COVEREDRATIO</value>
                        <minimum>0.80</minimum>
                    </limit>
                </limits>
            </rule>
        </rules>
    </configuration>
</plugin>
```

### 4.2 测试配置文件

```yaml
# application-test.yml
spring:
  datasource:
    url: jdbc:tc:postgresql:13:///test
    driver-class-name: org.testcontainers.jdbc.ContainerDatabaseDriver
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: true

# Mock服务配置
btse:
  mock:
    enabled: true
    scenarios:
      transferFailureRate: 0.0  # 测试环境不模拟失败
      balanceInsufficientRate: 0.0

# 日志配置
logging:
  level:
    com.binaryoption: DEBUG
    org.springframework.test: DEBUG
```

## 五、质量标准

### 5.1 覆盖率目标
- **整体覆盖率**：≥ 80%
- **核心Service**：≥ 90%
- **工具类Util**：≥ 95%
- **Controller**：≥ 70%

### 5.2 测试质量要求
- **命名规范**：使用@DisplayName提供中文描述
- **测试结构**：Given-When-Then模式
- **断言清晰**：使用AssertJ流式断言
- **Mock合理**：只Mock必要的外部依赖
- **数据隔离**：每个测试独立的数据准备

### 5.3 持续集成要求
- 所有测试必须在CI环境通过
- 测试执行时间 < 5分钟
- 测试失败时提供详细的错误信息
- 定期执行回归测试

## 六、预期收益

### 6.1 代码质量提升
- **Bug减少**：单元测试发现边界条件问题
- **重构安全**：测试保证重构不破坏功能
- **文档作用**：测试用例作为代码使用文档

### 6.2 开发效率提升
- **快速反馈**：本地运行测试快速验证代码
- **调试便利**：测试用例便于问题重现
- **信心增强**：充分的测试覆盖提升部署信心

### 6.3 维护成本降低
- **回归检测**：自动化测试检测功能退化
- **知识传承**：测试用例帮助新人理解业务
- **技术债务**：测试驱动的重构改善代码结构

---

**实施建议**：
1. **分阶段实施**：从核心服务开始，逐步扩展
2. **工具先行**：先配置好测试框架和CI集成
3. **质量优先**：宁可测试少而精，不要多而滥
4. **持续改进**：根据实际执行情况调整测试策略