# WebSocket数据延迟问题分析 - 日志对比方案

## 方案概述

通过在关键节点增加详细日志，对比WebSocket和Fixture API的数据时效性和一致性，精确定位延迟问题。

## 实施方案

### 1. WebSocket数据日志增强

**目标文件**：`option-market-service/src/main/java/com/binaryoption/marketservice/integration/BtseWebSocketClient.java`

**修改方法**：`onExternalMarketData`

**日志内容**：
- 当前系统时间（接收到数据的时间）
- WebSocket消息中的价格数据
- WebSocket消息中的时间戳（如果有）
- 数据处理耗时

**修改示例**：
```java
public void onExternalMarketData(MarketData marketData) {
    long receiveTime = System.currentTimeMillis();
    String receiveTimeStr = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS"));
    
    log.info("=== WebSocket数据接收 ===");
    log.info("接收时间: {} ({})", receiveTimeStr, receiveTime);
    log.info("数据价格: {}", marketData.getPrice());
    log.info("数据时间戳: {}", marketData.getTimestamp()); // 如果有
    log.info("交易对: {}", marketData.getSymbol());
    
    // 原有处理逻辑
    long processStart = System.currentTimeMillis();
    // ... 数据处理 ...
    long processEnd = System.currentTimeMillis();
    
    log.info("数据处理耗时: {}ms", processEnd - processStart);
    log.info("=== WebSocket数据处理完成 ===");
}
```

### 2. Fixture API数据日志增强

**目标文件**：`option-common-service/src/main/java/com/binaryoption/commonservice/integration/BtseMarketApiClientImpl.java`

**修改方法**：`getFixtures`

**日志内容**：
- API调用时间
- API响应时间
- 响应数据中的价格信息
- 响应数据中的时间戳
- API调用耗时

**修改示例**：
```java
@Override
public FixturesResponseDTO getFixtures(String symbol, LocalDateTime includeExpiredAfter) {
    long apiCallStart = System.currentTimeMillis();
    String callTimeStr = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS"));
    
    log.info("=== Fixture API调用开始 ===");
    log.info("调用时间: {} ({})", callTimeStr, apiCallStart);
    log.info("请求交易对: {}", symbol);
    
    try {
        // ... 原有API调用逻辑 ...
        
        ResponseEntity<String> response = btseRestTemplate.exchange(
            uri, HttpMethod.GET, entity, String.class);
            
        long apiCallEnd = System.currentTimeMillis();
        String responseTimeStr = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS"));
        
        log.info("响应时间: {} ({})", responseTimeStr, apiCallEnd);
        log.info("API调用耗时: {}ms", apiCallEnd - apiCallStart);
        
        // 解析响应数据
        Map<String, Object> data = objectMapper.readValue(response.getBody(), Map.class);
        
        // 提取并记录价格相关信息
        if (data.containsKey("fixtures") && data.get("fixtures") instanceof List) {
            List<Map<String, Object>> fixtures = (List<Map<String, Object>>) data.get("fixtures");
            for (Map<String, Object> fixture : fixtures) {
                if (fixture.containsKey("currentPrice")) {
                    log.info("Fixture价格: {}", fixture.get("currentPrice"));
                }
                if (fixture.containsKey("timestamp")) {
                    log.info("Fixture时间戳: {}", fixture.get("timestamp"));
                }
                if (fixture.containsKey("lastUpdated")) {
                    log.info("最后更新时间: {}", fixture.get("lastUpdated"));
                }
            }
        }
        
        log.info("=== Fixture API调用完成 ===");
        
        return dataConverter.convertFixturesResponse(data);
        
    } catch (Exception e) {
        long apiCallEnd = System.currentTimeMillis();
        log.error("=== Fixture API调用失败 ===");
        log.error("失败时间: {}", LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS")));
        log.error("调用耗时: {}ms", apiCallEnd - apiCallStart);
        throw new BtseApiException("Failed to get fixtures", e);
    }
}
```

### 3. 日志格式统一

**为了便于对比分析，建议统一日志格式**：

```
2025-10-13 15:30:45.123 [数据源] [交易对] [操作] 价格=67890.12 时间戳=1697189445123 耗时=45ms
```

**示例**：
```
2025-10-13 15:30:45.123 [WebSocket] [BTC-USDT] [接收] 价格=67890.12 时间戳=1697189445000 处理=5ms
2025-10-13 15:30:45.234 [Fixture] [BTC-USDT] [响应] 价格=67890.15 时间戳=1697189445100 耗时=156ms
```

**统一日志方法**：
```java
// 统一的日志记录方法
private void logMarketData(String source, String symbol, String operation, 
                          Object price, Long timestamp, Long duration) {
    log.info("[{}] [{}] [{}] 价格={} 时间戳={} {}={}ms", 
        source, symbol, operation, price, timestamp, 
        operation.equals("接收") ? "处理" : "耗时", duration);
}

// WebSocket中调用
logMarketData("WebSocket", marketData.getSymbol(), "接收", 
    marketData.getPrice(), marketData.getTimestamp(), processingTime);

// Fixture API中调用  
logMarketData("Fixture", symbol, "响应", 
    currentPrice, responseTimestamp, apiCallDuration);
```

## 测试执行计划

### 步骤1：部署日志增强代码

1. 修改 `BtseWebSocketClient.java` 的 `onExternalMarketData` 方法
2. 修改 `BtseMarketApiClientImpl.java` 的 `getFixtures` 方法
3. 重启相关服务
4. 确认日志正常输出

### 步骤2：执行并发测试

**测试脚本**：
```bash
#!/bin/bash
# 并发数据获取测试

echo "开始数据对比测试..."

# 同时触发WebSocket和Fixture API数据获取
for i in {1..10}; do
    echo "=== 第${i}次测试 $(date) ==="
    
    # 触发Fixture API调用
    curl -s "http://localhost:8081/api/btse/fixtures?symbol=BTC-USDT" > /dev/null &
    
    # 等待1秒让WebSocket也有数据推送
    sleep 1
    
    echo "等待数据处理..."
    sleep 2
done

echo "测试完成，请检查日志文件"
```

### 步骤3：日志分析

**日志收集**：
```bash
# 提取WebSocket相关日志
grep "\[WebSocket\]" logs/option-market-service.log > ws_data.log

# 提取Fixture API相关日志  
grep "\[Fixture\]" logs/option-common-service.log > fixture_data.log

# 按时间合并排序
sort -k1,2 ws_data.log fixture_data.log > combined_data.log
```

**分析维度**：

1. **时间差异分析**
   ```bash
   # 提取同一时间段的数据
   grep "2025-10-13 15:30:" combined_data.log
   ```

2. **价格差异分析**
   ```bash
   # 提取价格数据进行对比
   grep -oP '价格=\K[0-9.]+' combined_data.log
   ```

3. **延迟分析**
   ```bash
   # 分析处理耗时
   grep -oP '(耗时|处理)=\K[0-9]+' combined_data.log
   ```

## 预期结果分析

### 场景1：BTSE WebSocket本身延迟

**日志特征**：
```
15:30:45.123 [Fixture] [BTC-USDT] [响应] 价格=67890.15 时间戳=1697189445100 耗时=156ms
15:30:47.234 [WebSocket] [BTC-USDT] [接收] 价格=67890.15 时间戳=1697189445100 处理=5ms
```

**分析**：
- 相同价格，相同时间戳，但WebSocket晚了2秒才收到
- 说明BTSE WebSocket推送确实有延迟

### 场景2：项目WebSocket处理延迟

**日志特征**：
```
15:30:45.123 [WebSocket] [BTC-USDT] [接收] 价格=67890.15 时间戳=1697189445000 处理=2000ms
15:30:45.234 [Fixture] [BTC-USDT] [响应] 价格=67890.15 时间戳=1697189445100 耗时=156ms
```

**分析**：
- WebSocket接收时间正常，但处理耗时过长
- 说明项目内部处理逻辑存在性能问题

### 场景3：数据源不一致

**日志特征**：
```
15:30:45.123 [WebSocket] [BTC-USDT] [接收] 价格=67890.15 时间戳=1697189445000 处理=5ms
15:30:45.234 [Fixture] [BTC-USDT] [响应] 价格=67892.30 时间戳=1697189445100 耗时=156ms
```

**分析**：
- 价格不同，时间戳不同
- 可能是两个数据源更新频率不同

## 日志监控脚本

**实时监控脚本**：
```bash
#!/bin/bash
# real_time_monitor.sh

echo "实时监控WebSocket和Fixture数据差异..."

tail -f logs/*.log | grep -E "\[(WebSocket|Fixture)\]" | while read line; do
    echo "$(date '+%H:%M:%S') $line"
    
    # 检查价格差异
    if echo "$line" | grep -q "价格="; then
        price=$(echo "$line" | grep -oP '价格=\K[0-9.]+')
        echo "  -> 价格: $price"
    fi
done
```

**异常告警脚本**：
```bash
#!/bin/bash
# alert_monitor.sh

# 监控延迟超过1秒的情况
tail -f logs/*.log | grep -E "\[(WebSocket|Fixture)\]" | while read line; do
    if echo "$line" | grep -q "耗时="; then
        duration=$(echo "$line" | grep -oP '耗时=\K[0-9]+')
        if [ "$duration" -gt 1000 ]; then
            echo "⚠️  高延迟告警: ${duration}ms - $line"
        fi
    fi
done
```

## 总结

通过这个日志对比方案，我们可以：

1. **精确定位延迟源头**：通过时间戳对比确定是BTSE源头延迟还是项目处理延迟
2. **量化性能瓶颈**：通过耗时统计找到具体的性能问题点
3. **验证数据一致性**：通过价格对比确认两个数据源的一致性
4. **建立监控基线**：为后续性能优化提供数据支撑

执行完这个方案后，我们将有足够的数据来判断问题的根本原因，并制定针对性的解决方案。