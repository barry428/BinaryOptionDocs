# 二元期权平台 SQL查询整理文档

## 文档概述
本文档整理了二元期权交易平台中所有MyBatis Mapper的SQL查询语句，用于性能分析和优化参考。

## 服务架构
- **option-common-service** : 账户管理、BTSE集成、用户管理
- **option-order-service** : 订单处理、风控、交易轮次

---

## option-common-service SQL查询分析

### 1. AccountMapper.xml - 账户管理核心查询

#### 1.1 基础查询
```sql
-- 根据ID查询账户
SELECT id, user_id, account_type, currency, balance, frozen_balance, 
       total_deposit, total_withdraw, total_profit, total_loss, 
       reset_count, last_reset_time, create_time, update_time
FROM account 
WHERE id = #{id}

-- 索引: PRIMARY KEY (id)
```

```sql
-- 根据用户ID查询账户列表
SELECT id, user_id, account_type, currency, balance, frozen_balance, 
       total_deposit, total_withdraw, total_profit, total_loss, 
       reset_count, last_reset_time, create_time, update_time
FROM account 
WHERE user_id = #{userId} 
ORDER BY account_type, currency

-- 索引: CREATE INDEX idx_account_user_id ON account (user_id);
```

```sql
-- 根据用户ID和账户类型查询账户 (高频)
SELECT id, user_id, account_type, currency, balance, frozen_balance, 
       total_deposit, total_withdraw, total_profit, total_loss, 
       reset_count, last_reset_time, create_time, update_time
FROM account 
WHERE user_id = #{userId} 
  AND account_type = #{accountType}

-- 索引: CREATE INDEX idx_account_user_type ON account (user_id, account_type);
```

#### 1.2 写入操作
```sql
-- 插入新账户记录
INSERT INTO account (
    user_id, account_type, currency, balance, frozen_balance, 
    total_deposit, total_withdraw, total_profit, total_loss, 
    reset_count, last_reset_time, create_time, update_time
) VALUES (
    #{userId}, #{accountType}, #{currency}, #{balance}, #{frozenBalance},
    #{totalDeposit}, #{totalWithdraw}, #{totalProfit}, #{totalLoss},
    #{resetCount}, #{lastResetTime}, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
)

-- 索引: PRIMARY KEY (id), UNIQUE (user_id, account_type)
```

#### 1.3 原子更新操作
```sql
-- 原子性余额变更 (业务核心，并发安全)
UPDATE account 
SET balance = balance + #{balanceChange}, 
    frozen_balance = frozen_balance + #{frozenChange}, 
    update_time = CURRENT_TIMESTAMP 
WHERE id = #{id} 
  AND balance + #{balanceChange} >= 0 
  AND frozen_balance + #{frozenChange} >= 0

-- 索引: PRIMARY KEY (id)
```

```sql
-- 专用转出冻结操作
UPDATE account 
SET balance = balance - #{amount}, 
    frozen_balance = frozen_balance + #{amount}, 
    update_time = CURRENT_TIMESTAMP 
WHERE id = #{id} 
  AND balance >= #{amount}

-- 索引: PRIMARY KEY (id)
```

#### 1.4 统计对账查询
```sql
-- 账户余额平衡检查 (对账使用)
SELECT COALESCE(SUM(total_deposit) - SUM(total_withdraw) - SUM(balance) - SUM(frozen_balance) + SUM(total_profit) - SUM(total_loss), 0) 
FROM account 
WHERE account_type = #{accountType}

-- 索引: CREATE INDEX idx_account_type ON account (account_type);
```

```sql
-- 账户汇总数据查询 (对账详情)
SELECT SUM(total_deposit) as total_deposit,
       SUM(total_withdraw) as total_withdraw,
       SUM(balance) as current_balance,
       SUM(frozen_balance) as current_frozen_balance,
       SUM(total_profit) as account_total_profit,
       SUM(total_loss) as account_total_loss
FROM account 
WHERE account_type = #{accountType}

-- 索引: CREATE INDEX idx_account_type ON account (account_type);
```

### 2. AccountTransactionMapper.xml - 交易流水查询

#### 2.1 写入操作
```sql
-- 插入交易流水记录 (每次余额变动都会记录)
INSERT INTO account_transaction (
    user_id, account_id, type, amount, frozen_amount, 
    balance_before, balance_after, frozen_before, frozen_after, 
    ref_id, ref_type, description, remark, create_time
) VALUES (
    #{userId}, #{accountId}, #{type}, #{amount}, 
    COALESCE(#{frozenAmount}, 0), #{balanceBefore}, #{balanceAfter},
    COALESCE(#{frozenBefore}, 0), COALESCE(#{frozenAfter}, 0),
    #{refId}, #{refType}, #{description}, #{remark}, 
    COALESCE(#{createTime}, CURRENT_TIMESTAMP)
)

-- 删除流水记录 (极少使用，主要用于数据清理)
DELETE FROM account_transaction WHERE id = ?;

-- 索引: PRIMARY KEY (id), idx_transaction_user_time, idx_transaction_account_time
```

**执行频率**: 高频 - 与AccountMapper同步，每笔资金操作都记录，约1000 QPS
**优化要点**: 自增主键，索引user_id和account_id，支持分库分表

#### 2.2 管理后台查询
```sql
-- 用户流水分页查询 (管理后台使用)
SELECT id, user_id, account_id, type, amount, frozen_amount, 
       balance_before, balance_after, frozen_before, frozen_after, 
       ref_id, ref_type, description, remark, create_time
FROM account_transaction 
WHERE user_id = #{userId} 
ORDER BY create_time DESC 
LIMIT #{limit} OFFSET #{offset}

-- 索引: CREATE INDEX idx_transaction_user_time ON account_transaction (user_id, create_time DESC);
```

```sql
-- 按账户类型查询流水 (对账使用)
SELECT at.id, at.user_id, at.account_id, at.type, at.amount, at.frozen_amount, 
       at.balance_before, at.balance_after, at.frozen_before, at.frozen_after, 
       at.ref_id, at.ref_type, at.description, at.remark, at.create_time
FROM account_transaction at 
INNER JOIN account a ON at.account_id = a.id 
WHERE a.account_type = #{accountType} 
ORDER BY at.create_time DESC 
LIMIT #{limit} OFFSET #{offset}

-- 索引: 
-- CREATE INDEX idx_transaction_account_time ON account_transaction (account_id, create_time DESC);
-- CREATE INDEX idx_account_type ON account (account_type);
```

#### 2.2 对账聚合查询
```sql
-- 交易流水金额汇总 (对账检查使用)
SELECT COALESCE(SUM(at.amount + COALESCE(at.frozen_amount, 0)), 0) 
FROM account_transaction at 
INNER JOIN account a ON at.account_id = a.id 
WHERE a.account_type = #{accountType}

-- 索引: 
-- CREATE INDEX idx_transaction_account_id ON account_transaction (account_id);
-- CREATE INDEX idx_account_type ON account (account_type);
```

### 3. BtseTransferLogMapper.xml - BTSE转账日志查询

#### 3.1 超时处理查询
```sql
-- 查询超时转账记录 (定时任务使用)
SELECT id, trace_id, user_id, order_id, direction, amount, currency, 
       transfer_id, api_method, status, error_message, request_data, 
       response_data, retry_count, environment, is_mock, 
       request_time, response_time, create_time, update_time
FROM btse_transfer_log 
WHERE direction = #{direction} 
  AND status = #{status} 
  AND create_time < #{timeoutTime} 
ORDER BY create_time ASC 
LIMIT #{limit}

-- 索引: CREATE INDEX idx_btse_transfer_timeout ON btse_transfer_log (direction, status, create_time);
```

#### 3.2 订单转账记录查询
```sql
-- 查询订单成功转账记录
SELECT id, trace_id, user_id, order_id, direction, amount, currency, 
       transfer_id, api_method, status, error_message, request_data, 
       response_data, retry_count, environment, is_mock, 
       request_time, response_time, create_time, update_time
FROM btse_transfer_log 
WHERE order_id = #{orderId} 
  AND direction = #{direction} 
  AND status = 'SUCCESS' 
ORDER BY create_time DESC 
LIMIT 1

-- 索引: CREATE INDEX idx_btse_transfer_order ON btse_transfer_log (order_id, direction, status, create_time DESC);
```

#### 3.3 写入操作 (INSERT/UPDATE/DELETE)
```sql
-- 记录BTSE转账操作
INSERT INTO btse_transfer_log (
    trace_id, user_id, order_id, direction, amount, currency, 
    transfer_id, api_method, status, error_message, request_data, 
    response_data, retry_count, environment, is_mock, 
    request_time, response_time, create_time, update_time
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, 'PENDING', ?, ?, ?, 0, ?, ?, 
         CURRENT_TIMESTAMP, NULL, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP);

-- 更新转账状态
UPDATE btse_transfer_log SET
    status = ?,
    transfer_id = ?,
    response_data = ?,
    response_time = CURRENT_TIMESTAMP,
    update_time = CURRENT_TIMESTAMP
WHERE trace_id = ? AND direction = ?;

-- 更新转账错误信息
UPDATE btse_transfer_log SET
    status = 'FAILED',
    error_message = ?,
    response_time = CURRENT_TIMESTAMP,
    update_time = CURRENT_TIMESTAMP
WHERE id = ?;
```

**执行频率**: 低频 - REAL账户转账约50 QPS，状态更新约50 QPS
**优化要点**: trace_id索引，复合索引(direction, status, create_time)支持补偿查询

### 4. GlobalConfigMapper.xml - 全局配置查询

```sql
-- 根据配置键查询 (高频访问)
SELECT id, config_key, config_value, config_type, config_group, 
       description, enabled, sort_order, create_time, update_time
FROM global_config 
WHERE config_key = #{configKey} 
  AND enabled = 1

-- 索引: CREATE UNIQUE INDEX uk_global_config_key ON global_config (config_key);
```

### 5. SymbolConfigMapper.xml - 交易对配置查询

```sql
-- 查询启用的交易对
SELECT id, symbol, base_currency, quote_currency, enabled, 
       min_amount, max_amount, btse_symbol, sort_order, 
       create_time, update_time
FROM symbol_config 
WHERE enabled = 1 
ORDER BY sort_order, id

-- 索引: CREATE INDEX idx_symbol_config_enabled ON symbol_config (enabled, sort_order);
```

### 6. UserMapper.xml - 用户管理查询

```sql
-- 根据外部ID查询用户 (OAuth认证高频使用)
SELECT id, external_id, password, nickname, email, phone, 
       status, signature, risk_agreement, aml_agreement, 
       create_time, update_time
FROM "user" 
WHERE external_id = #{externalId}

-- 索引: CREATE UNIQUE INDEX uk_user_external_id ON "user" (external_id);
```

```sql
-- 时间范围查询新用户 (统计分析使用)
SELECT id, external_id, password, nickname, email, phone, 
       status, signature, risk_agreement, aml_agreement, 
       create_time, update_time
FROM "user" 
WHERE create_time BETWEEN #{startTime} AND #{endTime} 
ORDER BY create_time DESC

-- 索引: CREATE INDEX idx_user_create_time ON "user" (create_time DESC);
```

---

## option-order-service SQL查询分析

### 7. OrderMapper.xml - 订单管理核心查询

#### 7.1 写入操作
```sql
-- 插入订单记录 (下单时)
INSERT INTO option_order (
    user_id, account_type, symbol_id, round_id, round_no, 
    direction, amount, odds, expected_profit, order_price, 
    status, create_time, update_time
) VALUES (
    #{userId}, #{accountType}, #{symbolId}, #{roundId}, #{roundNo},
    #{direction}, #{amount}, #{odds}, #{expectedProfit}, #{orderPrice},
    #{status}, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
)

-- 索引: PRIMARY KEY (id), idx_order_user_account_time, idx_order_round_status
```

```sql
-- 更新订单状态 (状态变更时)
UPDATE option_order 
SET status = #{status}, 
    update_time = CURRENT_TIMESTAMP 
WHERE id = #{id}

-- 索引: PRIMARY KEY (id)
```

```sql
-- 结算订单 (结算时一次性更新所有结算字段)
UPDATE option_order 
SET status = #{status}, 
    settle_price = #{settlePrice}, 
    profit = #{profit}, 
    fee = #{fee}, 
    settle_time = #{settleTime}, 
    update_time = CURRENT_TIMESTAMP 
WHERE id = #{id}

-- 批量状态更新 (按轮次结算)
UPDATE option_order SET 
    status = ?,
    settle_price = ?,
    profit = ?,
    settle_time = CURRENT_TIMESTAMP,
    update_time = CURRENT_TIMESTAMP
WHERE round_id = ? AND status = 'ACTIVE';

-- 索引: PRIMARY KEY (id), idx_order_round_status
```

**执行频率**: 高频 - 下单约500 QPS，状态更新约200 QPS，结算约50 QPS
**优化要点**: 复合索引(user_id, order_status)，round_id索引支持批量结算

#### 7.2 订单基础查询
```sql
-- 根据ID查询订单
SELECT id, user_id, account_type, symbol_id, round_id, round_no, 
       direction, amount, odds, expected_profit, order_price, settle_price, 
       status, profit, fee, settle_time, cancel_time, 
       create_time, update_time
FROM option_order 
WHERE id = #{id}

-- 索引: PRIMARY KEY (id)
```

```sql
-- 用户订单列表查询 (高频访问)
SELECT id, user_id, account_type, symbol_id, round_id, round_no, 
       direction, amount, odds, expected_profit, order_price, settle_price, 
       status, profit, fee, settle_time, cancel_time, 
       create_time, update_time
FROM option_order 
WHERE user_id = #{userId} 
  AND account_type = #{accountType} 
ORDER BY id DESC 
LIMIT #{limit} OFFSET #{offset}

-- 索引: CREATE INDEX idx_order_user_account_time ON option_order (user_id, account_type, create_time DESC);
```

#### 7.3 结算相关查询
```sql
-- 轮次待结算订单查询 (定时任务关键查询)
SELECT id, user_id, account_type, symbol_id, round_id, round_no, 
       direction, amount, odds, expected_profit, order_price, settle_price, 
       status, profit, fee, settle_time, cancel_time, 
       create_time, update_time
FROM option_order 
WHERE round_id = #{roundId} 
  AND status = 'ACTIVE' 
ORDER BY id ASC

-- 索引: CREATE INDEX idx_order_round_status ON option_order (round_id, status);
```

#### 7.4 统计聚合查询
```sql
-- 用户时间范围金额统计 (风控检查使用)
SELECT COALESCE(SUM(amount), 0) 
FROM option_order 
WHERE user_id = #{userId} 
  AND account_type = #{accountType} 
  AND create_time >= #{startTime}
  AND create_time <= #{endTime}

-- 索引: CREATE INDEX idx_order_user_account_time_range ON option_order (user_id, account_type, create_time);
```

```sql
-- 用户盈利统计
SELECT COALESCE(SUM(profit), 0) 
FROM option_order 
WHERE user_id = #{userId} 
  AND account_type = #{accountType} 
  AND profit IS NOT NULL

-- 索引: CREATE INDEX idx_order_user_profit ON option_order (user_id, account_type, profit) WHERE profit IS NOT NULL;
```

#### 7.5 复杂历史查询

```sql
-- 用户历史轮次ID查询 (MySQL版本)
SELECT DISTINCT round_id
FROM option_order o
WHERE o.user_id = #{userId}
  AND o.account_type = #{accountType}
  AND o.status IN ('WIN', 'LOSE')
GROUP BY round_id
ORDER BY MAX(o.settle_time) DESC
LIMIT #{limit} OFFSET #{offset}

-- 索引: CREATE INDEX idx_order_user_status_settle ON option_order (user_id, account_type, status, settle_time DESC);
```

```sql
-- 用户历史轮次ID查询 (PostgreSQL版本)
SELECT round_id
FROM (
  SELECT round_id, MAX(settle_time) as max_settle_time
  FROM option_order
  WHERE user_id = #{userId}
    AND account_type = #{accountType}
    AND status IN ('WIN', 'LOSE')
  GROUP BY round_id
  ORDER BY max_settle_time DESC
  LIMIT #{limit} OFFSET #{offset}
) subquery

-- 索引: CREATE INDEX idx_order_user_status_settle ON option_order (user_id, account_type, status, settle_time DESC);
-- 注意: 此查询存在性能问题，深度分页时性能下降明显，后续需要优化
```

### 8. TradingRoundMapper.xml - 交易轮次查询

#### 8.1 写入操作
```sql
-- 插入新交易轮次
INSERT INTO trading_round (
    round_no, symbol_id, duration_minutes, start_time, 
    lock_time, end_time, start_price, status,
    total_up_amount, total_down_amount, create_time, update_time
) VALUES (
    #{roundNo}, #{symbolId}, #{durationMinutes}, #{startTime},
    #{lockTime}, #{endTime}, #{startPrice}, #{status},
    0.0, 0.0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
)

-- 轮次状态更新 (OPEN -> LOCKED -> COMPLETED)
UPDATE trading_round SET 
    status = ?,
    update_time = CURRENT_TIMESTAMP
WHERE id = ?;

-- 轮次结算更新
UPDATE trading_round SET 
    status = 'COMPLETED',
    end_price = ?,
    update_time = CURRENT_TIMESTAMP
WHERE id = ?;

-- 原子性投注额更新 (并发安全)
UPDATE trading_round SET 
    total_up_amount = total_up_amount + ?, 
    total_down_amount = total_down_amount + ?, 
    update_time = CURRENT_TIMESTAMP 
WHERE id = ?;

-- 索引: PRIMARY KEY (id), idx_trading_round_current
```

**执行频率**: 低频 - 创建约10 QPS，状态更新约5 QPS，投注额更新约500 QPS
**优化要点**: 复合索引(symbol_id, duration_minutes, status)支持轮次查询

#### 8.2 轮次状态查询
```sql
-- 查询当前进行中轮次 (高频查询，下单时使用)
SELECT id, round_no, symbol_id, duration_minutes, start_time, 
       lock_time, end_time, start_price, end_price, status, 
       total_up_amount, total_down_amount, create_time, update_time
FROM trading_round 
WHERE symbol_id = #{symbolId} 
  AND duration_minutes = #{durationMinutes} 
  AND status IN ('OPEN', 'LOCKED') 
  AND CURRENT_TIMESTAMP BETWEEN start_time AND end_time 
ORDER BY start_time DESC 
LIMIT 1

-- 索引: CREATE INDEX idx_trading_round_current ON trading_round (symbol_id, duration_minutes, status, start_time, end_time);
```

```sql
-- 查询需要结算的轮次 (定时任务使用)
SELECT id, round_no, symbol_id, duration_minutes, start_time, 
       lock_time, end_time, start_price, end_price, status, 
       total_up_amount, total_down_amount, create_time, update_time
FROM trading_round 
WHERE status IN ('OPEN', 'LOCKED') 
  AND end_time <= #{currentTime} 
ORDER BY end_time

-- 索引: CREATE INDEX idx_trading_round_settlement ON trading_round (status, end_time);
```

#### 8.3 轮次更新操作
```sql
-- 原子性投注额更新 (并发安全关键)
UPDATE trading_round 
SET total_up_amount = total_up_amount + #{upAmountChange}, 
    total_down_amount = total_down_amount + #{downAmountChange}, 
    update_time = CURRENT_TIMESTAMP 
WHERE id = #{id}

-- 索引: PRIMARY KEY (id)
```

### 9. BlacklistMapper.xml - 黑名单查询

```sql
-- 查询有效黑名单 (风控检查使用)
SELECT id, user_id, reason, operator_id, operator_name, 
       start_time, end_time, status, create_time, update_time
FROM blacklist 
WHERE user_id = #{userId} 
  AND status = 1 
  AND start_time <= #{currentTime} 
  AND (end_time IS NULL OR end_time > #{currentTime}) 
LIMIT 1

-- 索引: CREATE INDEX idx_blacklist_user_status_time ON blacklist (user_id, status, start_time, end_time);
```

### 10. RiskConfigMapper.xml - 风控配置查询

```sql
-- 根据配置键查询风控配置
SELECT id, config_key, config_value, config_type, description, 
       enabled, create_time, update_time
FROM risk_config 
WHERE config_key = #{configKey}

-- 索引: CREATE UNIQUE INDEX uk_risk_config_key ON risk_config (config_key);
```

### 11. RiskLogMapper.xml - 风控日志查询

```sql
-- 时间范围查询风控日志 (分页查询)
SELECT id, user_id, order_id, risk_type, risk_level, risk_score, 
       trigger_value, threshold_value, action_taken, action_result, 
       description, create_time
FROM risk_log 
WHERE create_time BETWEEN #{startTime} AND #{endTime} 
ORDER BY create_time DESC 
LIMIT #{limit} OFFSET #{offset}

-- 索引: CREATE INDEX idx_risk_log_time_range ON risk_log (create_time DESC);
```

```sql
-- 批量插入风控日志 (性能关键)
INSERT INTO risk_log (
  user_id, order_id, risk_type, risk_level, risk_score,
  trigger_value, threshold_value, action_taken, action_result,
  description, create_time
) VALUES
  (#{log.userId}, #{log.orderId}, #{log.riskType}, #{log.riskLevel}, #{log.riskScore},
   #{log.triggerValue}, #{log.thresholdValue}, #{log.actionTaken}, #{log.actionResult},
   #{log.description}, COALESCE(#{log.createTime}, CURRENT_TIMESTAMP)),
  ...

-- 索引: PRIMARY KEY (id) 自增主键
```

### 12. OrderHedgeMapper.xml - 订单对冲查询

#### 12.1 写入操作
```sql
-- 插入对冲记录 (REAL账户下单时)
INSERT INTO option_order_hedge (
    order_id, symbol, expiration, strike, side, fixture_price,
    hedge_amount, hedge_status, hedge_time, hedge_message, retry_count,
    create_time, update_time
) VALUES (
    #{orderId}, #{symbol}, #{expiration}, #{strike}, #{side}, #{fixturePrice},
    #{hedgeAmount}, #{hedgeStatus}, #{hedgeTime}, #{hedgeMessage}, #{retryCount},
    CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
)

-- 索引: PRIMARY KEY (id), idx_order_hedge_order_id, idx_order_hedge_status_create_time
```

#### 12.2 基础查询
```sql
-- 根据订单ID查询对冲记录 (每次REAL账户下单都会查询)
SELECT id, order_id, symbol, expiration, strike, side, 
       fixture_price, hedge_amount, hedge_status, hedge_time, 
       hedge_message, retry_count, create_time, update_time
FROM option_order_hedge 
WHERE order_id = #{orderId}

-- 索引: CREATE INDEX idx_order_hedge_order_id ON option_order_hedge (order_id);
```

#### 12.3 状态管理查询
```sql
-- 查询待处理的对冲记录 (定时任务使用)
SELECT id, order_id, symbol, expiration, strike, side, 
       fixture_price, hedge_amount, hedge_status, hedge_time, 
       hedge_message, retry_count, create_time, update_time
FROM option_order_hedge 
WHERE hedge_status = 'PENDING' 
ORDER BY create_time ASC 
LIMIT #{limit}

-- 索引: CREATE INDEX idx_order_hedge_status_create_time ON option_order_hedge (hedge_status, create_time);
```

```sql
-- 查询失败的对冲记录 (补偿任务使用)
SELECT id, order_id, symbol, expiration, strike, side, 
       fixture_price, hedge_amount, hedge_status, hedge_time, 
       hedge_message, retry_count, create_time, update_time
FROM option_order_hedge 
WHERE hedge_status = 'FAILED' 
  AND retry_count < #{maxRetryCount} 
  AND create_time > CURRENT_TIMESTAMP - INTERVAL '1 DAY' 
ORDER BY create_time ASC 
LIMIT #{limit}

-- 索引: CREATE INDEX idx_order_hedge_status_retry ON option_order_hedge (hedge_status, retry_count, create_time);
```

#### 12.3 状态更新操作
```sql
-- 更新对冲状态 (每次对冲操作完成后)
UPDATE option_order_hedge 
SET hedge_status = #{hedgeStatus}, 
    hedge_time = #{hedgeTime}, 
    hedge_message = #{hedgeMessage}, 
    update_time = CURRENT_TIMESTAMP 
WHERE order_id = #{orderId}

-- 索引: CREATE INDEX idx_order_hedge_order_id ON option_order_hedge (order_id);
```

### 13. UserRiskStatsMapper.xml - 用户风控统计查询 (新增)

#### 13.1 基础查询
```sql
-- 根据用户ID和账户类型查询风控统计 (高频查询，替代原风控SQL)
SELECT id, user_id, account_type, today_order_count, today_order_amount, 
       today_win_count, today_loss_count, today_profit,
       week_order_count, week_order_amount, week_win_count, week_loss_count, week_profit,
       month_order_count, month_order_amount, month_win_count, month_loss_count, month_profit,
       total_order_count, total_order_amount, total_win_count, total_loss_count, total_profit,
       last_order_time, last_reset_date, last_reset_week, last_reset_month,
       create_time, update_time
FROM user_risk_stats 
WHERE user_id = #{userId} 
  AND account_type = #{accountType}

-- 索引: CREATE INDEX idx_user_risk_stats_user_account ON user_risk_stats (user_id, account_type);
```

```sql
-- 批量查询用户风控统计 (批量风控检查使用)
SELECT id, user_id, account_type, today_order_count, today_order_amount, 
       today_win_count, today_loss_count, today_profit,
       week_order_count, week_order_amount, week_win_count, week_loss_count, week_profit,
       month_order_count, month_order_amount, month_win_count, month_loss_count, month_profit,
       total_order_count, total_order_amount, total_win_count, total_loss_count, total_profit,
       last_order_time, last_reset_date, last_reset_week, last_reset_month,
       create_time, update_time
FROM user_risk_stats 
WHERE user_id IN (#{userIds}) 
  AND account_type = #{accountType} 
ORDER BY user_id

-- 索引: CREATE INDEX idx_user_risk_stats_user_id ON user_risk_stats (user_id);
```

#### 13.2 定时重置查询
```sql
-- 查询需要重置的统计记录 (定时任务使用)
SELECT id, user_id, account_type, today_order_count, today_order_amount, 
       today_win_count, today_loss_count, today_profit,
       week_order_count, week_order_amount, week_win_count, week_loss_count, week_profit,
       month_order_count, month_order_amount, month_win_count, month_loss_count, month_profit,
       total_order_count, total_order_amount, total_win_count, total_loss_count, total_profit,
       last_order_time, last_reset_date, last_reset_week, last_reset_month,
       create_time, update_time
FROM user_risk_stats 
WHERE (last_reset_date IS NULL OR last_reset_date < CURRENT_DATE)
   OR (last_reset_week IS NULL OR last_reset_week < DATE_TRUNC('week', CURRENT_DATE))
   OR (last_reset_month IS NULL OR last_reset_month < DATE_TRUNC('month', CURRENT_DATE)) 
ORDER BY update_time 
LIMIT #{limit}

-- 索引: CREATE INDEX idx_user_risk_stats_update_time ON user_risk_stats (update_time);
```

#### 13.3 写入操作 (INSERT/UPDATE)
```sql
-- 插入或初始化用户风控统计记录
INSERT INTO user_risk_stats (
    user_id, account_type, today_order_count, today_order_amount, 
    today_win_count, today_loss_count, today_profit,
    week_order_count, week_order_amount, week_win_count, week_loss_count, week_profit,
    month_order_count, month_order_amount, month_win_count, month_loss_count, month_profit,
    total_order_count, total_order_amount, total_win_count, total_loss_count, total_profit,
    last_order_time, last_reset_date, last_reset_week, last_reset_month,
    create_time, update_time
) VALUES (?, ?, 0, 0.00, 0, 0, 0.00, 0, 0.00, 0, 0, 0.00, 0, 0.00, 0, 0, 0.00,
         0, 0.00, 0, 0, 0.00, NULL, NULL, NULL, NULL, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP);

-- 增量更新统计数据 (每次下单)
UPDATE user_risk_stats SET
    today_order_count = today_order_count + 1,
    week_order_count = week_order_count + 1,
    month_order_count = month_order_count + 1,
    total_order_count = total_order_count + 1,
    today_order_amount = today_order_amount + ?,
    week_order_amount = week_order_amount + ?,
    month_order_amount = month_order_amount + ?,
    total_order_amount = total_order_amount + ?,
    last_order_time = CURRENT_TIMESTAMP,
    update_time = CURRENT_TIMESTAMP
WHERE user_id = ? AND account_type = ?;

-- 结算后更新盈亏统计
UPDATE user_risk_stats SET
    today_win_count = today_win_count + ?,
    today_loss_count = today_loss_count + ?,
    today_profit = today_profit + ?,
    week_win_count = week_win_count + ?,
    week_loss_count = week_loss_count + ?,
    week_profit = week_profit + ?,
    month_win_count = month_win_count + ?,
    month_loss_count = month_loss_count + ?,
    month_profit = month_profit + ?,
    total_win_count = total_win_count + ?,
    total_loss_count = total_loss_count + ?,
    total_profit = total_profit + ?,
    update_time = CURRENT_TIMESTAMP
WHERE user_id = ? AND account_type = ?;
```

**执行频率**: 中频 - 增量更新约500 QPS，结算更新约50 QPS，初始化约10 QPS
**优化要点**: 复合索引(user_id, account_type)，支持按周期类型批量操作

#### 13.4 批量重置操作
```sql
-- 批量重置今日统计
UPDATE user_risk_stats 
SET today_order_count = 0,
    today_order_amount = 0,
    today_win_count = 0,
    today_loss_count = 0,
    today_profit = 0,
    last_reset_date = #{resetDate} 
WHERE id IN (#{ids})

-- 索引: PRIMARY KEY (id)
```

```sql
-- 批量重置本周统计
UPDATE user_risk_stats 
SET week_order_count = 0,
    week_order_amount = 0,
    week_win_count = 0,
    week_loss_count = 0,
    week_profit = 0,
    last_reset_week = #{resetWeek} 
WHERE id IN (#{ids})

-- 索引: PRIMARY KEY (id)
```

```sql
-- 批量重置本月统计
UPDATE user_risk_stats 
SET month_order_count = 0,
    month_order_amount = 0,
    month_win_count = 0,
    month_loss_count = 0,
    month_profit = 0,
    last_reset_month = #{resetMonth} 
WHERE id IN (#{ids})

-- 索引: PRIMARY KEY (id)
```

---

## SQL操作频率和性能分级（基于实际场景）

### 场景假设
- **用户规模**：100-1000 在线用户
- **轮次周期**：5分钟一轮，每小时12轮
- **用户行为**：每用户5分钟内下单0-10笔（平均5笔）
- **查询行为**：每用户每分钟查询0-5次（平均2.5次）
- **交易对数量**：单币对场景（可扩展）

### 操作频率计算（基于1000用户，包含读写操作）

#### 🔴 超高频操作 (每秒10-100次)

**读操作 (SELECT)**

1. **当前轮次查询** `TradingRoundMapper.findCurrentRound`
   - 触发：每次下单前查询
   - 频率：1000用户 × 5单/5分钟 = 1000单/分钟 = **17次/秒**
   - 索引：idx_trading_round_current (symbol_id, duration_minutes, status, start_time, end_time)

2. **账户查询** `AccountMapper.findByUserIdAndAccountType`  
   - 触发：下单、查询余额、转账
   - 频率：下单(17次/秒) + 查询(42次/秒) = **59次/秒**
   - 索引：idx_user_account_type (user_id, account_type)

3. **用户订单列表** `OrderMapper.findByUserIdAndAccountType`
   - 触发：用户查看当前订单、历史订单
   - 频率：1000用户 × 2.5次/分钟 = **42次/秒**
   - 索引：idx_option_order_user_account_create_time

**写操作 (INSERT/UPDATE/DELETE)**

1. **余额原子更新** `AccountMapper.atomicBalanceChange`
   - 触发：下单冻结、结算、转账
   - 频率：下单(17次/秒) + 结算(3.3次/秒) + 转账(2次/秒) = **22次/秒**
   - 索引：PRIMARY KEY (id)

2. **订单创建** `OrderMapper.insert`
   - 触发：用户下单
   - 频率：**17次/秒**
   - 索引：写入操作，依赖主键和复合索引

3. **交易流水记录** `AccountTransactionMapper.insert`
   - 触发：每次余额变动（与余额更新同步）
   - 频率：**22次/秒**
   - 索引：写入操作，依赖主键

4. **轮次投注额更新** `TradingRoundMapper.updateBetAmounts`
   - 触发：每次下单后更新轮次统计
   - 频率：**17次/秒**
   - 索引：PRIMARY KEY (id)

#### 🟡 高频操作 (每秒1-10次)

**读操作 (SELECT)**

1. **风控统计查询** `UserRiskStatsMapper.selectByUserIdAndAccountType`
   - 触发：每次下单前的风控检查
   - 频率：17次/秒
   ```sql
   SELECT today_order_count, today_order_amount, week_order_count, week_order_amount,
          month_order_count, month_order_amount, total_order_count, total_order_amount,
          today_win_count, today_loss_count, today_profit,
          week_win_count, week_loss_count, week_profit,
          month_win_count, month_loss_count, month_profit
   FROM user_risk_stats 
   WHERE user_id = ? AND account_type = ?
   ```
   - 索引：idx_user_risk_stats_user_account

**写操作 (INSERT/UPDATE/DELETE)**

1. **用户风控统计更新** `UserRiskStatsMapper.incrementOrderStats`
   - 触发：下单时更新统计、结算时更新统计
   - 频率：下单(17次/秒) + 结算(3.3次/秒) = **20次/秒**
   - 索引：PRIMARY KEY (id)

2. **订单状态更新** `OrderMapper.updateStatus`
   - 触发：订单状态变更（PENDING->ACTIVE->WIN/LOSE）
   - 频率：状态变更约**10次/秒**
   - 索引：PRIMARY KEY (id)

3. **订单对冲记录创建** `OrderHedgeMapper.insert`
   - 触发：REAL账户订单创建时
   - 频率：REAL账户订单约8.5次/秒（假设50%为REAL账户）
   - 索引：写入操作，order_id索引

4. **订单对冲状态更新** `OrderHedgeMapper.updateHedgeStatus`
   - 触发：REAL账户订单对冲操作完成后
   - 频率：REAL账户订单约**8.5次/秒**
   - 索引：idx_order_hedge_order_id

#### 🟠 中频查询 (每分钟1-60次)

1. **轮次结算查询** `OrderMapper.findPendingOrdersByRound`
   - 触发：每5分钟结算一次
   - 频率：12轮/小时 = **0.2次/分钟**（但查询返回大量数据）
   - 索引：idx_option_order_round_status

2. **轮次状态更新** `TradingRoundMapper.updateStatus`
   - 触发：轮次锁定、结算
   - 频率：12轮/小时 × 2次 = **0.4次/分钟**
   - 索引：PRIMARY KEY (id)

3. **BTSE转账超时处理** `BtseTransferLogMapper.findTimeoutPendingTransfers`
   - 触发：每5秒执行一次
   - 频率：**12次/分钟**
   - 索引：idx_btse_transfer_timeout

4. **黑名单检查** `BlacklistMapper.findByUserId`
   - 触发：每次下单前
   - 频率：1000次/分钟 = **17次/秒**（应归类为高频）
   - 索引：idx_blacklist_user_status_time

5. **失败对冲补偿查询** `OrderHedgeMapper.findFailedHedges`
   - 触发：每5秒执行一次补偿任务
   - 频率：**12次/分钟**
   - 索引：idx_order_hedge_status_retry

#### 🟢 低频查询 (每小时1-60次)

1. **用户统计** `UserMapper.findByCreateTimeBetween`
   - 触发：后台统计任务
   - 频率：**每小时1次**
   - 索引：idx_user_create_time

2. **风控日志记录** `RiskLogMapper.insert`
   - 触发：触发风控规则时
   - 频率：约**10-20次/小时**
   - 索引：写入操作

3. **配置查询** `GlobalConfigMapper.findByKey`
   - 触发：系统初始化、配置刷新
   - 频率：**缓存命中率99%，实际查询<1次/分钟**
   - 索引：uk_config_key

4. **风控统计重置查询** `UserRiskStatsMapper.selectNeedResetRecords`
   - 触发：定时任务检查需要重置的统计记录
   - 频率：**每小时4次**（每15分钟检查一次）
   - 索引：idx_user_risk_stats_update_time

5. **批量重置风控统计** `UserRiskStatsMapper.batchReset*Stats`
   - 触发：定时任务批量重置过期统计数据
   - 频率：**每天3-4次**（日重置1次，周重置偶尔，月重置偶尔）
   - 索引：PRIMARY KEY (id)

### 不同用户规模下的操作量对比（读+写）

| 操作类型 | 操作分类 | 100用户/秒 | 500用户/秒 | 1000用户/秒 |
|---------|---------|-----------|-----------|------------|
| **读操作 (SELECT)** |  |  |  |  |
| 账户查询 | 高频读 | 5.9 | 29.5 | 59 |
| 订单列表查询 | 高频读 | 4.2 | 21 | 42 |
| 当前轮次查询 | 高频读 | 1.7 | 8.5 | 17 |
| 风控统计查询 | 高频读 | 1.7 | 8.5 | 17 |
| **写操作 (INSERT/UPDATE/DELETE)** |  |  |  |  |
| 余额原子更新 | 超高频写 | 2.2 | 11 | 22 |
| 订单创建 | 超高频写 | 1.7 | 8.5 | 17 |
| 交易流水记录 | 超高频写 | 2.2 | 11 | 22 |
| 轮次投注额更新 | 超高频写 | 1.7 | 8.5 | 17 |
| 风控统计更新 | 高频写 | 2.0 | 10 | 20 |
| 订单状态更新 | 高频写 | 1.0 | 5 | 10 |
| 对冲记录创建 | 高频写 | 0.85 | 4.25 | 8.5 |
| 对冲状态更新 | 高频写 | 0.85 | 4.25 | 8.5 |
| **小计** |  |  |  |  |
| 读操作QPS | - | 13.5 | 67.5 | 135 |
| 写操作QPS | - | 12.4 | 62 | 124 |
| **总QPS** | - | **25.9** | **129.5** | **259** |

### 重要性能指标总结
- **读写比例**：约 52% 读操作，48% 写操作
- **峰值QPS**：1000用户场景下约259 QPS
- **关键瓶颈**：余额原子更新和交易流水记录（各22 QPS）
- **索引优化重点**：user_id, account_type, order_id, round_id相关复合索引
- **分库分表建议**：基于user_id分片，支持水平扩展


---
