# 前端代码优化方案

> 更新日期: 2025-12-15
> 基于当前分支未提交代码的分析

---

## 一、代码变更概览

### 1.1 变更统计

| 类型 | 文件数 | 新增行 | 删除行 |
|------|--------|--------|--------|
| 修改文件 | 33 | 2171 | 1860 |
| 新增文件 | 2 | ~300 | 0 |

### 1.2 主要变更分类

| 分类 | 涉及文件 | 变更内容 |
|------|----------|----------|
| WebSocket 全局初始化 | App.vue, websocket.ts, MarketWebSocket.ts | 应用启动时自动连接并订阅所有交易对 |
| 订单 API 对接 | ActiveOrders.vue, HistoryOrderTable.vue, order.ts | 活跃订单/历史订单 API 对接 |
| 类型系统统一 | market.ts, types.ts | symbolId: string → number |
| 响应判断统一 | 多个文件 | 支持 `res.success \|\| res.code === 200` |
| 周期配置 | market.ts, useMarketListData.ts | 全局 durations 配置和锁定状态计算 |
| 时间工具函数 | timeUtils.ts (新增) | ISO 时间处理工具 |

---

## 二、与 API 文档对比分析

### 2.1 已完成项 ✅

| 文档要求 | 实现状态 | 说明 |
|----------|----------|------|
| WebSocket 数组格式订阅 | ✅ 完成 | `{ subscribe: ["BTC-USDT"] }` |
| WebSocket subscribeAll | ✅ 完成 | `{ subscribe: ["*"] }` |
| WebSocket 全局初始化 | ✅ 完成 | App.vue onMounted |
| odds 替代 fixtures | ✅ 完成 | 已更新所有相关组件 |
| symbolId: number 类型 | ✅ 完成 | market.ts 统一转换 |
| 历史订单时间戳参数 | ✅ 完成 | startTime/endTime 毫秒时间戳 |
| 响应判断兼容 | ✅ 完成 | `res.success \|\| res.code === 200` |
| 周期配置 durations API | ✅ 完成 | 全局加载并缓存 |
| 锁定状态时间计算 | ✅ 完成 | useMarketListData.ts |
| 活跃订单 API 对接 | ✅ 完成 | ActiveOrders.vue |
| 历史订单 API 对接 | ✅ 完成 | HistoryOrderTable.vue |
| 下单成功刷新订单列表 | ✅ 完成 | TradingPanel.vue |
| 24H High/Low 数据绑定 | ✅ 完成 | TradingHeader.vue |

### 2.2 遗留问题解决状态

| 问题 | 文档位置 | 状态 | 说明 |
|------|----------|------|------|
| 模板硬编码赔率值 | 1.1 | ✅ 已解决 | ExpirationOptions.vue 已动态绑定 |
| symbolId 类型不一致 | 2.1 | ✅ 已解决 | toNumberId 统一转换函数 |
| 响应状态判断 | 3.1 | ✅ 已解决 | 主要 API 调用已修复 |
| ISO 时间字符串处理 | 4.1 | ✅ 已解决 | timeUtils.ts 工具函数 |
| Fixture 相关废弃代码 | 5.1 | ✅ 已解决 | 全部更新为 OddsData |
| 周期选择全局同步 | 4.1 | ✅ 已解决 | marketStore.selectedDuration |
| SymbolTabs 标签页联动 | 4.4 | ✅ 已解决 | watch activeSymbolId |
| 批量订阅优化 | 后续优化 1 | ✅ 已解决 | subscribeAll() 实现 |

---

## 三、发现的优化点

### 3.1 高优先级优化

#### 3.1.1 重复的响应判断逻辑

**问题**: 多个文件中重复使用 `res.success || res.code === 200` 判断

**涉及文件**:
- `src/store/order.ts` (3处)
- `src/store/market.ts` (2处)
- `src/components/trading/TradingPanel.vue` (1处)
- `src/composables/useMarketCardData.ts` (1处)

**优化方案**:
```typescript
// src/utils/apiUtils.ts
export function isApiSuccess(response: any): boolean {
  return response && (response.success === true || response.code === 200)
}

// 使用方式
import { isApiSuccess } from '@/utils/apiUtils'

if (isApiSuccess(response) && response.data) {
  // 处理成功逻辑
}
```

---

#### 3.1.2 console.log 调试代码未清理

**问题**: 正式代码中残留调试日志

**涉及位置**:
```typescript
// src/store/order.ts:99-101
console.log('[OrderStore] getActiveOrders response:', response)
console.log('[OrderStore] setActiveOrders data:', res)
```

**优化方案**: 移除或替换为条件日志
```typescript
// 方案1: 直接移除
// 方案2: 使用条件日志
if (import.meta.env.DEV) {
  console.log('[OrderStore] getActiveOrders response:', response)
}
```

---

#### 3.1.3 HistoryOrderTable 展开状态使用 Set 但触发响应式问题

**问题**: 使用 `ref<Set<string>>` 需要手动触发响应式更新

**当前代码**:
```typescript
const expandedGroups = ref<Set<string>>(new Set())

const toggleExpand = (groupId: string) => {
  if (expandedGroups.value.has(groupId)) {
    expandedGroups.value.delete(groupId)
  } else {
    expandedGroups.value.add(groupId)
  }
  // 需要手动创建新 Set 触发响应式
  expandedGroups.value = new Set(expandedGroups.value)
}
```

**优化方案**: 使用 reactive Map 或普通对象
```typescript
// 方案1: 使用 Record 对象
const expandedGroups = ref<Record<string, boolean>>({})

const toggleExpand = (groupId: string) => {
  expandedGroups.value[groupId] = !expandedGroups.value[groupId]
}

const isGroupExpanded = (groupId: string): boolean => {
  return !!expandedGroups.value[groupId]
}
```

---

### 3.2 中优先级优化

#### 3.2.1 ActiveOrders 倒计时定时器可合并

**问题**: 每个 OrderGroup 可能有独立的倒计时逻辑，当订单量大时性能影响

**当前实现**:
```typescript
// 全局 now 每秒更新
let countdownTimer: ReturnType<typeof setInterval> | null = null
const now = ref(Date.now())

// onMounted
countdownTimer = setInterval(() => {
  now.value = Date.now()
}, 1000)
```

**当前实现已合理**: 使用单一 `now` ref 驱动所有倒计时，这是正确的优化方式。

---

#### 3.2.2 MarketWebSocket 防抖逻辑可优化

**问题**: 使用 Map + setTimeout 管理防抖，可能有内存泄漏风险

**当前代码**:
```typescript
private debounceTimers = new Map<string, number>()

private debounce(symbol: string, callback: () => void, delay?: number): void {
  if (this.debounceTimers.has(symbol)) {
    clearTimeout(this.debounceTimers.get(symbol)!)
  }
  const timerId = setTimeout(() => {
    callback()
    this.debounceTimers.delete(symbol)
  }, debounceDelay)
  this.debounceTimers.set(symbol, timerId)
}
```

**优化方案**: 使用 lodash-es 的 debounce 或创建防抖工具类
```typescript
// 使用 Map 存储每个 symbol 的防抖函数
private debouncedHandlers = new Map<string, ReturnType<typeof debounce>>()

private getDebouncedHandler(symbol: string) {
  if (!this.debouncedHandlers.has(symbol)) {
    this.debouncedHandlers.set(symbol, debounce((data) => {
      this.emit('tick', { type: 'tick', data, timestamp: Date.now() })
    }, this.debounceDelay))
  }
  return this.debouncedHandlers.get(symbol)!
}
```

---

#### 3.2.3 useMarketListData 锁定状态更新可优化

**问题**: 每秒遍历所有 marketListItems 更新锁定状态

**当前代码**:
```typescript
const updateLockStatus = () => {
  marketListItems.value.forEach(item => {
    item.payouts.forEach(payout => {
      const config = durationsConfig.find(d => d.durationMinutes === payout.duration)
      if (config) {
        const locked = isLocked(payout.duration, config.lockSeconds)
        payout.locked = locked
        payout.upLocked = locked
        payout.downLocked = locked
      }
    })
  })
}
```

**优化方案**:
1. 预计算锁定配置 Map，避免每次 find
2. 只更新需要变化的项

```typescript
// 预计算 duration -> config 映射
const durationConfigMap = computed(() => {
  const map = new Map<number, DurationConfig>()
  marketStore.durations.forEach(d => map.set(d.durationMinutes, d))
  return map
})

const updateLockStatus = () => {
  const configMap = durationConfigMap.value
  marketListItems.value.forEach(item => {
    item.payouts.forEach(payout => {
      const config = configMap.get(payout.duration)
      if (config) {
        const newLocked = isLocked(payout.duration, config.lockSeconds)
        // 只在状态变化时更新
        if (payout.locked !== newLocked) {
          payout.locked = newLocked
          payout.upLocked = newLocked
          payout.downLocked = newLocked
        }
      }
    })
  })
}
```

---

### 3.3 低优先级优化

#### 3.3.1 类型定义可进一步完善

**问题**: 部分类型使用 `any`

**涉及位置**:
- `src/store/order.ts`: `round: any`
- `src/components/orders/HistoryOrderTable.vue`: `round: any`

**优化方案**: 定义完整的类型
```typescript
// src/api/types.ts
export interface HistoryRoundOrderDTO {
  roundId: number
  roundNo: string
  symbolId: number
  symbol: string
  durationMinutes: number
  startTime: string
  endTime: string
  startPrice: string
  endPrice: string | null
  status: string
  orders: OrderDTO[]
}
```

---

#### 3.3.2 国际化 key 可统一管理

**问题**: 新增的国际化 key 分散在各个语言文件中

**已有 key**:
- `formTrade.noActiveRound`
- `formTrade.orderPlacedSuccessfully`
- `formTrade.orderFailed`

**优化建议**: 创建类型安全的 i18n key 管理

---

#### 3.3.3 localStorage 操作可封装

**问题**: 多处直接操作 localStorage

**涉及位置**:
- `src/store/market.ts`: `selectedDuration`, `activeSymbol`
- `src/store/order.ts`: 可能涉及

**优化方案**:
```typescript
// src/utils/storage.ts
const STORAGE_KEYS = {
  SELECTED_DURATION: 'selectedDuration',
  ACTIVE_SYMBOL: 'activeSymbol',
} as const

export const storage = {
  get<T>(key: keyof typeof STORAGE_KEYS, defaultValue?: T): T | null {
    const value = localStorage.getItem(STORAGE_KEYS[key])
    return value ? JSON.parse(value) : (defaultValue ?? null)
  },
  set(key: keyof typeof STORAGE_KEYS, value: any): void {
    localStorage.setItem(STORAGE_KEYS[key], JSON.stringify(value))
  },
  remove(key: keyof typeof STORAGE_KEYS): void {
    localStorage.removeItem(STORAGE_KEYS[key])
  }
}
```

---

## 四、代码质量评估

### 4.1 优点

1. **架构清晰**: WebSocket 全局初始化在 App.vue，职责单一
2. **类型系统**: symbolId 统一转换函数 `toNumberId` 设计合理
3. **响应式设计**: 锁定状态实时更新机制设计良好
4. **兼容性处理**: 响应判断支持两种格式，向后兼容
5. **代码复用**: `useMarketListData.ts` 封装了市场列表数据逻辑
6. **工具函数**: `timeUtils.ts` 提供了统一的时间处理方法

### 4.2 待改进

1. ~~**调试代码**: 需要清理 console.log~~ ✅ 已完成
2. ~~**响应判断**: 建议抽取为通用函数~~ ✅ 已完成
3. ~~**Set 响应式**: HistoryOrderTable 的 expandedGroups 处理可优化~~ ✅ 已完成
4. ~~**类型完整性**: 部分 `any` 类型需要定义完整~~ ✅ 已完成

---

## 五、推荐优化顺序

### 第一阶段 (提交前必须) - ✅ 已完成

1. ✅ 清理 `console.log` 调试代码
2. ✅ 抽取 `isApiSuccess` 通用函数
3. ✅ 重构所有响应判断使用 `isApiSuccess`
4. ✅ 优化 HistoryOrderTable 展开状态管理

### 第二阶段 (下个迭代) - ✅ 已完成

5. ✅ 完善类型定义，消除 `any`
6. ✅ 封装 localStorage 操作

### 第三阶段 (性能优化) - 可选

7. 优化 useMarketListData 锁定状态更新 (详见 3.2.3)
8. 评估 MarketWebSocket 防抖逻辑 (详见 3.2.2)

> **说明**: 第三阶段为性能优化，属于可选项。当前实现已经可以正常工作，这些优化只有在遇到性能瓶颈时才需要考虑。详细分析见下方 "第三阶段优化详解" 章节。

---

## 六、已完成的优化

### 6.1 新增工具函数

**文件**: `src/utils/apiUtils.ts`
```typescript
/**
 * 判断 API 响应是否成功
 * 兼容两种响应格式
 */
export function isApiSuccess(response: any): boolean {
  if (!response) return false
  return response.success === true || response.code === 200
}

export function isApiSuccessWithData(response: any): boolean {
  return isApiSuccess(response) && response.data !== undefined && response.data !== null
}
```

### 6.2 重构的文件

| 文件 | 修改内容 |
|------|----------|
| `src/store/order.ts` | 移除 console.log，使用 isApiSuccessWithData |
| `src/store/market.ts` | 使用 isApiSuccessWithData |
| `src/components/trading/TradingPanel.vue` | 使用 isApiSuccess |
| `src/components/orders/HistoryOrderTable.vue` | expandedGroups 从 Set 改为 Record |

### 6.3 HistoryOrderTable 展开状态优化

**优化前** (Set 需要手动触发响应式):
```typescript
const expandedGroups = ref<Set<string>>(new Set())

const toggleExpand = (groupId: string) => {
  if (expandedGroups.value.has(groupId)) {
    expandedGroups.value.delete(groupId)
  } else {
    expandedGroups.value.add(groupId)
  }
  expandedGroups.value = new Set(expandedGroups.value) // 手动触发
}
```

**优化后** (Record 自动响应式):
```typescript
const expandedGroups = ref<Record<string, boolean>>({})

const toggleExpand = (groupId: string) => {
  expandedGroups.value[groupId] = !expandedGroups.value[groupId]
}

const isGroupExpanded = (groupId: string): boolean => {
  return !!expandedGroups.value[groupId]
}
```

---

## 七、第二阶段优化内容

### 7.1 新增订单相关类型定义

**文件**: `src/api/types.ts`

```typescript
// 轮次内的单个订单
export interface OrderInRound {
  orderId: number
  direction: 'UP' | 'DOWN'
  amount: number
  odds: number
  expectedProfit: number
  orderPrice: number
  status: string
  profit?: number
  fee?: number
  createTime?: string
}

// 用户在轮次内的统计信息
export interface UserRoundStats {
  totalOrders: number
  totalAmount: number
  totalProfit: number
  totalLoss: number
  netProfit: number
  winCount?: number
  loseCount?: number
  winRate?: number
}

// 包含订单的轮次信息
export interface RoundWithOrders {
  roundId: number
  roundNo: string
  symbol: string
  symbolId?: number
  durationMinutes: number
  startTime: string
  endTime: string
  startPrice: number | string
  endPrice: number | string | null
  status: string
  settleTime?: string | null
  orders: OrderInRound[]
  userStats?: UserRoundStats
}

// 活跃订单响应 - 2级结构 (与历史订单结构一致)
export interface ActiveOrdersResponse {
  rounds: RoundWithOrders[]
  totalRounds: number
  totalOrders: number
}

// 历史订单响应 - 2级结构 + 分页
export interface HistoryOrdersResponse {
  rounds: RoundWithOrders[]
  total: number
  page: number
  pageSize: number
  totalPages: number
  hasNext: boolean
  hasPrevious: boolean
}
```

### 7.2 新增 localStorage 存储工具

**文件**: `src/utils/storage.ts`

```typescript
// 存储键常量
export const STORAGE_KEYS = {
  SELECTED_DURATION: 'selectedDuration',
  ACTIVE_SYMBOL: 'activeSymbol',
  ACCOUNT_TYPE: 'accountType',
  HAS_ORDER_IN_ROUND: 'hasOrderInRound',
} as const

// 通用存储工具
export const storage = {
  get<T>(key: StorageKey, defaultValue?: T): T | null,
  getString(key: StorageKey, defaultValue?: string): string | null,
  getNumber(key: StorageKey, defaultValue?: number): number | null,
  set(key: StorageKey, value: unknown): void,
  remove(key: StorageKey): void,
  clear(): void,
  dynamic: {
    get(prefix: string, suffix: string): string | null,
    set(prefix: string, suffix: string, value: string): void,
    remove(prefix: string, suffix: string): void,
  },
}
```

### 7.3 重构的文件

| 文件 | 修改内容 |
|------|----------|
| `src/api/types.ts` | 新增订单相关类型定义 |
| `src/utils/storage.ts` | 新增 localStorage 存储工具 |
| `src/store/order.ts` | 使用新类型替代 any，使用 storage 工具 |
| `src/store/market.ts` | 使用 storage 工具替代直接 localStorage 操作 |
| `src/components/orders/HistoryOrderTable.vue` | 使用 RoundWithOrders 和 OrderInRound 类型 |

---

## 八、第三阶段优化详解 (性能优化 - 可选)

> **重要说明**: 以下优化为性能优化，属于**可选项**。当前实现已经可以正常工作，只有在以下情况才需要考虑：
> - 交易对数量超过 50 个
> - 用户反馈页面卡顿
> - 性能监控发现 CPU 占用过高

### 8.1 useMarketListData 锁定状态更新优化

#### 8.1.1 当前实现分析

**文件**: `src/composables/useMarketListData.ts`

**当前逻辑**:
```typescript
// 每秒执行一次，遍历所有交易对和所有周期
const updateLockStatus = () => {
  const durationsConfig = marketStore.durations
  if (durationsConfig.length === 0) return

  marketListItems.value.forEach(item => {           // 遍历所有交易对 (8个)
    item.payouts.forEach(payout => {                 // 遍历所有周期 (4个)
      const config = durationsConfig.find(d =>       // 每次都 find 查找
        d.durationMinutes === payout.duration
      )
      if (config) {
        const locked = isLocked(payout.duration, config.lockSeconds)
        payout.locked = locked
        payout.upLocked = locked
        payout.downLocked = locked
      }
    })
  })
}

// 每秒调用一次
lockUpdateInterval.value = window.setInterval(updateLockStatus, 1000)
```

**性能分析**:
- 每秒执行 1 次
- 8 个交易对 × 4 个周期 = 32 次循环
- 每次循环都执行 `find()` 查找 = 32 × 4 = 128 次比较
- 即使锁定状态没变化，也会赋值

**实际影响**:
- 当前 8 个交易对、4 个周期，性能影响**可忽略不计**
- 只有当交易对超过 50 个时才可能产生明显影响

#### 8.1.2 优化方案 (如果需要)

```typescript
// 1. 预计算 duration -> config 映射，避免每次 find
const durationConfigMap = computed(() => {
  const map = new Map<number, DurationConfig>()
  marketStore.durations.forEach(d => map.set(d.durationMinutes, d))
  return map
})

// 2. 只在状态变化时更新
const updateLockStatus = () => {
  const configMap = durationConfigMap.value
  marketListItems.value.forEach(item => {
    item.payouts.forEach(payout => {
      const config = configMap.get(payout.duration)  // O(1) 查找
      if (config) {
        const newLocked = isLocked(payout.duration, config.lockSeconds)
        // 只在状态变化时更新，避免不必要的响应式触发
        if (payout.locked !== newLocked) {
          payout.locked = newLocked
          payout.upLocked = newLocked
          payout.downLocked = newLocked
        }
      }
    })
  })
}
```

**优化效果**:
- `find()` 的 O(n) 查找 → `Map.get()` 的 O(1) 查找
- 减少不必要的响应式更新

#### 8.1.3 是否需要优化?

| 交易对数量 | 每秒操作次数 | 建议 |
|-----------|-------------|------|
| < 20 | < 80 | ❌ 不需要优化 |
| 20-50 | 80-200 | ⚠️ 可以考虑优化 |
| > 50 | > 200 | ✅ 建议优化 |

**当前状态**: 8 个交易对，**不需要优化**

---

### 8.2 MarketWebSocket 防抖逻辑评估

#### 8.2.1 当前实现分析

**文件**: `src/websocket/MarketWebSocket.ts`

**当前逻辑**:
```typescript
private debounceTimers = new Map<string, number>()

private debounce(symbol: string, callback: () => void, delay?: number): void {
  const debounceDelay = delay || this.debounceDelay  // 默认 100ms

  // 如果已有定时器，清除它
  if (this.debounceTimers.has(symbol)) {
    clearTimeout(this.debounceTimers.get(symbol)!)
  }

  // 创建新的定时器
  const timerId = setTimeout(() => {
    callback()
    this.debounceTimers.delete(symbol)
  }, debounceDelay)

  this.debounceTimers.set(symbol, timerId)
}
```

**工作原理**:
1. WebSocket 推送数据可能非常频繁（比如每 100ms 一次）
2. 防抖机制确保在 100ms 内多次推送只触发一次 UI 更新
3. 每个交易对有独立的防抖定时器

**潜在问题**:
- 如果 WebSocket 断开重连，定时器可能未清理 → 已有 `clearDebounceTimers()` 处理
- 大量交易对时 Map 可能变大 → 当前 8 个交易对，不是问题

#### 8.2.2 优化方案 (如果需要)

**方案 A: 使用 lodash-es debounce (更标准)**
```typescript
import { debounce } from 'lodash-es'

// 为每个 symbol 创建防抖函数
private debouncedHandlers = new Map<string, ReturnType<typeof debounce>>()

private getDebouncedHandler(symbol: string) {
  if (!this.debouncedHandlers.has(symbol)) {
    this.debouncedHandlers.set(symbol, debounce((data: TickData) => {
      this.emit('tick', { type: 'tick', data, timestamp: Date.now() })
    }, this.debounceDelay))
  }
  return this.debouncedHandlers.get(symbol)!
}
```

**方案 B: 使用 requestAnimationFrame (更流畅)**
```typescript
// 合并一帧内的所有更新
private pendingUpdates = new Map<string, TickData>()
private rafId: number | null = null

private scheduleUpdate(symbol: string, data: TickData): void {
  this.pendingUpdates.set(symbol, data)

  if (!this.rafId) {
    this.rafId = requestAnimationFrame(() => {
      this.pendingUpdates.forEach((tickData) => {
        this.emit('tick', { type: 'tick', data: tickData, timestamp: Date.now() })
      })
      this.pendingUpdates.clear()
      this.rafId = null
    })
  }
}
```

#### 8.2.3 是否需要优化?

| 情况 | 当前实现 | 建议 |
|------|---------|------|
| 正常使用 | 工作正常 | ❌ 不需要优化 |
| 需要更精确的防抖 | 自实现足够 | ⚠️ 可考虑 lodash |
| 动画卡顿 | 未发现 | ⚠️ 可考虑 RAF |
| 内存泄漏 | 已有清理逻辑 | ❌ 不需要优化 |

**当前状态**: 实现正确，**不需要优化**

---

### 8.3 第三阶段结论

| 优化项 | 当前状态 | 建议 |
|--------|---------|------|
| 锁定状态更新 | 8个交易对，每秒32次循环 | ❌ 暂不优化 |
| WebSocket 防抖 | 工作正常，有清理机制 | ❌ 暂不优化 |

**总结**: 当前代码质量良好，性能在可接受范围内。第三阶段优化可以**推迟到后续版本**，在遇到实际性能问题时再进行。

---

## 九、多周期倒计时管理器 ✅ 已完成

### 9.1 问题背景

**系统架构**：
- 支持 4 个交易周期：1分钟、3分钟、5分钟、15分钟
- 每个周期有独立的轮次（Round），包含 `closeTime` 和 `lockTime`
- 用户可以在不同周期之间切换进行交易

**需要解决的问题**：
1. 倒计时结束后需要立即进入下一轮，不能等待 API 返回
2. 每个周期的 lock 时间可能不同，必须严格按轮次配置
3. 轮次结束时需要刷新轮次信息和订单列表

### 9.2 实现方案

#### 9.2.1 核心设计

**文件**：`src/components/trading/CountdownTimer.vue`

**设计原则**：
1. **预测式倒计时**：倒计时结束后立即根据周期时长计算下一轮时间，无需等待 API
2. **异步数据刷新**：后台请求 API 获取最新轮次数据，不阻塞 UI
3. **去重机制**：使用 `closeTime_duration` 作为唯一标识，避免重复请求
4. **1分钟轮次触发订单刷新**：因为 3、5、15 分钟都是 1 分钟的倍数

#### 9.2.2 核心代码

```typescript
// 状态管理
const currentCloseTime = ref<number>(0)    // 当前轮次结束时间
const currentLockTime = ref<number>(0)     // 当前轮次锁定时间
const configLockOffset = ref<number>(10000) // 从 API 配置保存的 lockOffset（用于预测）
const processedRoundIds = new Set<string>() // 已处理的轮次（去重用）

/**
 * 从轮次数据初始化倒计时
 */
const initFromRound = (round: TradingRound) => {
  if (!round?.closeTime) return false

  const closeTime = new Date(round.closeTime).getTime()
  const lockTime = round.lockTime
    ? new Date(round.lockTime).getTime()
    : closeTime - 10000  // 默认锁定时间为结束前10秒

  currentCloseTime.value = closeTime
  currentLockTime.value = lockTime
  currentRoundId.value = round.roundId

  // 保存 API 配置的 lockOffset，用于预测下一轮
  // 注意：+1000 是因为时间范围是包含的
  // 例如 lockTime=50s, closeTime=59s 意味着 50,51,52...59 共 10 秒
  configLockOffset.value = closeTime - lockTime + 1000

  return true
}

/**
 * 移动到下一轮（预测式，无需等待 API）
 */
const moveToNextRound = (): boolean => {
  const round = currentRound.value

  // 获取周期时长
  const durationMinutes = round?.durationMinutes || marketStore.selectedDuration || 1
  const durationMs = durationMinutes * 60 * 1000

  // 保存旧的 closeTime 用于去重
  const oldCloseTime = currentCloseTime.value

  // 计算下一轮时间
  // 使用 configLockOffset（从 API 数据保存），确保 lock 时间准确
  currentCloseTime.value = currentCloseTime.value + durationMs
  currentLockTime.value = currentCloseTime.value - configLockOffset.value

  // 触发轮次结束处理（异步，不阻塞）
  handleRoundExpired(oldCloseTime, durationMinutes)

  return true
}

/**
 * 主倒计时更新函数
 */
const updateCountdown = () => {
  // 初始化检查
  if (!currentCloseTime.value) {
    const round = currentRound.value
    if (round) initFromRound(round)
    if (!currentCloseTime.value) return
  }

  const now = Date.now()
  let remainingMs = currentCloseTime.value - now

  // 轮次结束 - 立即进入下一轮（循环处理，防止页面后台时错过多轮）
  let iterations = 0
  while (remainingMs <= 0 && iterations < 100) {
    const prevCloseTime = currentCloseTime.value
    moveToNextRound()

    // 安全检查：确保时间前进
    if (currentCloseTime.value <= prevCloseTime) break

    remainingMs = currentCloseTime.value - now
    iterations++
  }

  // 计算剩余秒数（使用 ceil 确保与实际时间对齐）
  // 00:00:00 时显示 60，00:00:59.xxx 时显示 1，00:01:00 时进入下一轮
  const totalSeconds = Math.max(0, Math.ceil(remainingMs / 1000))
  updateDisplay(totalSeconds)

  // 检查锁定状态（基于显示的秒数，确保红色警告与倒计时同步）
  const lockOffsetSeconds = Math.ceil(configLockOffset.value / 1000)
  const shouldBeLocked = totalSeconds <= lockOffsetSeconds

  if (shouldBeLocked) {
    if (!isWarning.value) {
      emit('lock-change', true)
      isWarning.value = true
    }
  } else {
    if (isWarning.value) {
      emit('lock-change', false)
      isWarning.value = false
    }
  }
}

/**
 * 带重试的轮次数据获取
 * 1. 先等待1秒（在:01秒时请求，因为:00秒时后端还在处理）
 * 2. 如果获取到的数据已过期（closeTime < 当前时间），则重试（间隔1秒，最多3次）
 */
const fetchRoundWithRetry = async (
  durationMinutes: number,
  maxRetries: number = 3,
  retryDelay: number = 1000
): Promise<boolean> => {
  // 等待1秒后再发起第一次请求
  // :00秒时后端还在处理，:01秒时新轮次数据才可用
  await new Promise(resolve => setTimeout(resolve, 1000))

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    await marketStore.getCurrentRound(true)

    // 检查获取的数据是否是最新的
    const round = marketStore.getRoundByDuration(durationMinutes)
    if (round) {
      const closeTime = new Date(round.closeTime).getTime()
      if (closeTime > Date.now()) {
        // 数据是新鲜的，更新本地状态
        if (durationMinutes === marketStore.selectedDuration) {
          initFromRound(round)
        }
        return true
      }
    }

    // 数据过期，等待后重试
    if (attempt < maxRetries) {
      console.warn(`[CountdownTimer] Round data is stale (attempt ${attempt}/${maxRetries}), retrying...`)
      await new Promise(resolve => setTimeout(resolve, retryDelay))
    }
  }

  console.error(`[CountdownTimer] Failed to get fresh round data after ${maxRetries} attempts`)
  return false
}

/**
 * 轮次结束处理 - 异步刷新数据
 */
const handleRoundExpired = async (expiredCloseTime: number, durationMinutes: number) => {
  emit('countdown-complete')

  // 使用 closeTime + duration 作为唯一标识去重
  const uniqueKey = `${expiredCloseTime}_${durationMinutes}`
  if (processedRoundIds.has(uniqueKey)) return
  processedRoundIds.add(uniqueKey)

  // 清理旧记录
  if (processedRoundIds.size > 20) {
    const ids = Array.from(processedRoundIds)
    ids.slice(0, ids.length - 10).forEach(id => processedRoundIds.delete(id))
  }

  try {
    // 1. 刷新轮次数据（带重试，确保获取最新数据）
    await fetchRoundWithRetry(durationMinutes)

    // 2. 刷新订单列表（仅 1 分钟周期触发）
    if (durationMinutes === 1) {
      const accountType = accountStore.accountType as 'REAL' | 'DEMO'
      if (accountType) {
        await orderStore.refreshActiveOrders(accountType)
      }
    }
  } catch (error) {
    console.error('Failed to refresh after round expiration:', error)
    processedRoundIds.delete(uniqueKey)
  }
}
```

#### 9.2.3 定时器配置

```typescript
// 使用 200ms 间隔保证倒计时流畅和精确
countdownTimer = window.setInterval(updateCountdown, 200)
```

#### 9.2.4 周期切换监听

```typescript
// 监听周期切换，重新初始化倒计时
watch(
  () => marketStore.selectedDuration,
  () => {
    const round = currentRound.value
    if (round) {
      initFromRound(round)

      // 计算新周期的剩余时间和锁定状态
      const now = Date.now()
      const remainingMs = currentCloseTime.value - now
      const totalSeconds = Math.max(0, Math.ceil(remainingMs / 1000))
      const lockOffsetSeconds = Math.ceil(configLockOffset.value / 1000)
      const shouldBeLocked = totalSeconds <= lockOffsetSeconds

      // 立即 emit 正确的锁定状态，确保父组件立即更新
      isWarning.value = shouldBeLocked
      emit('lock-change', shouldBeLocked)

      updateCountdown()
    }
  }
)

// 监听 API 返回的新轮次数据
watch(
  () => marketStore.roundList,
  (newRounds) => {
    if (!newRounds || newRounds.length === 0) return

    const round = currentRound.value
    if (!round) return

    // 如果 API 返回更新的轮次，更新本地时间
    const apiCloseTime = new Date(round.closeTime).getTime()
    if (apiCloseTime > currentCloseTime.value) {
      initFromRound(round)
    }
  },
  { deep: true }
)
```

### 9.3 涉及文件

| 文件 | 修改内容 |
|------|----------|
| `src/components/trading/CountdownTimer.vue` | 核心倒计时逻辑重构 |
| `src/components/trading/TradingPanel.vue` | 简化，移除冗余 props |
| `src/components/trading/TradingLayout.vue` | 简化，移除冗余 props |
| `src/store/market.ts` | 新增 `getRoundByDuration()` 方法 |
| `src/composables/useRoundManager.ts` | 备用多周期管理器（可选） |

### 9.4 数据流

```
API: /public/order/round/current/{symbolId}
  └── 返回: { rounds: [1min, 3min, 5min, 15min] }

marketStore
  ├── roundList: 所有周期轮次数据
  └── getCurrentRoundByDuration: 根据 selectedDuration 获取当前周期轮次

CountdownTimer.vue
  ├── initFromRound(): 从 API 数据初始化
  ├── moveToNextRound(): 预测下一轮时间
  ├── updateCountdown(): 每 200ms 更新显示
  └── handleRoundExpired(): 异步刷新数据
        ├── marketStore.getCurrentRound(true)  // 刷新轮次
        └── orderStore.refreshActiveOrders()   // 刷新订单（仅1分钟）
```

### 9.5 关键特性

| 特性 | 实现方式 |
|------|----------|
| 无缝轮次切换 | 预测式计算下一轮时间，无需等待 API |
| Lock 时间准确 | 使用 `configLockOffset` 保存 API 配置的 lockOffset（+1秒修正栅栏问题），基于显示秒数判断 |
| 时间对齐 | 使用 `Math.ceil` 确保倒计时与实际时钟对齐（00:00:00 显示 60，00:00:59 显示 1） |
| 周期切换锁定状态 | 切换周期时立即重新计算并 emit 锁定状态，确保父组件立即更新 |
| 去重机制 | 使用 `closeTime_duration` 唯一标识 |
| 订单刷新优化 | 仅 1 分钟轮次触发，覆盖所有周期 |
| 后台恢复 | while 循环处理错过的多个轮次 |
| 流畅体验 | 200ms 更新间隔 |
| 数据新鲜度保证 | :01秒首次请求，过期数据重试3次（间隔1秒） |

### 9.6 已修复的问题

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| Lock 时间显示 9 秒而非 10 秒 | API 返回的 lockTime=50, closeTime=59，差值为 9 秒，但实际是 50-59 共 10 秒（栅栏问题） | `configLockOffset = closeTime - lockTime + 1000` |
| 切换周期后锁定状态不更新 | 切换周期时只重置了 `isWarning`，但没有 emit 通知父组件 | 切换周期时立即计算并 emit 正确的锁定状态 |

---

## 十、待实现功能

### 10.1 账户切换时自动刷新余额

#### 10.1.1 问题描述

当用户点击 "Demo Trading" 按钮切换 REAL/DEMO 账户时，需要刷新页面才能获取新账户的余额。期望切换账户后自动获取对应账户的余额。

#### 10.1.2 现有实现分析

**文件**：`src/store/account.ts`

**当前逻辑**：
```typescript
const setAccountType = (type: AccountType) => {
  // 避免重复设置相同的类型
  if (accountType.value === type) {
    return
  }

  // 立即清空当前余额，避免显示错误的余额
  balance.value = 0

  // 更新账户类型
  accountType.value = type

  // 持久化存储
  localStorage.setItem('accountType', type)
  // ❌ 问题：没有调用 getBalance() 获取新账户余额
}
```

**问题**：`setAccountType` 只更新了账户类型并清空余额，但没有主动调用 `getBalance()` 获取新账户的余额。

#### 10.1.3 实现方案

**方案 A：在 setAccountType 中自动获取余额（推荐）**

```typescript
const setAccountType = async (type: AccountType) => {
  // 避免重复设置相同的类型
  if (accountType.value === type) {
    return
  }

  // 立即清空当前余额，避免显示错误的余额
  balance.value = 0

  // 更新账户类型
  accountType.value = type

  // 持久化存储
  localStorage.setItem('accountType', type)

  // ✅ 自动获取新账户余额
  await getBalance(type)
}
```

**优点**：
- 改动最小，只需修改一处
- 逻辑集中在 store 中，调用方无需关心
- 保证切换账户后余额立即更新

**缺点**：
- `setAccountType` 变成异步函数，可能影响现有调用方

**方案 B：在调用方监听账户变化并获取余额**

在使用账户切换的组件中添加 watch：

```typescript
watch(() => accountStore.accountType, async (newType) => {
  await accountStore.getBalance(newType)
})
```

**优点**：
- 不改变 `setAccountType` 的同步特性
- 调用方可以控制是否需要刷新余额

**缺点**：
- 需要在多处添加 watch
- 容易遗漏，导致部分场景余额不刷新

#### 10.1.4 推荐方案

**推荐使用方案 A**，原因：
1. 改动集中，只需修改 `account.ts` 一个文件
2. 语义清晰：切换账户 = 更新类型 + 获取新余额
3. 调用方无需关心实现细节

#### 10.1.5 涉及文件

| 文件 | 修改内容 |
|------|----------|
| `src/store/account.ts` | `setAccountType` 方法添加 `await getBalance(type)` |

#### 10.1.6 注意事项

1. `setAccountType` 变为异步后，`switchToDemo` 和 `switchToReal` 也需要相应调整
2. 需要处理获取余额失败的情况（网络错误等）
3. 可以考虑添加 loading 状态，在获取余额期间显示加载中

---

### 10.2 High Payouts 动态数据实现 ✅ 已完成

#### 10.2.1 需求描述

High Payouts 组件当前使用静态假数据，需要改为动态数据：
1. 根据已有的 symbols 信息和 WebSocket 实时数据
2. 按照 odds（赔率）进行排序
3. 不同的 rounds（周期）可能有不同的赔率，取最高的赔率进行排序
4. 选出赔率最高的 3 个 symbols 显示

#### 10.2.2 现有数据结构分析

**symbols 数据**（来自 `marketStore.symbolsAllList`）：
```typescript
interface Symbol {
  symbolId: number
  symbol: string           // 如 "BTC-USDT"
  baseCurrency: string     // 如 "BTC"
  quoteCurrency: string    // 如 "USDT"
  baseOdds: number         // 基础赔率
  // ...
}
```

**WebSocket odds 数据**（来自 `websocketStore.getMarketData(symbol).odds`）：
```typescript
interface OddsData {
  duration: number    // 周期（分钟）：1, 3, 5, 15
  upOdds: number      // 看涨赔率
  downOdds: number    // 看跌赔率
}
```

**useMarketListData 已转换的数据**：
```typescript
interface MarketListItem {
  symbolId: string
  symbol: string
  baseCurrency: string
  quoteCurrency: string
  price: number
  priceChange: number
  payouts: MarketPayout[]  // 各周期的赔率信息
}

interface MarketPayout {
  duration: number        // 周期（分钟）
  upMultiplier: number    // 看涨赔率
  downMultiplier: number  // 看跌赔率
  locked: boolean         // 是否锁定
}
```

#### 10.2.3 实现方案

**方案：复用 useMarketListData，添加 High Payouts 计算逻辑**

```typescript
// 在 useMarketListData.ts 中添加

/**
 * 获取 High Payouts 列表
 * 按照最高赔率排序，返回前 3 个 symbols
 */
const highPayoutItems = computed(() => {
  // 为每个 symbol 计算最高赔率
  const itemsWithMaxOdds = marketListItems.value.map(item => {
    // 从所有周期中找出最高的赔率（取 upMultiplier 和 downMultiplier 中的较大值）
    let maxOdds = 0
    let bestPayout: MarketPayout | null = null

    item.payouts.forEach(payout => {
      const maxInPayout = Math.max(payout.upMultiplier, payout.downMultiplier)
      if (maxInPayout > maxOdds) {
        maxOdds = maxInPayout
        bestPayout = payout
      }
    })

    return {
      ...item,
      maxOdds,
      bestPayout,
    }
  })

  // 按最高赔率降序排序，取前 3 个
  return itemsWithMaxOdds
    .filter(item => item.maxOdds > 0) // 过滤掉没有赔率数据的
    .sort((a, b) => b.maxOdds - a.maxOdds)
    .slice(0, 3)
})
```

**HighPayouts.vue 组件改造**：

```typescript
import { useMarketListData } from '@/composables/useMarketListData'

const { highPayoutItems, loadMarketList } = useMarketListData()

// 转换为 PayoutCard 格式
const payoutCards = computed(() => {
  return highPayoutItems.value.map(item => ({
    symbolId: item.symbolId,
    symbol: item.baseCurrency,
    baseCurrency: item.baseCurrency,
    quoteCurrency: item.quoteCurrency,
    duration: item.bestPayout?.duration || 1,
    upMultiplier: item.bestPayout?.upMultiplier || 0,
    downMultiplier: item.bestPayout?.downMultiplier || 0,
    expiryTime: calculateExpiryTime(item.bestPayout?.duration || 1),
  }))
})
```

#### 10.2.4 涉及文件

| 文件 | 修改内容 |
|------|----------|
| `src/composables/useMarketListData.ts` | 添加 `highPayoutItems` computed 属性 |
| `src/components/orders/HighPayouts.vue` | 使用 `useMarketListData` 替代静态数据 |

#### 10.2.5 数据流

```
symbols API + WebSocket odds
       ↓
useMarketListData
       ↓
marketListItems (所有 symbols 的完整数据)
       ↓
highPayoutItems (按最高赔率排序的前 3 个)
       ↓
HighPayouts.vue (展示)
```

#### 10.2.6 注意事项

1. **实时更新**：WebSocket 数据变化时，高赔率排名会自动更新
2. **边界情况**：如果 odds 数据未加载，需要显示 loading 或 fallback
3. **性能考虑**：computed 已经做了缓存，只在数据变化时重新计算
4. **到期时间计算**：需要根据当前轮次的 closeTime 计算剩余时间

#### 10.2.7 实现完成 (2025-12-16)

**修改的文件：**

1. **`src/components/orders/HighPayouts.vue`**
   - 直接使用 `marketStore` 和 `websocketStore` 获取数据（不使用 `useMarketListData` composable，避免数据实例隔离问题）
   - 在组件内部计算 `payoutCards`：遍历所有 symbol，找出每个 symbol 所有 odds 中最高的，按 maxOdds 降序排序，取前 3 个
   - 添加 `currentTime` ref 实现到期时间实时更新（每秒更新）
   - 确保 symbols 数据在组件挂载时已加载

**实现逻辑：**
```typescript
// 动态卡片数据 - 直接从 store 计算
const payoutCards = computed<PayoutCard[]>(() => {
  const now = currentTime.value
  const symbols = marketStore.symbolsAllList

  if (!symbols || symbols.length === 0) {
    return []
  }

  // 计算每个 symbol 的最高赔率
  const itemsWithMaxOdds = symbols.map(symbol => {
    const marketData = websocketStore.getMarketData(symbol.symbol)
    const odds = marketData?.odds || []

    let maxOdds = 0
    let bestOddsData = null

    odds.forEach((o: any) => {
      const maxInOdds = Math.max(o.upOdds || 0, o.downOdds || 0)
      if (maxInOdds > maxOdds) {
        maxOdds = maxInOdds
        bestOddsData = o
      }
    })

    return { ...symbol, maxOdds, bestOddsData }
  })

  // 按最高赔率排序，取前3个
  return itemsWithMaxOdds
    .filter(item => item.maxOdds > 0)
    .sort((a, b) => b.maxOdds - a.maxOdds)
    .slice(0, 3)
    .map(item => ({ /* 转换为 PayoutCard 格式 */ }))
})
```

**实现效果：**
- High Payouts 区域显示当前赔率最高的 3 个交易对
- 赔率数据来自 WebSocket 实时推送，与其他组件共享同一数据源
- 到期时间每秒更新
- WebSocket 数据变化时自动更新排名

**注意事项：**
- 使用 Pinia store 共享数据，避免 composable 实例隔离导致数据不同步
- 如果 WebSocket 数据尚未到达，卡片列表会是空的，直到收到第一次 odds 数据

---

### 10.3 Token 与账户类型处理 ✅ 已完成

#### 10.3.1 问题描述

用户可能同时拥有 OAuth token（正式用户）和 Demo token（匿名用户），需要根据 token 存在情况决定请求行为：
- 有 OAuth token：DEMO 和 REAL 都使用 OAuth token
- 无 OAuth token：DEMO 使用 Demo token，REAL 跳转登录页面

#### 10.3.2 HTTP 请求头处理

**文件**: `src/api/http.ts`

```typescript
// 添加认证头
if (needAuth) {
  const token = this.getAuthToken()
  if (token) {
    // 有 OAuth token 时，统一使用 OAuth token（无论 DEMO 还是 REAL）
    headers.Authorization = `Bearer ${token}`
  } else {
    // 无 OAuth token 时，使用 Demo token
    try {
      const authStore = useAuthStore()
      const demoToken = authStore.getDemoToken()
      if (demoToken) {
        headers['X-Demo-Token'] = demoToken
      }
    } catch (e) {
      console.warn('获取Demo Token失败')
    }
  }
}
```

#### 10.3.3 账户切换处理

**文件**: `src/store/account.ts`

切换到 REAL 账户时，检查是否有 OAuth token，没有则跳转登录：

```typescript
const setAccountType = async (type: AccountType): Promise<boolean> => {
  if (accountType.value === type) {
    return true
  }

  // 切换到 REAL 账户时，检查是否有 OAuth token
  if (type === 'REAL') {
    const { useAuthStore } = await import('./auth')
    const authStore = useAuthStore()

    // 没有 OAuth token，需要跳转登录
    if (!authStore.getToken()) {
      const { useIframeComm } = await import('@/composables/useIframeComm')
      const { requestLoginRedirect } = useIframeComm()
      requestLoginRedirect()
      return false // 返回 false 表示切换未完成
    }
  }

  // ... 继续切换逻辑
  return true
}
```

#### 10.3.4 处理逻辑

1. **有 OAuth token**：
   - DEMO 和 REAL 都使用 `Authorization: Bearer {token}`
   - 用户可以自由切换

2. **无 OAuth token**：
   - DEMO 模式：使用 `X-Demo-Token` 头
   - REAL 模式：调用 `requestLoginRedirect()` 跳转登录页面

#### 10.3.5 OAuth Token 准备状态

**问题**：页面刷新时，`ActiveOrders.vue` 的 `onMounted` 会立即请求订单，但此时 OAuth token 还没有通过 iframe 消息传递过来，导致使用了 Demo token。

**解决方案**：添加 `isOAuthTokenReady` 状态，组件等待此状态为 true 后再发送请求。

**文件**: `src/store/auth.ts`

```typescript
// 新增状态
const isOAuthTokenReady = ref<boolean>(false)

// setToken 时标记为 ready
const setToken = (newToken: string) => {
  token.value = newToken
  hasOAuthToken.value = !!newToken
  isOAuthTokenReady.value = true  // 标记已准备好
}

// init 时根据环境设置初始值
const init = () => {
  if (inIframe) {
    isOAuthTokenReady.value = false  // iframe 环境等待消息
  } else {
    isOAuthTokenReady.value = true   // 非 iframe 环境直接 ready
  }
}
```

**文件**: `src/components/orders/ActiveOrders.vue`

```typescript
// 监听 OAuth token 准备状态
watch(() => authStore.isOAuthTokenReady, (ready) => {
  if (ready) {
    loadActiveOrders()
  }
})

// onMounted 时检查状态
onMounted(() => {
  if (authStore.isOAuthTokenReady) {
    loadActiveOrders()
  }
  startCountdownTimer()
})
```

---

最后更新: 2025-12-16
