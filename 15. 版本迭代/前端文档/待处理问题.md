# 前端对接待处理问题

## 重要架构说明

### API 请求优化原则

**周期配置是全局的，不需要为每个 symbol 单独请求 round 信息：**

1. **`/public/order/durations`** - 获取所有交易周期配置（全局配置，对所有 symbols 通用）
   - 在应用初始化时请求一次即可
   - 返回 1分钟、3分钟、5分钟、15分钟等周期配置
   - **包含 `lockSeconds` 字段用于计算锁定状态**

2. **`/public/order/round/current/{symbolId}`** - 只在用户点击具体交易对时才请求
   - 获取当前轮次的详细信息（roundId, openTime, closeTime, lockTime 等）
   - 用于下单时的 roundId 参数

3. **WebSocket tick 数据** - 包含所有周期的实时赔率
   - `odds` 数组包含各周期（1/3/5/15分钟）的 upOdds 和 downOdds
   - 无需单独请求赔率数据

### 锁定状态计算逻辑

**锁定状态通过 `lockSeconds` 和当前时间计算，而非赔率值判断：**

```typescript
/**
 * 计算指定周期是否处于锁定状态
 * @param durationMinutes 周期时长（分钟）
 * @param lockSeconds 锁单时间（秒）
 * @returns 是否锁定
 */
const isLocked = (durationMinutes: number, lockSeconds: number): boolean => {
  const now = Date.now()
  const durationMs = durationMinutes * 60 * 1000
  // 计算当前周期的结束时间（下一个整点时间）
  const periodEnd = Math.ceil(now / durationMs) * durationMs
  // 计算距离周期结束还有多少毫秒
  const timeToEnd = periodEnd - now
  // 如果距离结束时间小于 lockSeconds，则锁定
  return timeToEnd <= lockSeconds * 1000
}
```

**实时更新机制：**

锁定状态通过定时器每秒实时更新，确保 UI 及时反映当前锁定状态：

```typescript
// useMarketListData.ts
const lockUpdateInterval = ref<number | null>(null)

// 每秒更新所有项目的锁定状态
const updateLockStatus = () => {
  marketListItems.value.forEach(item => {
    item.payouts.forEach(payout => {
      const config = durationsConfig.find(d => d.durationMinutes === payout.duration)
      if (config) {
        payout.locked = isLocked(payout.duration, config.lockSeconds)
      }
    })
  })
}

// 启动定时更新器
const startLockStatusUpdater = () => {
  lockUpdateInterval.value = window.setInterval(updateLockStatus, 1000)
}

// 组件卸载时自动清理
onUnmounted(() => {
  if (lockUpdateInterval.value) {
    clearInterval(lockUpdateInterval.value)
  }
})
```

**使用方式：**
```typescript
// MarketList.vue
onMounted(async () => {
  await loadMarketList()
  startLockStatusUpdater()  // 启动实时更新
})
```

---

## 对接过程中发现的问题

### 1. WebSocket 实时行情

#### 1.1 模板硬编码赔率值
**文件**: `src/components/trading/ExpirationOptions.vue`
**问题**: 模板中的赔率值 `1.32` 是硬编码的，没有绑定到实际的 odds 数据
```html
<span class="payout-value">1.32</span>
```
**状态**: 已修复 - 修改为动态绑定 `formatMultiplier(option.upMultiplier)` 和 `formatMultiplier(option.downMultiplier)`

#### 1.2 交易对名称格式
**问题**: 后端 WebSocket 订阅使用 `BTC-USDT` 格式，前端 Mock 数据已更新为相同格式
**状态**: 已修复

### 2. 类型系统

#### 2.1 symbolId 类型不一致
**问题**: 部分代码仍使用 `string` 类型的 symbolId
**状态**: 主要文件已修复为 `number` 类型
**需要检查的文件**:
- `src/components/` 下的组件
- `src/views/` 下的页面

### 3. API 响应处理

#### 3.1 响应状态判断
**问题**: 部分代码使用 `res.success` 判断响应状态，应该使用 `res.code === 200`
**状态**: 主要 API 调用已修复
**需要检查的文件**:
- `src/composables/useMarketCardData.ts` - 已修复
- `src/store/market.ts` - 已修复
- 其他使用 API 的组件

### 4. 时间处理

#### 4.1 ISO 时间字符串
**问题**: 后端返回 ISO 格式时间字符串，前端需要统一使用 `src/utils/timeUtils.ts` 进行转换
**状态**: 工具函数已创建，组件需要逐步迁移

### 5. 废弃代码清理

#### 5.1 Fixture 相关代码
**问题**: 已移除 `Fixture` 接口，但部分组件可能仍有引用
**状态**: 主要文件已更新为使用 `OddsData`
**已修复文件**:
- `src/types/websocket.ts` - 移除 Fixture
- `src/store/websocket.ts` - getFixtures -> getOdds
- `src/composables/useTrading.ts` - 使用 odds
- `src/composables/useMarketCardData.ts` - 使用 odds
- `src/components/trading/ExpirationOptions.vue` - 使用 odds
- `src/components/trading/TradingForm.vue` - 使用 odds

## 后续优化建议

### 1. 批量订阅优化
WebSocket 已支持批量订阅，建议在应用初始化时一次性订阅所有交易对：
```typescript
websocketStore.subscribe(['BTC-USDT', 'ETH-USDT', 'SOL-USDT', ...])
// 或订阅所有
websocketStore.subscribeAll()
```

### 2. 周期选择联动
当用户切换交易周期时，需要：
1. 更新 `marketStore.selectedDuration`
2. 触发 UI 更新显示对应周期的赔率
3. 获取对应周期的轮次信息

### 3. 错误处理增强
建议在 API 调用失败时添加用户友好的错误提示：
- 网络错误
- 服务器错误
- 数据格式错误

### 4. 已修复的联动问题

#### 4.1 周期选择全局同步
**文件**: `src/components/trading/TradingLayout.vue`
**问题**: TradingLayout 的 selectedDuration 使用本地 ref，不与全局 store 同步
**解决方案**: 使用 computed getter/setter 与 marketStore.selectedDuration 同步
```typescript
const selectedDuration = computed({
  get: () => marketStore.selectedDuration,
  set: (value: number) => marketStore.setSelectedDuration(value)
})
```
**状态**: 已修复

#### 4.2 Featured Options 搜索框行为
**文件**: `src/components/market/CryptoMarketScroll.vue`
**设计决策**: Featured Options 的搜索框不与 activeSymbolId 联动
- 搜索框默认始终为空
- 用户选择 symbol 后，会设置 activeSymbolId 并清空搜索框
- 点击卡片只切换 symbol，不影响搜索框状态
**状态**: 已实现

#### 4.3 symbolId 类型统一处理
**问题**: API 返回的 symbolId 可能是 string 类型，而 store 中使用 number 类型，导致比较失败
**解决方案**: 在 `src/store/market.ts` 中添加统一的类型转换函数
```typescript
// 将 symbolId 统一转换为 number 类型
const toNumberId = (id: number | string): number => {
  return typeof id === 'string' ? parseInt(id, 10) : id
}

// getSymbolById 和 activeSymbol 都使用此函数进行比较
const getSymbolById = (symbolId: number | string) => {
  const id = toNumberId(symbolId)
  return symbolsAllList.value.find((s: Symbol) => toNumberId(s.symbolId) === id) || null
}
```
**影响范围**:
- `src/store/market.ts` - 核心类型转换逻辑
- `src/components/market/SymbolTabs.vue` - 标签页比较逻辑
- `src/components/market/MarketListDropdown.vue` - 下拉框过滤逻辑
- `src/components/market/MarketCard.vue` - 卡片类型定义
**状态**: 已修复

#### 4.4 SymbolTabs 标签页联动
**文件**: `src/components/market/SymbolTabs.vue`
**问题**:
1. 每次刷新页面都会增加一个 symbol（类型比较失败导致重复添加）
2. 点击其他区域选择 symbol 时标签页不联动
**解决方案**:
1. 统一使用 `toNumberId` 函数进行 symbolId 比较
2. 监听 `activeSymbolId` 变化，自动将新 symbol 添加到标签列表
3. 只在首次加载时初始化标签列表（使用 `isInitialized` 标记）
```typescript
// 监听活跃交易对变化，确保它在选中列表中
watch(
  () => marketStore.activeSymbolId,
  (newId) => {
    const symbol = marketStore.getSymbolById(newId)
    if (symbol && Object.keys(symbol).length > 0) {
      addSymbolToList(symbol as Symbol)
    }
  }
)
```
**状态**: 已修复

---

## 下单 API 对接

### 5. 订单创建接口

#### 5.1 接口信息
**端点**: `POST /api/borc/order`
**认证**: 需要 Bearer Token 或 Demo Token

**请求参数**:
```typescript
interface CreateOrderRequest {
  symbolId: number       // 交易对ID
  accountType: 'REAL' | 'DEMO'  // 账户类型
  amount: string         // 下单金额（2位小数）
  direction: 'UP' | 'DOWN'  // 方向
  roundId: number        // 轮次ID
}
```

**响应格式**:
```typescript
interface OrderCreateResponse {
  code: number           // 200 表示成功
  success: boolean
  message: string
  data: {
    orderId: number
    accountType: 'DEMO' | 'REAL'
    symbolName: string
    roundNo: string
    direction: 'UP' | 'DOWN'
    amount: number
    odds: number
    expectedProfit: number
    orderPrice: number
    status: 'ACTIVE'
    createTime: string
  }
}
```

#### 5.2 已实现功能
**文件**: `src/components/trading/TradingForm.vue`

1. **防重复提交**: 添加 `isSubmitting` 状态，在提交期间禁用按钮
2. **轮次验证**: 检查 `currentRound.roundId` 是否有效
3. **响应判断兼容**: 同时支持 `res.success` 和 `res.code === 200`
4. **乐观更新**: DEMO 账户立即扣除余额，REAL 账户由 BTSE WebSocket 推送更新

```typescript
// 下单提交
const submitOrder = async (data: any) => {
  // 防止重复提交
  if (isSubmitting.value) return

  isSubmitting.value = true

  try {
    const res = await api.order.createOrder(data)

    // 兼容两种响应判断方式
    if (res && (res.success || res.code === 200)) {
      message.success(t('formTrade.orderPlacedSuccessfully'))

      // DEMO 账户乐观更新余额
      if (props.accountType === 'DEMO') {
        const newBalance = PrecisionMath.subtract(accountStore.balance, data.amount)
        accountStore.balance = Math.max(0, newBalance)
      }

      // 触发父组件刷新
      emit('order-success', { orderId: res.data?.orderId, ... })
    } else {
      message.error(res?.message || t('formTrade.orderFailed'))
    }
  } catch (err) {
    message.error(err?.message || t('formTrade.orderFailed'))
  } finally {
    isSubmitting.value = false
  }
}
```

#### 5.3 按钮禁用逻辑
下单按钮在以下情况禁用：
- 正在提交中 (`isSubmitting`)
- 未登录
- 未输入金额或金额无效
- 有验证错误（金额限制）
- 没有有效的轮次ID

```typescript
const buttomIsDisabled = computed(() => {
  if (isSubmitting.value) return true
  if (!isLogin.value) return true
  if (!stakeAmount.value || parseFloat(stakeAmount.value) <= 0) return true
  if (stakeAmountStatus.value === 'error') return true
  if (!props.currentRound?.roundId) return true
  return false
})
```

#### 5.4 国际化支持
新增 `noActiveRound` 翻译键用于轮次不可用提示：
- EN: "No active trading round available"
- 简中: "当前没有可用的交易轮次"
- 繁中: "當前沒有可用的交易輪次"
- 日文: "現在利用可能な取引ラウンドがありません"
- 韩文: "현재 사용 가능한 거래 라운드가 없습니다"

#### 5.5 PC端下单组件架构
**组件链路**: `TradingPanelCore.vue` → `TradingPanel.vue` → `TradingLayout.vue`

**TradingPanelCore.vue**:
- 负责 UI 展示：投资金额输入、滑块、上涨/下跌按钮
- 点击按钮时 emit `trade` 事件，携带 `direction` 和 `amount`

**TradingPanel.vue** (PC端核心下单逻辑):
- 接收 `trade` 事件并调用下单 API
- 从 `marketStore` 获取当前轮次和交易对信息
- 从 `accountStore` 获取账户类型（DEMO/REAL）
- 下单成功后：
  - DEMO 账户乐观更新余额
  - emit `order-success` 事件通知父组件刷新

```typescript
// 关键数据获取方式
const currentRound = marketStore.getCurrentRoundByDuration || marketStore.currentRound
const activeSymbol = marketStore.activeSymbol
const accountType = accountStore.accountType || props.accountType
```

**注意事项**:
- `TradingForm.vue` 是 H5 移动端使用的组件，PC 端不使用
- 轮次数据优先从 store 获取，确保与当前选中周期同步
- 账户类型优先从 accountStore 获取，避免 props 默认值覆盖

---

## 订单列表 API 对接

### 6. 活跃订单列表

#### 6.1 接口信息
**端点**: `GET /api/borc/order/list/active`
**认证**: 需要 Bearer Token 或 Demo Token

**请求参数**:
```typescript
{
  accountType?: 'REAL' | 'DEMO'  // 账户类型
  symbolId?: number              // 交易对ID（可选，用于过滤）
}
```

**响应格式**:
```typescript
interface ActiveOrdersListResponseDTO {
  rounds: HistoryRoundOrderDTO[]  // 轮次列表
  totalRounds: number             // 轮次总数
  totalOrders: number             // 订单总数
}

interface HistoryRoundOrderDTO {
  roundId: number
  roundNo: string
  symbolId: number
  symbol: string                  // 如 "BTC-USDT"
  durationMinutes: number
  startTime: string               // ISO 日期
  endTime: string                 // ISO 日期
  startPrice: string
  endPrice: string
  status: string
  orders: OrderDTO[]
}

interface OrderDTO {
  orderId: number
  direction: 'UP' | 'DOWN'
  amount: string
  odds: string
  expectedProfit: string
  orderPrice: string
  status: string
  createTime: string
}
```

#### 6.2 组件实现
**文件**: `src/components/orders/ActiveOrders.vue`

**核心逻辑**:
- 组件挂载时自动加载活跃订单
- 使用 `orderStore.loadActiveOrders()` 获取数据
- 监听 `accountStore.accountType` 变化自动刷新
- 实时倒计时显示剩余时间
- 支持按 Token 过滤和按到期时间排序

```typescript
// 数据转换：API 数据 -> 组件格式
const transformApiDataToOrders = computed(() => {
  const apiData = orderStore.activeOrders
  // rounds -> OrderGroup[] (tokenName, currentPrice, orderId, tradeItems...)
})

// 加载数据
const loadActiveOrders = async () => {
  const accountType = accountStore.accountType || 'DEMO'
  await orderStore.loadActiveOrders(accountType)
}
```

---

### 7. 历史订单列表

#### 7.1 接口信息
**端点**: `GET /api/borc/order/list/history`
**认证**: 需要 Bearer Token 或 Demo Token

**请求参数**:
```typescript
{
  accountType?: 'REAL' | 'DEMO'
  symbolId?: number
  startTime?: number      // 时间戳
  endTime?: number        // 时间戳
  page?: number           // 页码（从1开始）
  pageSize?: number       // 每页数量
}
```

**响应格式**:
```typescript
interface HistoryOrdersListResponseDTO {
  rounds: HistoryRoundOrderDTO[]
  total: number           // 总记录数
  page: number            // 当前页
  pageSize: number        // 每页大小
  totalPages: number      // 总页数
  hasNext: boolean
  hasPrevious: boolean
}
```

#### 7.2 组件实现
**文件**: `src/components/orders/HistoryOrderTable.vue`

**核心逻辑**:
- 组件挂载时自动加载历史订单
- 使用 `orderStore.loadHistoryOrders()` 获取数据
- 支持分页、按币种过滤
- Tab 切换触发重新加载
- 账户类型变化自动刷新

```typescript
// 加载历史订单
const loadHistoryOrders = async () => {
  const accountType = accountStore.accountType || 'DEMO'
  await orderStore.loadHistoryOrders(accountType, {
    page: currentPage.value,
    pageSize: 10,
    symbolId,  // 根据选中的 tab 过滤
  })
}

// 分页处理
const handlePageChange = (page: number) => {
  currentPage.value = page
  loadHistoryOrders()
}
```

---

---

## 当前状态总结 (2025-12-15)

### 已全部解决的问题

| 序号 | 问题 | 状态 |
|------|------|------|
| 1.1 | 模板硬编码赔率值 | ✅ 已解决 |
| 1.2 | 交易对名称格式 | ✅ 已解决 |
| 2.1 | symbolId 类型不一致 | ✅ 已解决 |
| 3.1 | 响应状态判断 | ✅ 已解决 |
| 4.1 | ISO 时间字符串处理 | ✅ 已解决 |
| 5.1 | Fixture 相关废弃代码 | ✅ 已解决 |
| 4.1-4.4 | 联动问题 | ✅ 已解决 |
| 5.x | 下单 API 对接 | ✅ 已解决 |
| 6.x | 活跃订单列表 | ✅ 已解决 |
| 7.x | 历史订单列表 | ✅ 已解决 |

### 后续优化建议实施状态

| 建议 | 状态 | 说明 |
|------|------|------|
| 批量订阅优化 | ✅ 已实现 | App.vue 中 subscribeAll() |
| 周期选择联动 | ✅ 已实现 | marketStore.selectedDuration 全局同步 |
| 错误处理增强 | ⏳ 待优化 | 可进一步完善错误提示 |

### 遗留优化点

详见 [进一步优化方案.md](./进一步优化方案.md)

---

最后更新: 2025-12-15
