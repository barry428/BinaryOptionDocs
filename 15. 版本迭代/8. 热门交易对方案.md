# 热门交易对技术方案

## 1. 概述

实现热门交易对功能，通过定时任务统计最近24小时各交易对的交易量，支持按时间区间（1min, 3min, 5min, 15min）细分统计，缓存到Redis中，为前端提供热门交易对查询接口。

## 2. 整体架构

```
+-------------------+     +-------------------+     +-------------------+
|    定时任务        |---->|      Redis        |<----|    公开API        |
|   (每小时执行)     |     |   (Hash缓存)      |     |  (热门交易对)     |
+-------------------+     +-------------------+     +-------------------+
         |                                                   |
         v                                                   v
+-------------------+                             +-------------------+
|  bo_trading_      |                             |     前端展示       |
|  round 表         |                             |                   |
+-------------------+                             +-------------------+
```

## 3. 数据结构设计

### 3.1 交易量统计维度

| 维度 | 说明 |
|------|------|
| symbol | 交易对（如 BTC-USDT） |
| duration | 时间区间（1, 3, 5, 15 分钟） |
| volume24h | 该维度下24小时交易量 |

### 3.2 排序规则

**两级排序**：
1. **第一级**：按 symbol 整体交易量（所有区间之和）降序
2. **第二级**：同一 symbol 内，按区间交易量降序

**示例**：
```
排序结果：
1. BTC-USDT (总量: 1000万)
   - 1min:  500万  ← 最热门区间
   - 3min:  300万
   - 5min:  150万
   - 15min:  50万

2. ETH-USDT (总量: 800万)
   - 3min:  400万  ← 最热门区间
   - 1min:  250万
   - 5min:  100万
   - 15min:  50万
```

## 4. 需要修改的文件

```
BinaryOption/
├── option-common-dto/
│   └── src/main/java/com/binaryoption/dto/
│       ├── SymbolVolumeDTO.java              # [修改] 添加 duration 字段
│       ├── SymbolDurationVolumeDTO.java      # [新增] 区间交易量DTO
│       └── response/
│           └── HotSymbolResponse.java        # [修改] 包含区间交易量列表
│
├── option-common-utils/
│   └── src/main/java/com/binaryoption/commonutils/constants/
│       └── CacheConstants.java               # [修改] 添加缓存Key常量
│
└── option-order-service/
    ├── src/main/java/com/binaryoption/orderservice/
    │   ├── mapper/
    │   │   └── TradingRoundMapper.java       # [修改] 添加按区间统计方法
    │   ├── service/
    │   │   ├── SymbolService.java            # [修改] 修改热门交易对业务逻辑
    │   │   └── ScheduledTaskService.java     # [修改] 修改定时任务
    │   └── controller/
    │       └── PublicOrderController.java    # [修改] 修改API返回结构
    │
    └── src/main/resources/mapper/
        └── TradingRoundMapper.xml            # [修改] 修改统计SQL
```

## 5. 修改说明

| 文件 | 操作 | 说明 |
|------|------|------|
| `SymbolVolumeDTO.java` | 修改 | 添加 `totalVolume24h`（整体交易量）和 `durationVolumes`（区间交易量列表） |
| `SymbolDurationVolumeDTO.java` | 新增 | 区间交易量DTO，包含 `duration`、`volume24h` 字段 |
| `HotSymbolResponse.java` | 修改 | 响应包含区间交易量数据 |
| `TradingRoundMapper.java` | 修改 | 修改查询方法，按 symbol + duration 分组统计 |
| `TradingRoundMapper.xml` | 修改 | 修改SQL，GROUP BY symbol, duration_minutes |
| `SymbolService.java` | 修改 | 修改排序逻辑：先按整体交易量，再按区间交易量 |
| `ScheduledTaskService.java` | 修改 | 定时任务统计并缓存区间交易量数据 |
| `PublicOrderController.java` | 修改 | API返回包含区间信息 |

## 6. 数据流

### 6.1 定时任务 (每小时第5分钟执行)

```
Step 1: 查询 bo_trading_round 表
        - 统计24h内各交易对在各时间区间的交易量
        - GROUP BY symbol, duration_minutes

Step 2: 内存聚合
        - 计算每个 symbol 的总交易量
        - 按区间交易量降序排列各 symbol 的区间列表

Step 3: 排序
        - 第一级：按 symbol 总交易量降序
        - 第二级：同一 symbol 内，按区间交易量降序
        - 交易量相同时，按 sort_order 升序

Step 4: 写入 Redis Hash
        - Key: BO:Symbol:Volume24h
        - TTL: 2小时
```

### 6.2 API查询

```
1. 优先从 Redis 读取缓存
2. 缓存miss时 fallback 查询数据库
3. 返回包含区间交易量的完整数据
```

## 7. SQL查询

**统计各 symbol 各区间的24h交易量**
```sql
SELECT
    symbol,
    duration_minutes,
    COALESCE(SUM(total_up_amount + total_down_amount), 0) as volume24h
FROM bo_trading_round
WHERE created_at >= NOW() - INTERVAL '24 hours'
GROUP BY symbol, duration_minutes
ORDER BY symbol, volume24h DESC
```

**结果示例**：
| symbol | duration_minutes | volume24h |
|--------|-----------------|-----------|
| BTC-USDT | 1 | 5000000 |
| BTC-USDT | 3 | 3000000 |
| BTC-USDT | 5 | 1500000 |
| BTC-USDT | 15 | 500000 |
| ETH-USDT | 3 | 4000000 |
| ETH-USDT | 1 | 2500000 |
| ... | ... | ... |

## 8. API规范

**接口**: `GET /api/borc/public/order/symbols/hot`

| 参数 | 类型 | 必填 | 默认值 | 说明 |
|------|------|------|--------|------|
| limit | int | 否 | 10 | 返回数量，最大50 |

**响应**:
```json
{
  "code": 0,
  "message": "success",
  "data": {
    "items": [
      {
        "symbolId": 1,
        "symbol": "BTC-USDT",
        "totalVolume24h": 10000000.00,
        "durationVolumes": [
          { "duration": 1, "volume24h": 5000000.00 },
          { "duration": 3, "volume24h": 3000000.00 },
          { "duration": 5, "volume24h": 1500000.00 },
          { "duration": 15, "volume24h": 500000.00 }
        ]
      },
      {
        "symbolId": 2,
        "symbol": "ETH-USDT",
        "totalVolume24h": 8000000.00,
        "durationVolumes": [
          { "duration": 3, "volume24h": 4000000.00 },
          { "duration": 1, "volume24h": 2500000.00 },
          { "duration": 5, "volume24h": 1000000.00 },
          { "duration": 15, "volume24h": 500000.00 }
        ]
      }
    ]
  }
}
```

**响应字段说明**：

| 字段 | 类型 | 说明 |
|------|------|------|
| symbolId | number | 交易对ID |
| symbol | string | 交易对名称 |
| totalVolume24h | number | 该交易对24h总交易量（所有区间之和） |
| durationVolumes | array | 各时间区间的交易量列表（按交易量降序） |
| durationVolumes[].duration | number | 时间区间（分钟）：1, 3, 5, 15 |
| durationVolumes[].volume24h | number | 该区间24h交易量 |

## 9. DTO 定义

### 9.1 SymbolDurationVolumeDTO（新增）

```java
@Data
public class SymbolDurationVolumeDTO {
    /** 时间区间（分钟）：1, 3, 5, 15 */
    private Integer duration;

    /** 该区间24h交易量 */
    private BigDecimal volume24h;
}
```

### 9.2 SymbolVolumeDTO（修改）

```java
@Data
public class SymbolVolumeDTO {
    /** 交易对ID */
    private Long symbolId;

    /** 交易对名称 */
    private String symbol;

    /** 24h总交易量（所有区间之和） */
    private BigDecimal totalVolume24h;

    /** 各区间交易量列表（按交易量降序） */
    private List<SymbolDurationVolumeDTO> durationVolumes;

    /** 配置的排序权重（交易量相同时使用） */
    private Integer sortOrder;
}
```

## 10. 内存聚合与排序逻辑

```java
// 1. 查询数据库，获取 symbol + duration 维度的交易量
List<SymbolDurationVolume> rawData = mapper.selectSymbolDurationVolume24h();

// 2. 按 symbol 分组
Map<String, List<SymbolDurationVolume>> groupedBySymbol = rawData.stream()
    .collect(Collectors.groupingBy(SymbolDurationVolume::getSymbol));

// 3. 构建结果列表
List<SymbolVolumeDTO> result = new ArrayList<>();
for (Map.Entry<String, List<SymbolDurationVolume>> entry : groupedBySymbol.entrySet()) {
    String symbol = entry.getKey();
    List<SymbolDurationVolume> volumes = entry.getValue();

    // 计算总交易量
    BigDecimal totalVolume = volumes.stream()
        .map(SymbolDurationVolume::getVolume24h)
        .reduce(BigDecimal.ZERO, BigDecimal::add);

    // 按区间交易量降序排序
    List<SymbolDurationVolumeDTO> sortedDurations = volumes.stream()
        .map(v -> new SymbolDurationVolumeDTO(v.getDuration(), v.getVolume24h()))
        .sorted((a, b) -> b.getVolume24h().compareTo(a.getVolume24h()))
        .collect(Collectors.toList());

    result.add(new SymbolVolumeDTO(symbol, totalVolume, sortedDurations));
}

// 4. 按总交易量降序排序（交易量相同时按 sortOrder 升序）
result.sort((a, b) -> {
    int cmp = b.getTotalVolume24h().compareTo(a.getTotalVolume24h());
    return cmp != 0 ? cmp : a.getSortOrder().compareTo(b.getSortOrder());
});
```

## 11. 注意事项

1. 定时任务使用 `@DistributedScheduled` 分布式锁，避免多实例重复执行
2. 缓存TTL 2小时 > 任务间隔 1小时，保证数据连续性
3. Service层有数据库fallback，避免缓存穿透
4. 交易量相同时，按 `bo_symbol_config.sort_order` 升序排列
5. 各 symbol 的 `durationVolumes` 数组已按交易量降序排列，前端可直接使用
6. 如果某个区间没有交易记录，该区间不会出现在 `durationVolumes` 中

## 12. 前端使用示例

```typescript
// 获取热门交易对
const response = await api.market.getHotSymbols(10)

// 第一个交易对
const topSymbol = response.data.items[0]
console.log(topSymbol.symbol)           // "BTC-USDT"
console.log(topSymbol.totalVolume24h)   // 10000000

// 该交易对最热门的时间区间
const hottestDuration = topSymbol.durationVolumes[0]
console.log(hottestDuration.duration)   // 1 (表示1分钟区间最热门)
console.log(hottestDuration.volume24h)  // 5000000
```

---

最后更新: 2025-12-18
