Binary Option Pricing (Odds)


作者：Matej Horvath

6

thumbs up
1
We estimate odds of bet fixtures as prices of binary options with the same characteristics

Bet target price  ~ binary option strike price

Time to end of a bet ~ binary option time to expiration

In the current version binary options are priced with the Black-Scholes model. As inputs the model takes a distance of the current underlying price from the option strike price (moneyness), time to expiration (time to maturity), and implied volatility (IV). Implied volatility is estimated from historical data by a machine learning prediction model.

The pricing model itself does not attempt to predict direction of the underlying asset, therefore whether it’s trending or not has no influence on the pricing. The current binary option model has no preference for side.

Pricing as a function of moneyness and time to maturity when IV is constant (approximately) can be visualized in a chart - volatility surface.

image-20251219-092338.png
As it can be seen in the chart, far from expiration, pricing approaches an almost linear dependency on  moneyness. The closer is an option to expiration the more pricing converges to a binary behavior, in relationship to moneyness. The further an option is out-of-the-money (OTM), the more likely it will end up worthless (and its bet is lost), the further an option is in-the-money (ITM), the more likely its bet will end up winning. With less time to expiration the less chances of it being changed.

Another way to put it is that option pricing of ITM options rises with time to maturity and approaches 1, and option pricing of OTM options falls with time to maturity and approaches 0 at the time of expiration.

At the moment, when the strike price of a new bet is always equal to the current underlying price, moneyness of new options (bets) is always 0.

It’s important to note that binary options expire worthless even when they’re at-the-money (ATM) at the time of expiration. That means, a bet becomes a winning bet, only if the current underlying price is above (>) the target price for call options, and below (<) the target price for put options. If the current underlying price at the time of expiration is equal (=) to the target price, the option expires worthless, and its bet ends up with a loss.

 

Implementation
Function

Files

Notes

Volatility prediction

volatility_predictor.cpython-312-x86_64-linux-gnu.so
volatility_predictor.cpython-313-darwin.so
…

The library file names must remain unchanged

Python versions, operating systems and computer architectures must match the library file names

Odds calculation

libodds_calculator_jni.so
libodds_calculator_jni.dylib
…

Operating systems and computer architectures must match the library file extensions

Volatility prediction
A compiled Python library

To be called only once a minute - Python performance is not an issue

Needs to be imported into a Python environment to be used

Java - JEP - Java Embedded Python

Execute Python code in Java

JNI - Java Native Interface - data exchange between the two environments

Shared interpreter - instance is reused, not recreated on each call

Before running the Java application a Python environment must be prepared

Installation of system-wide pip packages must be allowed

Required pip packages must be installed (requirements.txt)

PYTHONPATH must be pointing to the location of the installed pip packages

Example code:



import jep.Interpreter;
import jep.SharedInterpreter;
# Historical market data
List<DataOhlc> klines;
# Model parameters retieved from the database
List<Long> param00;
List<Long> param01;
List<Long> param02;
try (Interpreter interp = new SharedInterpreter()) {
  # import the library
  interp.exec("from volatility_predictor import preprocess, predict, postprocess");
  # Import parameters & data
  interp.set("param_00", param00);
  interp.set("param_01", param01);
  interp.set("param_02", param02);
  interp.set("klines", klines);
  # Prepare parameters & data
  interp.exec("param_00 = list(param_00)");
  interp.exec("param_01 = list(param_01)");
  interp.exec("param_02 = list(param_02)");
  interp.exec("klines = [[ohlc.timestamp, ohlc.open, ohlc.high, " + "ohlc.low, ohlc.close] for ohlc in klines]");
  # Preprocess data
  interp.exec("df_data = preprocess(klines)");
  # Forecast volatility
  interp.exec("df_forecast = predict(df_data, param_00, param_01, param_02)");
  # Postprocess to usable parameters
  interp.exec("fc_index, fc_mean, fc_var = postprocess(df_forecast)");
  # Retrieve forecasted values
  List fcIndex = interp.getValue("fc_index", List.class);
  List fcMean = interp.getValue("fc_mean", List.class);
  List fcVar = interp.getValue("fc_var", List.class);
}
Odds calculation
A fully native shared library

The library exposes a JNI (Java Native Interface) for a Java code to interact with

Java code is able to call the library’s functions and exchange data directly

Inputs and outputs have a predefined structure, their names and types must not change



static {
  System.loadLibrary("odds_calculator_jni");  // Loads libodds_calculator.dylib,
                                              // libodds_calculator.so or odds_calculator.dll
}
public static class StrikeProbability {
  public char type;          // 'C' or 'P'
  public double strike;
  public double probability;
}
public static class OutputExpiry {
  public int timeStamp;                          // Current timestamp
  public double impliedVolatility;               // IV used in calculation
  public List<StrikeProbability> probabilities;  // Results per strike
}
public static class InputExpiry {
  public int timeStamp;         // Expiry timestamp
  public int totalDuration;     // Total duration of an option contract in days
  public List<Double> strikes;  // Strike / target prices
}
public static class InputParameters {
  public double assetPrice;           // Current underlying asset price
  public int timeStamp;               // Current timestamp
  public List<InputExpiry> expiries;  // Option contracts to price
}
// Declare a native method
public native List<OutputExpiry> calcAllOdds(InputParameters inputParameters, List<List<Double>> volatilities);


// Volatilities - obtained from the forecast
List<List<Double>> volatilities = new ArrayList<List<Double>>();
for (VolatilityPrediction forecast : ivs) {
  volatilities.add(List.of((double)forecast.timeOffset,
                           forecast.logReturnsMean, forecast.logReturnsVar,
                           priceUnderlying));
}
calcAllOdds() can be called anywhere in Java code as if it’s any other Java method.

The library is able to calculate probabilities for multiple strikes of options with the same expiration at once. The function is fast and there should be no performance concerns. 