# 赔率计算模块调用 - 最终方案

## 1. 概述

### 1.1 目标
将现有固定赔率替换为基于 Black-Scholes 模型的动态赔率计算，根据市场波动率实时调整赔率。

### 1.2 环境区分

| 环境 | 赔率计算库 | 波动率预测 |
|------|-----------|-----------|
| **local** | `libodds_calculator_jni.dylib` | 固定值（不计算） |
| **dev/prod** | `libodds_calculator_jni.so` | `volatility_predictor_jni.so` (JEP) |

### 1.3 参考实现
基于 `boa-core` 项目的 Kotlin 实现：
- `com.btse.boa.core.jni.OddsCalculatorJNI`
- `com.btse.boa.core.jni.VolatilityPredictorJNI`

---

## 2. 赔率计算模块 (JNI)

### 2.1 JNI 接口定义

```java
package com.binaryoption.order.pricing.odds;

public class OddsCalculatorJNI {

    static {
        loadNativeLibrary();
    }

    /**
     * 计算所有到期时间的赔率
     * JNI 函数签名: Java_com_binaryoption_order_pricing_odds_OddsCalculatorJNI_calcAllOdds
     */
    public native List<OutputExpiry> calcAllOdds(
        InputParameters inputParameters,
        List<List<Double>> volatilities  // 修改: double[][] -> List<List<Double>>
    );

    // ========== 内部类 ==========

    public static class InputParameters {
        public double assetPrice;      // 当前标的资产价格
        public long timeStamp;         // 当前时间戳（秒）
        public List<InputExpiry> expiries;
    }

    public static class InputExpiry {
        public long timeStamp;         // 到期时间戳（秒）
        public int totalDuration;      // 固定值 1
        public List<Double> strikes;   // 行权价列表
    }

    public static class OutputExpiry {
        public long timeStamp;
        public double impliedVolatility;
        public List<StrikeProbability> probabilities;
    }

    public static class StrikeProbability {
        public char type;              // 'C' (Call/UP) 或 'P' (Put/DOWN)
        public double strike;
        public double probability;
    }
}
```

### 2.2 参数说明

#### 2.2.1 InputParameters

| 字段 | 类型 | 来源 | 说明 |
|------|------|------|------|
| assetPrice | double | Redis `pricer:index` | 当前标的资产价格 |
| timeStamp | long | `System.currentTimeMillis() / 1000` | 当前时间戳（秒） |
| expiries | List | 根据 duration 构建 | 到期时间列表 |

#### 2.2.2 InputExpiry

| 字段 | 类型 | 来源 | 说明 |
|------|------|------|------|
| timeStamp | long | `currentTime + duration * 60` | 到期时间戳（秒） |
| totalDuration | int | 固定值 `1` | 合约持续时间（天） |
| strikes | List | `[assetPrice]` | 行权价 = 当前价格 |

#### 2.2.3 volatilities (二维列表)

每行 4 个值：`[timeOffset, logReturnsMean, logReturnsVar, priceUnderlying]`

| 索引 | 字段 | 来源 |
|------|------|------|
| [0] | timeOffset | 波动率预测结果 |
| [1] | logReturnsMean | 波动率预测结果 |
| [2] | logReturnsVar | 波动率预测结果 |
| [3] | priceUnderlying | Redis `pricer:index` |

### 2.3 输出处理

```java
// 概率转赔率
double odds = 1.0 / probability;

// 赔率范围限制
BigDecimal MIN_ODDS = new BigDecimal("1.01");
BigDecimal MAX_ODDS = new BigDecimal("100.00");
```

### 2.4 库文件

| 文件 | 平台 | 位置 |
|------|------|------|
| `libodds_calculator_jni.dylib` | macOS | `resources/lib/` |
| `libodds_calculator_jni.so` | Linux | `resources/lib/` |

**JNI 函数签名**:
```
Java_com_binaryoption_order_pricing_odds_OddsCalculatorJNI_calcAllOdds
```

> ⚠️ **注意**: `odds_libs/prod/libodds_calculator_jni.so` 使用旧包名 `com.pricing.math`，需要重新编译或使用正确的库文件。

### 2.5 JNI 库加载与调用实现

#### 2.5.1 库文件加载

```java
package com.binaryoption.order.pricing.odds;

import lombok.extern.slf4j.Slf4j;
import java.io.File;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;

@Slf4j
public class OddsCalculatorJNI {

    private static boolean libraryLoaded = false;
    private static String loadError = null;

    static {
        loadNativeLibrary();
    }

    /**
     * 加载本地库
     * 优先从 java.library.path 加载，失败则从 resources/lib/ 提取到临时目录
     */
    private static void loadNativeLibrary() {
        try {
            // 方式1: 尝试从系统路径加载
            System.loadLibrary("odds_calculator_jni");
            libraryLoaded = true;
            log.info("Loaded odds_calculator_jni from system library path");
        } catch (UnsatisfiedLinkError e1) {
            log.debug("Failed to load from system path, trying resources: {}", e1.getMessage());
            try {
                // 方式2: 从 resources/lib/ 提取并加载
                loadFromResources();
                libraryLoaded = true;
            } catch (Exception e2) {
                loadError = e2.getMessage();
                log.error("Failed to load odds_calculator_jni library", e2);
            }
        }
    }

    /**
     * 从 resources/lib/ 提取库文件到临时目录并加载
     */
    private static void loadFromResources() throws Exception {
        String osName = System.getProperty("os.name").toLowerCase();
        String libName;

        if (osName.contains("mac")) {
            libName = "libodds_calculator_jni.dylib";
        } else if (osName.contains("linux")) {
            libName = "libodds_calculator_jni.so";
        } else {
            throw new UnsupportedOperationException("Unsupported OS: " + osName);
        }

        String resourcePath = "/lib/" + libName;
        try (InputStream is = OddsCalculatorJNI.class.getResourceAsStream(resourcePath)) {
            if (is == null) {
                throw new RuntimeException("Library not found in resources: " + resourcePath);
            }

            // 创建临时文件
            File tempFile = File.createTempFile("odds_calculator_jni_", getLibExtension(osName));
            tempFile.deleteOnExit();

            // 复制库文件
            Files.copy(is, tempFile.toPath(), StandardCopyOption.REPLACE_EXISTING);

            // 加载库
            System.load(tempFile.getAbsolutePath());
            log.info("Loaded odds_calculator_jni from resources: {}", tempFile.getAbsolutePath());
        }
    }

    private static String getLibExtension(String osName) {
        return osName.contains("mac") ? ".dylib" : ".so";
    }

    /**
     * 检查库是否成功加载
     */
    public static boolean isLibraryLoaded() {
        return libraryLoaded;
    }

    /**
     * 获取加载错误信息
     */
    public static String getLoadError() {
        return loadError;
    }

    // ========== Native 方法 ==========

    /**
     * 调用 JNI 计算所有到期时间的赔率
     */
    public native List<OutputExpiry> calcAllOdds(
        InputParameters inputParameters,
        List<List<Double>> volatilities
    );
}
```

#### 2.5.2 输入参数构建

```java
/**
 * 构建 JNI 调用的输入参数
 *
 * @param symbol 交易对
 * @param currentPrice 当前价格
 * @param durations 到期时间列表 (分钟): [1, 3, 5, 15]
 * @return InputParameters
 */
public InputParameters buildInputParameters(String symbol, double currentPrice, List<Integer> durations) {
    long currentTimeSec = System.currentTimeMillis() / 1000;

    InputParameters params = new InputParameters();
    params.assetPrice = currentPrice;
    params.timeStamp = currentTimeSec;
    params.expiries = new ArrayList<>();

    for (Integer duration : durations) {
        InputExpiry expiry = new InputExpiry();
        expiry.timeStamp = currentTimeSec + duration * 60L;  // 到期时间 = 当前时间 + duration分钟
        expiry.totalDuration = 1;                             // 固定值
        expiry.strikes = List.of(currentPrice);               // 行权价 = 当前价格
        params.expiries.add(expiry);
    }

    return params;
}
```

#### 2.5.3 输出结果处理

```java
/**
 * 处理 JNI 返回结果，转换为赔率
 *
 * @param outputs JNI 返回的概率列表
 * @return Map<duration, OddsResult> 每个到期时间的赔率
 */
public Map<Integer, OddsResult> processOutputs(List<OutputExpiry> outputs, List<Integer> durations) {
    Map<Integer, OddsResult> result = new HashMap<>();

    for (int i = 0; i < outputs.size() && i < durations.size(); i++) {
        OutputExpiry output = outputs.get(i);
        Integer duration = durations.get(i);

        double upProb = 0.5;   // 默认值
        double downProb = 0.5; // 默认值

        if (output.probabilities != null) {
            for (StrikeProbability prob : output.probabilities) {
                if (prob.type == 'C') {       // Call = UP
                    upProb = prob.probability;
                } else if (prob.type == 'P') { // Put = DOWN
                    downProb = prob.probability;
                }
            }
        }

        // 概率转赔率: odds = 1 / probability
        BigDecimal upOdds = calculateOdds(upProb);
        BigDecimal downOdds = calculateOdds(downProb);

        result.put(duration, new OddsResult(upOdds, downOdds));
    }

    return result;
}

/**
 * 概率转赔率，并限制在合理范围内
 */
private BigDecimal calculateOdds(double probability) {
    if (probability <= 0 || probability >= 1) {
        return DEFAULT_ODDS; // 1.90
    }

    BigDecimal odds = BigDecimal.ONE.divide(
        BigDecimal.valueOf(probability),
        4,
        RoundingMode.HALF_UP
    );

    // 限制赔率范围 [1.01, 100.00]
    if (odds.compareTo(MIN_ODDS) < 0) return MIN_ODDS;
    if (odds.compareTo(MAX_ODDS) > 0) return MAX_ODDS;

    return odds.setScale(2, RoundingMode.HALF_UP);
}

private static final BigDecimal MIN_ODDS = new BigDecimal("1.01");
private static final BigDecimal MAX_ODDS = new BigDecimal("100.00");
private static final BigDecimal DEFAULT_ODDS = new BigDecimal("1.90");
```

#### 2.5.4 完整调用示例

```java
@Service
@RequiredArgsConstructor
public class OddsCalculatorService {

    private final OddsCalculatorJNI calculator = new OddsCalculatorJNI();
    private final VolatilityPredictionService volatilityService;
    private final MarketCacheService marketCacheService;

    /**
     * 计算指定交易对的赔率
     */
    public Map<Integer, OddsResult> calculateOdds(String symbol, List<Integer> durations) {
        // 1. 检查 JNI 库是否加载成功
        if (!OddsCalculatorJNI.isLibraryLoaded()) {
            log.warn("JNI library not loaded, returning default odds");
            return getDefaultOdds(durations);
        }

        try {
            // 2. 获取当前价格
            BigDecimal currentPrice = marketCacheService.getIndexPrice(symbol);
            if (currentPrice == null) {
                log.warn("No price available for symbol: {}", symbol);
                return getDefaultOdds(durations);
            }

            // 3. 获取波动率数据
            List<List<Double>> volatilities = volatilityService
                .getVolatilitiesForOdds(symbol, currentPrice.doubleValue());

            // 4. 构建输入参数
            InputParameters params = buildInputParameters(
                symbol,
                currentPrice.doubleValue(),
                durations
            );

            // 5. 调用 JNI 计算
            List<OutputExpiry> outputs = calculator.calcAllOdds(params, volatilities);

            // 6. 处理输出
            return processOutputs(outputs, durations);

        } catch (Exception e) {
            log.error("Failed to calculate odds for symbol: {}", symbol, e);
            return getDefaultOdds(durations);
        }
    }
}
```

---

## 3. 波动率预测模块 (JEP)

### 3.1 调用方式

波动率预测使用 **JEP (Java Embedded Python)** 调用 Python 扩展模块，不是纯 JNI。

```java
// 参考 boa-core 实现
SharedInterpreter().use { interp ->
    interp.exec("from volatility_predictor import preprocess, predict, postprocess");

    interp.set("lags_harx", lagsHarx);
    interp.set("lags_vol", lagsVol);
    interp.set("weights", weights);
    interp.set("klines", klinesData);

    interp.exec("df_data = preprocess(klines)");
    interp.exec("df_forecast = predict(df_data, lags_harx, lags_vol, weights)");
    interp.exec("fc_index, fc_mean, fc_var = postprocess(df_forecast)");

    // 获取结果
    val fcIndex = interp.getValue("fc_index") as List<Long>
    val fcMean = interp.getValue("fc_mean") as List<Double>
    val fcVar = interp.getValue("fc_var") as List<Double>
}
```

### 3.2 输入参数

| 参数 | 类型 | 来源 | 状态 |
|------|------|------|------|
| klines | List<[ts, close]> | BTSE API `/api/ohlcv` | ✅ 可获取 |
| lagsHarx | List<Long> | `binary_option_pricing_models` 表，name=`{symbol} harx_lags` | ✅ 已有 |
| lagsVol | List<Long> | `binary_option_pricing_models` 表，name=`{symbol} harch_lags` | ✅ 已有 |
| weights | List<Double> | `binary_option_pricing_models` 表，name=`{symbol} weights` | ✅ 已有 |

### 3.3 输出结构

```java
public class VolatilityPrediction {
    long timeOffset;       // 时间偏移量（秒）: 300, 600, 900, 1200
    double logReturnsMean; // 对数收益率均值
    double logReturnsVar;  // 对数收益率方差
}
```

### 3.4 库文件

| 文件 | 类型 | 说明 |
|------|------|------|
| `volatility_predictor_jni.so` | Python 扩展 | 需要通过 JEP 加载 |

### 3.5 环境依赖 (dev/prod)

| 依赖 | 说明 |
|------|------|
| Python 3.12+ | 系统 Python 环境 |
| JEP | Maven 依赖 `black.ninia:jep:4.2.0` |
| PYTHONPATH | 指向 `volatility_predictor_jni.so` 所在目录 |

### 3.6 JEP 调用实现

#### 3.6.1 JEP 环境初始化

```java
package com.binaryoption.order.pricing.volatility;

import jep.Interpreter;
import jep.JepConfig;
import jep.JepException;
import jep.SharedInterpreter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.File;
import java.util.List;

@Slf4j
@Component
@ConditionalOnProperty(name = "volatility.prediction.jep-enabled", havingValue = "true")
public class VolatilityPredictorJEP {

    @Value("${volatility.prediction.python-path:}")
    private String pythonPath;

    @Value("${volatility.prediction.lib-path:}")
    private String libPath;

    private boolean jepAvailable = false;
    private String jepError = null;

    @PostConstruct
    public void init() {
        try {
            // 1. 配置 Python 环境
            configurePythonEnvironment();

            // 2. 测试 JEP 可用性
            testJepAvailability();

            jepAvailable = true;
            log.info("VolatilityPredictorJEP initialized successfully");
        } catch (Exception e) {
            jepError = e.getMessage();
            log.error("Failed to initialize VolatilityPredictorJEP: {}", e.getMessage());
        }
    }

    /**
     * 配置 Python 环境变量
     */
    private void configurePythonEnvironment() {
        // 设置 PYTHONPATH 以包含 volatility_predictor_jni.so 所在目录
        if (libPath != null && !libPath.isEmpty()) {
            String currentPath = System.getenv("PYTHONPATH");
            String newPath = currentPath != null ? libPath + File.pathSeparator + currentPath : libPath;
            // Note: 实际需要在启动脚本中设置，Java 无法修改进程环境变量
            log.info("PYTHONPATH should include: {}", libPath);
        }
    }

    /**
     * 测试 JEP 是否可用
     */
    private void testJepAvailability() throws JepException {
        try (Interpreter interp = new SharedInterpreter()) {
            interp.exec("import sys");
            String version = (String) interp.getValue("sys.version");
            log.info("JEP available, Python version: {}", version.split("\n")[0]);

            // 测试导入 volatility_predictor
            interp.exec("from volatility_predictor import preprocess, predict, postprocess");
            log.info("volatility_predictor module loaded successfully");
        }
    }

    public boolean isJepAvailable() {
        return jepAvailable;
    }

    public String getJepError() {
        return jepError;
    }
}
```

#### 3.6.2 波动率预测调用

```java
/**
 * 执行波动率预测
 *
 * @param klines   K线数据 [[timestamp_ms, close_price], ...]
 * @param lagsHarx HARX 模型滞后参数
 * @param lagsVol  波动率滞后参数 (harch_lags)
 * @param weights  模型权重
 * @return 预测结果列表
 */
@SuppressWarnings("unchecked")
public List<VolatilityPrediction> getPredictions(
        List<List<Object>> klines,
        List<Long> lagsHarx,
        List<Long> lagsVol,
        List<Double> weights) {

    if (!jepAvailable) {
        log.warn("JEP not available, returning empty predictions");
        return Collections.emptyList();
    }

    if (klines.isEmpty() || lagsHarx.isEmpty() || lagsVol.isEmpty() || weights.isEmpty()) {
        log.warn("Invalid input parameters for volatility prediction");
        return Collections.emptyList();
    }

    try (Interpreter interp = new SharedInterpreter()) {
        // 1. 导入模块
        interp.exec("from volatility_predictor import preprocess, predict, postprocess");

        // 2. 设置输入参数
        interp.set("lags_harx", lagsHarx);
        interp.set("lags_vol", lagsVol);
        interp.set("weights", weights);
        interp.set("klines", klines);

        // 3. 执行预测流程
        interp.exec("df_data = preprocess(klines)");
        interp.exec("df_forecast = predict(df_data, lags_harx, lags_vol, weights)");
        interp.exec("fc_index, fc_mean, fc_var = postprocess(df_forecast)");

        // 4. 获取结果
        List<Long> fcIndex = (List<Long>) interp.getValue("fc_index");
        List<Double> fcMean = (List<Double>) interp.getValue("fc_mean");
        List<Double> fcVar = (List<Double>) interp.getValue("fc_var");

        // 5. 转换为 Java 对象
        List<VolatilityPrediction> predictions = new ArrayList<>();
        for (int i = 0; i < fcIndex.size(); i++) {
            predictions.add(new VolatilityPrediction(
                fcIndex.get(i),
                fcMean.get(i),
                fcVar.get(i)
            ));
        }

        log.debug("Volatility prediction completed, count: {}", predictions.size());
        return predictions;

    } catch (JepException e) {
        log.error("JEP prediction failed: {}", e.getMessage());
        return Collections.emptyList();
    }
}

/**
 * 预测结果结构
 */
@Data
@AllArgsConstructor
public static class VolatilityPrediction {
    private long timeOffset;       // 时间偏移（秒）
    private double logReturnsMean; // 对数收益率均值
    private double logReturnsVar;  // 对数收益率方差
}
```

#### 3.6.3 输入数据准备

```java
@Service
@RequiredArgsConstructor
public class VolatilityPredictionService {

    private final VolatilityPredictorJEP volatilityPredictor;
    private final HistoryIndexPriceMinuteMapper historyPriceMapper;
    private final PricingModelService pricingModelService;
    private final StringRedisTemplate redisTemplate;

    /**
     * 执行波动率预测并缓存结果
     *
     * @param symbol 交易对
     * @return 预测结果列表
     */
    public List<VolatilityPrediction> predictAndCache(String symbol) {
        // 1. 获取 K线数据 (最近 12 分钟)
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime startTime = now.minusMinutes(12);
        List<HistoryIndexPriceMinute> historyPrices =
            historyPriceMapper.findBySymbolAndTimeRange(symbol, startTime, now);

        if (historyPrices.size() < 10) {
            log.warn("Not enough K-line data for symbol: {}, count: {}", symbol, historyPrices.size());
            return Collections.emptyList();
        }

        // 2. 转换为 JEP 输入格式: [[timestamp_ms, close_price], ...]
        List<List<Object>> klines = historyPrices.stream()
            .map(p -> List.<Object>of(
                p.getMinuteTime().atZone(ZoneId.systemDefault()).toInstant().toEpochMilli(),
                p.getPrice().doubleValue()
            ))
            .collect(Collectors.toList());

        // 3. 获取模型参数
        PricingModelParams params = pricingModelService.getModelParams(symbol);
        if (params == null) {
            log.warn("No pricing model params for symbol: {}", symbol);
            return Collections.emptyList();
        }

        // 4. 调用 JEP 预测
        List<VolatilityPrediction> predictions = volatilityPredictor.getPredictions(
            klines,
            params.getHarxLags(),
            params.getHarchLags(),
            params.getWeights()
        );

        // 5. 缓存到 Redis (TTL: 2 分钟)
        if (!predictions.isEmpty()) {
            cacheToRedis(symbol, predictions);
        }

        return predictions;
    }

    /**
     * 缓存预测结果到 Redis
     */
    private void cacheToRedis(String symbol, List<VolatilityPrediction> predictions) {
        String key = CacheConstants.buildVolatilityKey(symbol);
        String json = objectMapper.writeValueAsString(predictions);
        redisTemplate.opsForValue().set(key, json, Duration.ofSeconds(120));
    }

    /**
     * 获取波动率数据 (供赔率计算使用)
     *
     * @param symbol       交易对
     * @param currentPrice 当前价格
     * @return 波动率二维列表 [[timeOffset, logReturnsMean, logReturnsVar, priceUnderlying], ...]
     */
    public List<List<Double>> getVolatilitiesForOdds(String symbol, double currentPrice) {
        // 1. 尝试从 Redis 获取缓存
        String key = CacheConstants.buildVolatilityKey(symbol);
        String json = redisTemplate.opsForValue().get(key);

        List<VolatilityPrediction> predictions;
        if (json != null) {
            predictions = objectMapper.readValue(json, new TypeReference<>() {});
        } else {
            // 2. 缓存不存在，使用默认值
            log.debug("No cached volatility for symbol: {}, using defaults", symbol);
            return getDefaultVolatilities(currentPrice);
        }

        // 3. 转换为赔率计算所需格式
        return predictions.stream()
            .map(p -> List.of(
                (double) p.getTimeOffset(),
                p.getLogReturnsMean(),
                p.getLogReturnsVar(),
                currentPrice
            ))
            .collect(Collectors.toList());
    }

    /**
     * 默认波动率值 (local 环境或缓存失效时使用)
     */
    private List<List<Double>> getDefaultVolatilities(double currentPrice) {
        return List.of(
            List.of(60.0,   0.000010, 0.000050, currentPrice),  // 1min
            List.of(180.0,  0.000015, 0.000080, currentPrice),  // 3min
            List.of(300.0,  0.000020, 0.000120, currentPrice),  // 5min
            List.of(900.0,  0.000030, 0.000200, currentPrice)   // 15min
        );
    }
}
```

#### 3.6.4 模型参数服务

```java
@Service
@RequiredArgsConstructor
public class PricingModelService {

    private final PricingModelMapper pricingModelMapper;

    /**
     * 获取交易对的模型参数
     */
    public PricingModelParams getModelParams(String symbol) {
        // 从 binary_option_pricing_models 表读取
        String harxLagsStr = pricingModelMapper.getValue(symbol + " harx_lags");
        String harchLagsStr = pricingModelMapper.getValue(symbol + " harch_lags");
        String weightsStr = pricingModelMapper.getValue(symbol + " weights");

        if (harxLagsStr == null || harchLagsStr == null || weightsStr == null) {
            return null;
        }

        return new PricingModelParams(
            parseLongs(harxLagsStr),
            parseLongs(harchLagsStr),
            parseDoubles(weightsStr)
        );
    }

    private List<Long> parseLongs(String value) {
        return Arrays.stream(value.split(","))
            .map(String::trim)
            .map(Long::parseLong)
            .collect(Collectors.toList());
    }

    private List<Double> parseDoubles(String value) {
        return Arrays.stream(value.split(","))
            .map(String::trim)
            .map(Double::parseDouble)
            .collect(Collectors.toList());
    }

    @Data
    @AllArgsConstructor
    public static class PricingModelParams {
        private List<Long> harxLags;
        private List<Long> harchLags;
        private List<Double> weights;
    }
}
```

#### 3.6.5 定时任务 (每分钟执行)

```java
@Slf4j
@Component
@RequiredArgsConstructor
@ConditionalOnProperty(name = "volatility.prediction.enabled", havingValue = "true")
public class VolatilityPredictionTask {

    private final VolatilityPredictionService volatilityPredictionService;
    private final PricingSettingsService pricingSettingsService;

    /**
     * 每分钟第 0 秒执行波动率预测
     */
    @Scheduled(cron = "0 * * * * ?")
    public void executeVolatilityPrediction() {
        log.debug("Starting volatility prediction task");
        long startTime = System.currentTimeMillis();

        try {
            // 获取配置的交易对列表
            List<String> symbols = pricingSettingsService.getSymbols();

            int successCount = 0;
            int failCount = 0;

            for (String symbol : symbols) {
                try {
                    List<VolatilityPrediction> predictions =
                        volatilityPredictionService.predictAndCache(symbol);

                    if (!predictions.isEmpty()) {
                        successCount++;
                    } else {
                        failCount++;
                    }
                } catch (Exception e) {
                    log.error("Failed to predict volatility for symbol: {}", symbol, e);
                    failCount++;
                }
            }

            long elapsed = System.currentTimeMillis() - startTime;
            log.info("Volatility prediction completed: symbols={}, success={}, failed={}, elapsed={}ms",
                symbols.size(), successCount, failCount, elapsed);

        } catch (Exception e) {
            log.error("Volatility prediction task failed", e);
        }
    }
}
```

### 3.7 JEP 环境配置

#### 3.7.1 Maven 依赖

```xml
<dependency>
    <groupId>black.ninia</groupId>
    <artifactId>jep</artifactId>
    <version>4.2.0</version>
</dependency>
```

#### 3.7.2 启动脚本配置

```bash
#!/bin/bash

# Python 环境配置
export PYTHONPATH="/opt/app/lib:$PYTHONPATH"

# JEP 库路径 (Python 安装目录下的 jep 模块)
export LD_LIBRARY_PATH="/usr/local/lib/python3.12/site-packages/jep:$LD_LIBRARY_PATH"

# 启动应用
java -jar binary-option-app.jar
```

#### 3.7.3 应用配置

```yaml
# application.yml
volatility:
  prediction:
    enabled: ${VOLATILITY_PREDICTION_ENABLED:false}
    jep-enabled: ${VOLATILITY_JEP_ENABLED:false}
    python-path: ${VOLATILITY_PYTHON_PATH:}
    lib-path: ${VOLATILITY_LIB_PATH:/opt/app/lib}
```

---

## 4. 数据库表结构

### 4.1 binary_option_pricing_models

存储波动率预测模型参数。

```sql
CREATE TABLE binary_option_pricing_models (
    name  VARCHAR(100) PRIMARY KEY,
    value TEXT
);
```

**数据示例**:

| name | value | 说明 |
|------|-------|------|
| `BTC-USDT harx_lags` | `1, 4, 6, 12, 288, 576` | HARX 模型滞后参数 |
| `BTC-USDT harch_lags` | `1, 2, 3, 6, 12, 288, 576` | HARCH 模型滞后参数 |
| `BTC-USDT weights` | `-0.0242268722, -0.0473008241, ...` | 模型权重 (多个值) |

**参数映射**:

| 数据库 name | Java 参数 | 解析方式 |
|------------|----------|---------|
| `{symbol} harx_lags` | `lagsHarx` | 逗号分隔 → `List<Long>` |
| `{symbol} harch_lags` | `lagsVol` | 逗号分隔 → `List<Long>` |
| `{symbol} weights` | `weights` | 逗号分隔 → `List<Double>` |

### 4.2 binary_option_pricing_settings

存储定价系统配置。

```sql
CREATE TABLE binary_option_pricing_settings (
    name  VARCHAR(100) PRIMARY KEY,
    value VARCHAR(1024)
);
```

**数据示例**:

| name | value | 说明 |
|------|-------|------|
| `symbols` | `BTC-USDT` | 支持的交易对 |
| `history_underlying` | `720000` | 历史标的数据量 (ms) |
| `history_volatility` | `720000` | 历史波动率数据量 (ms) |
| `fixture_expiration` | `60` | 到期时间 (秒) |
| `fixture_interval` | `1` | 时间间隔 (秒) |

### 4.3 K线数据来源

**数据源**: `bo_history_index_price_minute` (分钟级历史价格表)

**数据库**: `binary_option` (与 `binary_option_pricing_*` 表同库)

```sql
-- 表结构
CREATE TABLE bo_history_index_price_minute (
    id          BIGSERIAL PRIMARY KEY,
    symbol      VARCHAR(32) NOT NULL,
    price       NUMERIC(32, 16) NOT NULL,
    minute_time TIMESTAMP NOT NULL,
    created_at  TIMESTAMP NOT NULL DEFAULT NOW()
);

-- 索引
CREATE UNIQUE INDEX idx_history_price_minute_unique ON bo_history_index_price_minute (symbol, minute_time);
CREATE INDEX idx_history_price_minute_symbol_time ON bo_history_index_price_minute (symbol, minute_time DESC);
CREATE INDEX idx_history_price_minute_time ON bo_history_index_price_minute (minute_time);
```

**查询示例**:
```sql
-- 获取最近12分钟的K线数据
SELECT minute_time as ts, price as close
FROM bo_history_index_price_minute
WHERE symbol = 'BTC-USDT'
  AND minute_time >= NOW() - INTERVAL '12 minutes'
ORDER BY minute_time ASC;
```

**参数说明**:

| 参数 | 值 | 来源 |
|------|-----|------|
| 数据量 | 12 条 | `history_underlying` = 720000ms = 12分钟 |
| 间隔 | 1 分钟 | 分钟级数据 |
| 字段 | minute_time, price | 时间戳 + 收盘价 |

**选择分钟级数据的理由**:
1. 波动率预测每分钟执行一次，分钟级数据刚好匹配
2. 数据量小（12条 vs 秒级720条），查询效率高
3. 波动率计算关注价格趋势，不需要秒级精度
4. 与 boa-core 的 klines 格式一致

### 4.4 模型参数解析示例

```java
// 从数据库读取并解析
public List<Long> parseLags(String value) {
    return Arrays.stream(value.split(","))
        .map(String::trim)
        .map(Long::parseLong)
        .collect(Collectors.toList());
}

public List<Double> parseWeights(String value) {
    return Arrays.stream(value.split(","))
        .map(String::trim)
        .map(Double::parseDouble)
        .collect(Collectors.toList());
}

// BTC-USDT 示例
// harx_lags: [1, 4, 6, 12, 288, 576]
// harch_lags: [1, 2, 3, 6, 12, 288, 576]
// weights: [-0.0242268722, -0.0473008241, -0.0945581444, ...]
```

---

## 5. 配置项

```yaml
# application.yml

# 赔率计算配置
odds:
  dynamic-calculation:
    enabled: ${ODDS_DYNAMIC_ENABLED:true}     # 是否启用动态赔率计算
  default-odds: 1.90                          # 兜底赔率
  calculator:
    min-odds: 1.01                            # 赔率下限
    max-odds: 100.00                          # 赔率上限

# 波动率预测配置
volatility:
  prediction:
    enabled: ${VOLATILITY_PREDICTION_ENABLED:false}  # 是否启用波动率预测
    jep-enabled: ${VOLATILITY_JEP_ENABLED:false}     # 是否加载 JEP
  cache:
    ttl-seconds: 120                          # 缓存 TTL
  default:
    use-fixed: true                           # 使用固定波动率值
```

### 5.1 环境配置

| 环境 | ODDS_DYNAMIC_ENABLED | VOLATILITY_PREDICTION_ENABLED | VOLATILITY_JEP_ENABLED |
|------|---------------------|------------------------------|------------------------|
| local | true | false | false |
| dev | true | true | true |
| prod | true | true | true |

---

## 6. 代码修改清单

### 6.0 文件结构 (树形)

```
binary-option-app/src/main/java/com/binaryoption/order/pricing/
├── odds/
│   ├── OddsCalculatorJNI.java        [修改] volatilities类型、StrikeProbability.type
│   ├── OddsCalculatorService.java    [修改] 适配新参数类型
│   └── OddsService.java              [修改] 调整调用方式
├── task/
│   ├── OddsRefreshTask.java          [保留] 赔率刷新定时任务
│   └── VolatilityPredictionTask.java [修改] 整合模型参数获取
└── volatility/
    ├── VolatilityPredictionService.java [修改] 返回List<List<Double>>格式
    └── VolatilityPredictorJEP.java       [修改] 按照boa-core实现调整

binary-option-app/src/main/java/com/binaryoption/order/pricing/
├── model/                            [新增目录]
│   ├── PricingModelParams.java       [新增] 模型参数数据类
│   └── VolatilityPrediction.java     [新增] 波动率预测结果类
└── service/                          [新增目录]
    └── PricingModelService.java      [新增] 模型参数服务

binary-option-app/src/main/java/com/binaryoption/order/mapper/
├── HistoryIndexPriceMinuteMapper.java [现有] K线数据 Mapper
├── PricingModelMapper.java           [新增] 定价模型参数 Mapper
└── PricingSettingsMapper.java        [新增] 定价设置 Mapper

binary-option-app/src/main/resources/mapper/
├── HistoryIndexPriceMinuteMapper.xml [现有] K线数据 SQL (需确认是否需要修改)
├── PricingModelMapper.xml            [新增] 定价模型参数 SQL
└── PricingSettingsMapper.xml         [新增] 定价设置 SQL

binary-option-app/src/main/resources/lib/
├── libodds_calculator_jni.dylib      [现有] macOS 赔率计算库
├── libodds_calculator_jni.so         [需替换] Linux 赔率计算库 (包名修正)
└── volatility_predictor_jni.so       [现有] Python 波动率预测扩展
```

### 6.1 需要修改的文件

| 文件 | 修改内容 | 优先级 |
|------|---------|--------|
| `OddsCalculatorJNI.java` | 1. volatilities 参数类型改为 `List<List<Double>>`<br>2. StrikeProbability.type 改为 `char` | P0 |
| `OddsCalculatorService.java` | 适配新的参数类型 | P0 |
| `VolatilityPredictionService.java` | 返回 `List<List<Double>>` 格式 | P0 |
| `OddsService.java` | 调整调用方式 | P0 |
| `VolatilityPredictorJEP.java` | 按照 boa-core 实现调整 | P1 |
| `application.yml` | 添加环境配置 | P1 |

### 6.2 新增文件

| 文件 | 位置 | 说明 | 优先级 |
|------|------|------|--------|
| `PricingModelMapper.java` | `order/mapper/` | 定价模型参数 Mapper | P1 |
| `PricingModelMapper.xml` | `resources/mapper/` | 定价模型参数 SQL | P1 |
| `PricingSettingsMapper.java` | `order/mapper/` | 定价设置 Mapper | P1 |
| `PricingSettingsMapper.xml` | `resources/mapper/` | 定价设置 SQL | P1 |
| `PricingModelService.java` | `order/pricing/service/` | 模型参数服务 (解析 harx_lags, harch_lags, weights) | P1 |
| `PricingModelParams.java` | `order/pricing/model/` | 模型参数数据类 | P1 |
| `VolatilityPrediction.java` | `order/pricing/model/` | 波动率预测结果类 | P1 |

### 6.2.1 现有文件 (无需新增)

| 文件 | 位置 | 说明 |
|------|------|------|
| `HistoryIndexPriceMinuteMapper.java` | `order/mapper/` | K线数据 Mapper (已存在) |
| `HistoryIndexPriceMinuteMapper.xml` | `resources/mapper/` | K线数据 SQL (已存在，需确认查询方法) |

### 6.3 修改详情

#### 6.3.1 OddsCalculatorJNI.java

```java
// 修改前
public native List<OutputExpiry> calcAllOdds(InputParameters params, double[][] volatilities);

// 修改后
public native List<OutputExpiry> calcAllOdds(InputParameters params, List<List<Double>> volatilities);
```

```java
// 修改前
public static class StrikeProbability {
    public String type;  // "C" or "P"
    ...
}

// 修改后
public static class StrikeProbability {
    public char type;    // 'C' or 'P'
    ...
}
```

#### 6.3.2 VolatilityPredictionService.java

```java
// 修改前
public double[][] getVolatilitiesForOdds(String symbol, double currentPrice)

// 修改后
public List<List<Double>> getVolatilitiesForOdds(String symbol, double currentPrice) {
    List<VolatilityPrediction> predictions = getCachedVolatility(symbol);

    if (predictions.isEmpty()) {
        return getDefaultVolatilities(currentPrice);
    }

    List<List<Double>> volatilities = new ArrayList<>();
    for (VolatilityPrediction pred : predictions) {
        volatilities.add(List.of(
            (double) pred.getTimeOffset(),
            pred.getLogReturnsMean(),
            pred.getLogReturnsVar(),
            currentPrice
        ));
    }
    return volatilities;
}

// 固定波动率值 (local 环境使用)
private List<List<Double>> getDefaultVolatilities(double currentPrice) {
    return List.of(
        List.of(300.0,  0.000012, 0.000085, currentPrice),  // 5min
        List.of(600.0,  0.000018, 0.000120, currentPrice),  // 10min
        List.of(900.0,  0.000024, 0.000165, currentPrice),  // 15min
        List.of(1200.0, 0.000030, 0.000210, currentPrice)   // 20min
    );
}
```

---

## 7. 流程图

### 7.1 local 环境

```
┌──────────────────────────────────────────────────────────────┐
│                      local 环境流程                           │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐   │
│  │ 获取当前价格  │───▶│ 固定波动率值  │───▶│ JNI 赔率计算  │   │
│  │  (Redis)     │    │  (硬编码)     │    │  (.dylib)    │   │
│  └──────────────┘    └──────────────┘    └──────────────┘   │
│                                                              │
│  volatility.prediction.enabled = false                       │
│  volatility.prediction.jep-enabled = false                   │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

### 7.2 dev/prod 环境

```
┌──────────────────────────────────────────────────────────────┐
│                    dev/prod 环境流程                          │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│  【定时任务 - 每分钟】                                         │
│  ┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐  │
│  │ 获取K线   │──▶│ 获取参数  │──▶│ JEP预测   │──▶│ 缓存Redis │  │
│  │ (BTSE)   │   │ (数据库)  │   │ (Python) │   │ (2min)   │  │
│  └──────────┘   └──────────┘   └──────────┘   └──────────┘  │
│                                                              │
│  【实时调用】                                                  │
│  ┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐  │
│  │ 获取价格  │──▶│ 获取波动率 │──▶│ JNI计算   │──▶│ 返回赔率  │  │
│  │ (Redis)  │   │ (Redis)  │   │ (.so)    │   │          │  │
│  └──────────┘   └──────────┘   └──────────┘   └──────────┘  │
│                                                              │
│  volatility.prediction.enabled = true                        │
│  volatility.prediction.jep-enabled = true                    │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

---

## 8. 降级策略

| 场景 | 降级方案 |
|------|---------|
| JNI 库加载失败 | 返回默认赔率 `1.90` |
| 波动率预测失败 | 使用固定波动率值 |
| 波动率缓存过期 | 使用固定波动率值 |
| 当前价格获取失败 | 返回默认赔率 `1.90` |
| 计算结果异常 | 返回默认赔率并告警 |

---

## 9. 待解决问题

| 问题 | 状态 | 说明 |
|------|------|------|
| `libodds_calculator_jni.so` 包名不匹配 | ⚠️ 待解决 | prod 库使用旧包名 `com.pricing.math`，需重新编译 |
| JEP 环境部署 | ⚠️ 待确认 | dev/prod 环境 Python 配置 |

> ✅ **已确认**: 所有相关表 (`binary_option_pricing_*`, `bo_history_index_price_minute`) 都在同一数据库 `binary_option`，无需多数据源配置。

---

## 10. 更新日志

| 日期 | 更新内容 |
|------|---------|
| 2025-12-31 | 初始版本，基于 boa-core 参考实现 |
| 2025-12-31 | 补充数据库表结构 `binary_option_pricing_models` 和 `binary_option_pricing_settings` |
| 2025-12-31 | 确定 K线数据源为 `bo_history_index_price_minute` (分钟级历史价格表) |
| 2025-12-31 | 确认所有表在同一数据库 `binary_option`，更新表结构定义 |
| 2025-12-31 | 补充 JNI 库加载与调用实现 (2.5节)，JEP 波动率预测实现 (3.6-3.7节) |
| 2025-12-31 | 添加文件结构树形图 (6.0节)，Mapper 放置于 `order/mapper/`，`HistoryIndexPriceMinuteMapper` 已存在 |
