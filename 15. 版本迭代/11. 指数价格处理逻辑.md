# 指数价格处理逻辑

## 1. 概述

本方案重新设计指数价格的获取和处理逻辑，将价格数据持久化到数据库，并基于历史数据计算24小时统计信息。

### 1.1 核心变更

| 项目 | 原方案 | 新方案 |
|------|--------|--------|
| 指数价格获取 | market-service 订阅 BTSE WebSocket | order-service 定时任务从 Redis 读取 |
| 价格存储 | 仅 Redis (pricer:index) | Redis + 数据库 (bo_history_index_price) |
| 24h统计 | 订阅 BTSE changeIn24HrBySymbol | order-service 计算后写入 Redis |
| 历史价格缓存 | 无 | Redis ZSet (简化格式: timestamp + price) |
| market-service | 订阅 WebSocket | 从 Redis 读取价格和统计数据 |

### 1.2 数据流向

```
外部报价系统 → Redis (pricer:index) → order-service IndexPriceCollectorTask
                                              ↓
                             +----------------+----------------+----------------+
                             ↓                ↓                                ↓
                    bo_history_index_price   Redis ZSet              (每分钟第59秒)
                         (秒级数据)      (BO:History:Price:*)                 ↓
                                        (供/market/history接口)    +----------+----------+
                                                                   ↓                    ↓
                                                        bo_history_index_price_minute  计算24h统计
                                                             (分钟级数据)                ↓
                                                                              Redis (BO:Market:Stats24h)
                                                                                        ↓
                        market-service MarketWebSocketHandler ← 推送前即时刷新Redis数据
                                              ↓
                                         推送给前端
```

## 2. 数据库设计

### 2.1 秒级价格表: bo_history_index_price

用于存储每秒采集的原始价格数据，支持精确的历史价格查询。

```sql
CREATE TABLE bo_history_index_price (
    id BIGSERIAL PRIMARY KEY,
    symbol VARCHAR(32) NOT NULL,                    -- 交易对 (如 BTC-USDT)
    price DECIMAL(32, 16) NOT NULL,                 -- 指数价格
    second_time TIMESTAMP NOT NULL,                 -- 整数秒时间 (精确到秒，毫秒为0)
    created_at TIMESTAMP NOT NULL DEFAULT NOW()     -- 实际创建时间
);

-- 索引优化
CREATE INDEX idx_history_index_price_symbol_time ON bo_history_index_price(symbol, second_time DESC);
CREATE INDEX idx_history_index_price_time ON bo_history_index_price(second_time);
-- 唯一约束：每个交易对每秒只有一条记录
CREATE UNIQUE INDEX idx_history_index_price_unique ON bo_history_index_price(symbol, second_time);
```

**说明**:
- `second_time`: 整数秒时间，如 `2024-12-11 10:30:05.000`，便于连续查询
- `created_at`: 实际入库时间，用于监控和调试

### 2.2 分钟级价格表: bo_history_index_price_minute

用于存储每分钟的价格快照，供计算24小时涨跌幅使用。

```sql
CREATE TABLE bo_history_index_price_minute (
    id BIGSERIAL PRIMARY KEY,
    symbol VARCHAR(32) NOT NULL,                    -- 交易对 (如 BTC-USDT)
    price DECIMAL(32, 16) NOT NULL,                 -- 该分钟最后一条价格
    minute_time TIMESTAMP NOT NULL,                 -- 分钟时间 (精确到分钟，秒为0)
    created_at TIMESTAMP NOT NULL DEFAULT NOW()     -- 创建时间
);

-- 索引优化
CREATE INDEX idx_history_price_minute_symbol_time ON bo_history_index_price_minute(symbol, minute_time DESC);
CREATE INDEX idx_history_price_minute_time ON bo_history_index_price_minute(minute_time);
-- 唯一约束：每个交易对每分钟只有一条记录
CREATE UNIQUE INDEX idx_history_price_minute_unique ON bo_history_index_price_minute(symbol, minute_time);
```

### 2.3 数据保留策略

| 表 | 保留周期 | 清理时间 | 预估数据量 |
|---|---------|---------|-----------|
| bo_history_index_price | 3天 | 每天凌晨2点 | ~260万条/3天 (10交易对 × 86400秒 × 3天) |
| bo_history_index_price_minute | 7天 | 每天凌晨2点 | ~10万条/7天 (10交易对 × 1440分钟 × 7天) |

## 3. order-service 价格采集任务

### 3.1 价格采集任务（秒级 + 分钟级合并）

**任务名称**: IndexPriceCollectorTask

**执行方式**: 单线程循环 + 精确对齐整数秒 + 分布式锁

**设计特点**:
- 精确对齐到整数秒时刻采集，数据时间连续
- 使用 `DistributedLock` 组件实现分布式锁，支持多实例部署
- 秒级和分钟级采集合并，减少代码复杂度
- Redis ZSet 使用简化的数据格式 (仅 timestamp + price)

**CacheConstants 常量定义**:
```java
// CacheConstants.java
public static final String LOCK_INDEX_PRICE_COLLECTOR = "BO:Lock:IndexPriceCollector";
public static final String MARKET_STATS_24H_KEY = "BO:Market:Stats24h";  // Hash: symbol -> Stats24hDTO

// Redis ZSet 历史价格缓存 (供 /market/history 接口使用)
public static final String HISTORY_PRICE_KEY_PREFIX = "BO:History:Price:";  // ZSet: score=timestamp(ms), value=JSON
public static final int HISTORY_PRICE_RETENTION_SECONDS = 300;  // 保留5分钟

public static String buildHistoryPriceKey(String symbol) {
    return HISTORY_PRICE_KEY_PREFIX + symbol;
}
```

**核心逻辑**:

```java
@Slf4j
@Component
@RequiredArgsConstructor
@ConditionalOnProperty(name = "market.price-collector.enabled", havingValue = "true", matchIfMissing = true)
public class IndexPriceCollectorTask {

    private static final long LOCK_EXPIRE_SECONDS = 2;

    private final SymbolService symbolService;
    private final MarketPriceCacheService marketPriceCacheService;
    private final HistoryIndexPriceMapper historyIndexPriceMapper;
    private final HistoryIndexPriceMinuteMapper historyIndexPriceMinuteMapper;
    private final StringRedisTemplate stringRedisTemplate;
    private final ObjectMapper objectMapper;
    private final DistributedLock distributedLock;

    private String instanceIdentifier;
    private volatile boolean running = true;

    @PostConstruct
    public void start() {
        instanceIdentifier = generateIdentifier();
        clearHistoryPriceCache();

        Thread collector = new Thread(this::collectLoop, "index-price-collector");
        collector.setDaemon(true);
        collector.start();
        log.info("Index price collector started, instance: {}", instanceIdentifier);
    }

    private void collectLoop() {
        while (running && !Thread.currentThread().isInterrupted()) {
            try {
                // 1. 计算下一个整数秒时刻，sleep等待
                long now = System.currentTimeMillis();
                long nextSecond = ((now / 1000) + 1) * 1000;
                long sleepTime = nextSecond - now;
                if (sleepTime > 0) {
                    Thread.sleep(sleepTime);
                }

                // 2. 当前整数秒时间
                LocalDateTime secondTime = LocalDateTime.now().truncatedTo(ChronoUnit.SECONDS);

                // 3. 尝试获取分布式锁
                boolean locked = distributedLock.tryLock(
                        CacheConstants.LOCK_INDEX_PRICE_COLLECTOR,
                        instanceIdentifier,
                        LOCK_EXPIRE_SECONDS,
                        TimeUnit.SECONDS);

                if (locked) {
                    try {
                        collectAndSave(secondTime);
                    } finally {
                        distributedLock.unlock(CacheConstants.LOCK_INDEX_PRICE_COLLECTOR, instanceIdentifier);
                    }
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            } catch (Exception e) {
                log.error("Failed to collect index price", e);
            }
        }
    }

    private void collectAndSave(LocalDateTime secondTime) {
        // 1. 获取活跃交易对
        List<String> activeSymbols = symbolService.getActiveSymbolNames();
        if (activeSymbols.isEmpty()) return;

        // 2. 从Redis批量读取当前价格
        Map<String, BigDecimal> currentPrices = marketPriceCacheService.getIndexPrices(activeSymbols);
        if (currentPrices.isEmpty()) return;

        // 3. 写入秒级表
        List<HistoryIndexPrice> secondRecords = currentPrices.entrySet().stream()
            .map(e -> new HistoryIndexPrice(e.getKey(), e.getValue(), secondTime))
            .collect(Collectors.toList());
        historyIndexPriceMapper.batchUpsert(secondRecords);

        // 4. 写入 Redis ZSet 历史价格缓存（简化格式）
        long timestampMs = System.currentTimeMillis();
        cacheHistoryPricesToRedis(currentPrices, timestampMs);

        // 5. 如果是第59秒，写入分钟级表 + 计算24h统计
        if (secondTime.getSecond() == 59) {
            LocalDateTime minuteTime = secondTime.truncatedTo(ChronoUnit.MINUTES);

            // 5.1 写入分钟级表
            List<HistoryIndexPriceMinute> minuteRecords = currentPrices.entrySet().stream()
                .map(e -> new HistoryIndexPriceMinute(e.getKey(), e.getValue(), minuteTime))
                .collect(Collectors.toList());
            historyIndexPriceMinuteMapper.batchUpsert(minuteRecords);

            // 5.2 计算24h统计并写入Redis
            calculate24hStatsAndSave(activeSymbols, currentPrices, secondTime);
        }
    }
}
```

### 3.2 Redis ZSet 历史价格缓存（简化格式）

**数据结构**:
- Key: `BO:History:Price:{symbol}`
- Score: 时间戳（毫秒）
- Value: 简化 JSON `{"timestamp":1733903825000,"price":97500.25}`

```java
/**
 * 历史价格数据结构（简化版，只包含 timestamp 和 price）
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public static class HistoryPriceData {
    private Long timestamp;      // 时间戳（毫秒）
    private BigDecimal price;    // 价格
}

/**
 * 将历史价格写入 Redis ZSet
 */
private void cacheHistoryPricesToRedis(Map<String, BigDecimal> prices, long timestampMs) {
    stringRedisTemplate.executePipelined((RedisCallback<Object>) connection -> {
        for (Map.Entry<String, BigDecimal> entry : prices.entrySet()) {
            String symbol = entry.getKey();
            BigDecimal price = entry.getValue();

            try {
                String cacheKey = CacheConstants.buildHistoryPriceKey(symbol);
                byte[] keyBytes = cacheKey.getBytes();

                // 简化数据结构：只存储 timestamp 和 price
                String jsonValue = String.format("{\"timestamp\":%d,\"price\":%s}",
                    timestampMs, price.toPlainString());
                byte[] valueBytes = jsonValue.getBytes();

                // 写入数据（使用毫秒时间戳作为 score）
                connection.zAdd(keyBytes, timestampMs, valueBytes);
            } catch (Exception e) {
                log.error("Failed to cache history price: symbol={}", symbol, e);
            }
        }
        return null;
    });

    // 每60秒清理一次过期数据
    cleanupCounter++;
    if (cleanupCounter >= CLEANUP_INTERVAL) {
        cleanupCounter = 0;
        cleanupExpiredHistoryData(prices.keySet(), timestampMs);
    }
}
```

### 3.3 24小时统计计算

**涨跌幅计算公式**: `change = (currentPrice - price24hAgo) / price24hAgo`

**返回小数形式**，前端负责转换为百分比显示。

**24小时前价格获取策略**: 查询 `[now - 24h - 1min, now]` 范围内最早的价格，系统启动初期使用最早可用数据。

```java
/**
 * 计算24h统计数据并写入Redis
 */
private void calculate24hStatsAndSave(List<String> symbols, Map<String, BigDecimal> currentPrices, LocalDateTime now) {
    LocalDateTime h24Ago = now.minusHours(24);
    Map<String, String> statsMap = new HashMap<>();

    for (String symbol : symbols) {
        try {
            BigDecimal currentPrice = currentPrices.get(symbol);
            if (currentPrice == null) continue;

            // 查询24小时内最高最低价
            Stats24hResult stats = historyIndexPriceMapper.getStats24h(symbol, h24Ago, now);

            // 查询24小时+1分钟内最早的价格（系统启动初期使用最早可用数据）
            LocalDateTime startTime = now.minusHours(24).minusMinutes(1);
            BigDecimal price24hAgo = historyIndexPriceMinuteMapper.getEarliestPriceInRange(symbol, startTime, now);

            // 计算涨跌幅（返回小数形式）
            BigDecimal change = calculatePriceChange(currentPrice, price24hAgo);

            // 构建统计数据
            Stats24hDTO dto = Stats24hDTO.builder()
                .high(stats != null ? stats.getHigh() : null)
                .low(stats != null ? stats.getLow() : null)
                .change(change)
                .timestamp(System.currentTimeMillis())
                .build();

            statsMap.put(symbol, objectMapper.writeValueAsString(dto));
        } catch (Exception e) {
            log.error("Failed to calculate 24h stats for symbol: {}", symbol, e);
        }
    }

    if (!statsMap.isEmpty()) {
        stringRedisTemplate.opsForHash().putAll(CacheConstants.MARKET_STATS_24H_KEY, statsMap);
    }
}

/**
 * 计算价格涨跌幅（返回小数形式）
 *
 * 示例:
 * - 当前价格: 97500.00, 24小时前价格: 95000.00
 * - 涨跌幅 = (97500 - 95000) / 95000 = 0.0263 (表示 2.63%)
 */
private BigDecimal calculatePriceChange(BigDecimal currentPrice, BigDecimal price24hAgo) {
    if (currentPrice == null || price24hAgo == null) return null;
    if (price24hAgo.compareTo(BigDecimal.ZERO) == 0) return null;

    return currentPrice.subtract(price24hAgo)
        .divide(price24hAgo, 4, RoundingMode.HALF_UP);
}
```

### 3.4 Mapper SQL

```xml
<!-- 查询指定时间范围内最早的价格（系统启动初期使用） -->
<select id="getEarliestPriceInRange" resultType="java.math.BigDecimal">
    SELECT price
    FROM bo_history_index_price_minute
    WHERE symbol = #{symbol}
      AND minute_time BETWEEN #{startTime} AND #{endTime}
    ORDER BY minute_time ASC
    LIMIT 1
</select>
```

## 4. market-service 实时推送

### 4.1 架构简化

移除独立的 `MarketDataRefreshTask`，改为在 WebSocket 推送前即时刷新数据，确保推送的是最新价格。

**数据读取方式**:

| 数据 | Redis Key | 说明 |
|------|-----------|------|
| 当前价格 | `pricer:index` (Hash) | 外部报价系统写入 |
| 24h统计 | `BO:Market:Stats24h` (Hash) | order-service 每分钟更新 |

### 4.2 MarketWebSocketHandler

```java
@Component
@Slf4j
public class MarketWebSocketHandler extends TextWebSocketHandler {

    @Autowired
    private MarketTickCacheService marketTickCacheService;

    /**
     * 定时任务：向已订阅的客户端推送行情数据
     * 推送前先刷新 Redis 数据，确保推送最新价格
     */
    @Scheduled(fixedRateString = "${websocket.push.interval:1000}")
    public void pushMarketData() {
        if (sessions.isEmpty()) {
            return;
        }

        try {
            // 先从 Redis 刷新最新数据，确保推送的是最新价格
            marketTickCacheService.refreshFromRedis();

            // 收集所有订阅的交易对
            Set<String> allSymbols = new HashSet<>();
            for (WebSocketSession session : sessions) {
                Set<String> symbols = sessionSymbols.get(session.getId());
                if (symbols != null) {
                    allSymbols.addAll(symbols);
                }
            }

            if (allSymbols.isEmpty()) return;

            // 批量获取所有订阅交易对的行情数据
            Map<String, MarketTickDTO> tickMap = marketTickCacheService.getMarketTicks(allSymbols);
            if (tickMap.isEmpty()) return;

            // 遍历每个会话，推送其订阅的交易对行情
            for (WebSocketSession session : sessions) {
                if (!session.isOpen()) continue;

                Set<String> subscribedSymbols = sessionSymbols.get(session.getId());
                if (subscribedSymbols == null || subscribedSymbols.isEmpty()) continue;

                for (String symbol : subscribedSymbols) {
                    MarketTickDTO tick = tickMap.get(symbol);
                    if (tick != null) {
                        String tickJson = objectMapper.writeValueAsString(tick);
                        queueMessage(session, tickJson);
                    }
                }
            }
        } catch (Exception e) {
            log.error("Error in scheduled market data push", e);
        }
    }
}
```

### 4.3 MarketTickCacheService

```java
@Slf4j
@Component
@RequiredArgsConstructor
public class MarketTickCacheService {

    private static final List<Integer> SUPPORTED_DURATIONS = List.of(30, 60, 120, 300);
    private static final BigDecimal DEFAULT_ODDS = new BigDecimal("1.95");

    private final StringRedisTemplate stringRedisTemplate;
    private final ObjectMapper objectMapper;

    // 本地缓存 (从Redis刷新)
    private final Map<String, BigDecimal> priceCache = new ConcurrentHashMap<>();
    private final Map<String, Stats24hCache> stats24hCache = new ConcurrentHashMap<>();

    /**
     * 从Redis刷新数据到本地缓存
     * 由 MarketWebSocketHandler 在推送前调用
     */
    public void refreshFromRedis() {
        // 1. 读取当前价格
        try {
            Map<Object, Object> prices = stringRedisTemplate.opsForHash()
                .entries(CacheConstants.PRICER_INDEX_KEY);
            for (Map.Entry<Object, Object> entry : prices.entrySet()) {
                String symbol = entry.getKey().toString();
                BigDecimal price = new BigDecimal(entry.getValue().toString());
                priceCache.put(symbol, price);
            }
        } catch (Exception e) {
            log.error("Failed to refresh prices from Redis", e);
        }

        // 2. 读取24h统计
        try {
            Map<Object, Object> stats = stringRedisTemplate.opsForHash()
                .entries(CacheConstants.MARKET_STATS_24H_KEY);
            for (Map.Entry<Object, Object> entry : stats.entrySet()) {
                String symbol = entry.getKey().toString();
                Stats24hCache dto = objectMapper.readValue(
                    entry.getValue().toString(), Stats24hCache.class);
                stats24hCache.put(symbol, dto);
            }
        } catch (Exception e) {
            log.error("Failed to refresh stats24h from Redis", e);
        }
    }

    /**
     * 获取完整的行情数据
     */
    public MarketTickDTO getMarketTick(String symbol) {
        BigDecimal price = priceCache.get(symbol);
        if (price == null) return null;

        Stats24hCache stats = stats24hCache.get(symbol);
        List<OddsDTO> oddsList = buildOddsList(symbol);

        return MarketTickDTO.builder()
            .type("tick")
            .symbol(symbol)
            .price(price)
            .price24hMax(stats != null ? stats.getHigh() : null)
            .price24hMin(stats != null ? stats.getLow() : null)
            .price24hChange(stats != null ? stats.getChange() : null)
            .odds(oddsList)
            .timestamp(System.currentTimeMillis())
            .build();
    }
}
```

## 5. /market/history 接口

### 5.1 HistoryPriceQueryService

从 Redis ZSet 查询历史价格数据，返回简化格式。

```java
@Slf4j
@Service
public class HistoryPriceQueryService {

    private final RedisTemplate<String, String> redisTemplate;
    private final ObjectMapper objectMapper;

    /**
     * 历史价格数据结构（简化版）
     */
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class HistoryPriceData {
        private Long timestamp;      // 时间戳（毫秒）
        private BigDecimal price;    // 价格
    }

    /**
     * 查询历史价格数据
     */
    public BtseHistoryResponseDTO getHistoryPrices(BtseHistoryRequestDTO request) {
        try {
            String cacheKey = CacheConstants.buildHistoryPriceKey(request.getSymbol());

            // 解析 limit 参数，默认200
            int limit = 200;
            if (request.getLimitAfter() != null && !request.getLimitAfter().isEmpty()) {
                try {
                    limit = Integer.parseInt(request.getLimitAfter());
                } catch (NumberFormatException e) {
                    log.warn("Invalid limitAfter: {}, using default 200", request.getLimitAfter());
                }
            }

            // 查询最新 N 条数据
            Set<String> jsonValues = redisTemplate.opsForZSet()
                .reverseRange(cacheKey, 0, limit - 1);

            if (jsonValues == null || jsonValues.isEmpty()) {
                return BtseHistoryResponseDTO.builder()
                    .symbol(request.getSymbol())
                    .history(new ArrayList<>())
                    .build();
            }

            // 解析并转换为数组格式: [timestamp, price]
            List<List<BigDecimal>> historyData = new ArrayList<>(jsonValues.size());
            for (String jsonValue : jsonValues) {
                try {
                    HistoryPriceData priceData = objectMapper.readValue(jsonValue, HistoryPriceData.class);
                    if (priceData != null && priceData.getTimestamp() != null
                            && priceData.getPrice() != null
                            && priceData.getPrice().compareTo(BigDecimal.ZERO) > 0) {
                        historyData.add(List.of(
                            new BigDecimal(priceData.getTimestamp()),
                            priceData.getPrice()
                        ));
                    }
                } catch (JsonProcessingException e) {
                    log.error("Failed to deserialize price data: {}", e.getMessage());
                }
            }

            // 反转为时间升序
            Collections.reverse(historyData);

            return BtseHistoryResponseDTO.builder()
                .symbol(request.getSymbol())
                .history(historyData)
                .build();

        } catch (Exception e) {
            log.error("Failed to get history prices for {}", request.getSymbol(), e);
            return BtseHistoryResponseDTO.builder()
                .symbol(request.getSymbol())
                .history(new ArrayList<>())
                .build();
        }
    }
}
```

### 5.2 返回格式

```json
{
  "symbol": "BTC-USDT",
  "history": [
    [1733903820000, 97498.50],
    [1733903821000, 97500.25],
    [1733903822000, 97502.00],
    ...
  ]
}
```

每个元素为 `[timestamp, price]` 数组：
- `[0]`: 时间戳（毫秒）
- `[1]`: 价格

## 6. 推送给前端的数据格式

### 6.1 MarketTickDTO 数据结构

```java
@Data
@Builder
public class MarketTickDTO {
    private String type = "tick";           // 消息类型
    private String symbol;                   // 交易对
    private BigDecimal price;                // 当前指数价格
    private BigDecimal price24hMax;          // 24小时最高价
    private BigDecimal price24hMin;          // 24小时最低价
    private BigDecimal price24hChange;       // 24小时涨跌幅 (小数形式，如 0.0235 表示 2.35%)
    private List<OddsDTO> odds;              // 各时间区间的赔率数组
    private Long timestamp;                  // 时间戳
}

@Data
@Builder
public class OddsDTO {
    private Integer duration;                // 时间区间 (秒)
    private BigDecimal upOdds;               // 看涨赔率
    private BigDecimal downOdds;             // 看跌赔率
}
```

### 6.2 推送消息示例

```json
{
  "type": "tick",
  "symbol": "BTC-USDT",
  "price": 97500.25,
  "price24hMax": 98500.00,
  "price24hMin": 96200.00,
  "price24hChange": 0.0235,
  "odds": [
    {"duration": 30, "upOdds": 1.95, "downOdds": 1.95},
    {"duration": 60, "upOdds": 1.95, "downOdds": 1.95},
    {"duration": 120, "upOdds": 1.95, "downOdds": 1.95},
    {"duration": 300, "upOdds": 1.95, "downOdds": 1.95}
  ],
  "timestamp": 1733836800000
}
```

**注意**: `price24hChange` 为小数形式，前端需要乘以100转换为百分比显示。

## 7. 整体架构图

```
+------------------+
|  外部报价系统     |
+--------+---------+
         |
         v
+------------------+
|  Redis           |
|  pricer:index    |
+--------+---------+
         |
         v
+--------------------------------------------------+
|                  order-service                    |
|                                                  |
|  +--------------------------------------------+  |
|  |  IndexPriceCollectorTask (单线程循环)       |  |
|  |                                            |  |
|  |  每秒执行 (使用 DistributedLock):           |  |
|  |  - 读取 Redis pricer:index                 |  |
|  |  - 写入 bo_history_index_price (秒级)      |  |
|  |  - 写入 Redis ZSet BO:History:Price:*     |  |
|  |    (简化格式: timestamp + price)           |  |
|  |                                            |  |
|  |  第59秒额外执行:                            |  |
|  |  - 写入 bo_history_index_price_minute     |  |
|  |  - 计算24h最高/最低/涨跌幅(小数形式)        |  |
|  |  - 写入 Redis BO:Market:Stats24h          |  |
|  +--------------------------------------------+  |
+-------------------------+------------------------+
                          |
                          | Redis
                          v
+--------------------------------------------------+
|                  market-service                   |
|                                                  |
|  +--------------------------------------------+  |
|  |  MarketWebSocketHandler (每秒推送)          |  |
|  |  - 推送前调用 refreshFromRedis()           |  |
|  |  - 确保推送最新价格，无延迟                  |  |
|  +--------------------------------------------+  |
|                                                  |
|  +--------------------------------------------+  |
|  |  MarketTickCacheService (本地缓存)          |  |
|  |  - 当前价格缓存 (priceCache)               |  |
|  |  - 24h统计缓存 (stats24hCache)             |  |
|  |  - 整合数据返回 MarketTickDTO              |  |
|  +--------------------------------------------+  |
+-------------------------+------------------------+
                          |
                          | WebSocket
                          v
                  +------------------+
                  |     前端客户端    |
                  +------------------+
```

## 8. 配置项

### 8.1 order-service application.yml

```yaml
market:
  price-collector:
    enabled: true
  history-cleanup:
    enabled: true
    cron: "0 0 2 * * ?"
    second-retention-days: 3
    minute-retention-days: 7
```

### 8.2 market-service application.yml

```yaml
btse:
  websocket:
    enabled: false

websocket:
  push:
    interval: 1000
```

## 9. 测试验证

### 9.1 Redis ZSet 历史价格验证

```bash
# 检查Redis ZSet历史价格数据
redis-cli ZRANGE BO:History:Price:BTC-USDT 0 -1 WITHSCORES

# 预期返回: 简化格式的价格数据
# 1) "{\"timestamp\":1733836800000,\"price\":97500.25}"
# 2) "1733836800000"

# 检查数据条数
redis-cli ZCARD BO:History:Price:BTC-USDT
```

### 9.2 24h统计验证

```bash
# 检查Redis中的24h统计数据
redis-cli HGETALL BO:Market:Stats24h

# 预期返回 (change 为小数形式):
# "BTC-USDT"
# "{\"high\":98500.00,\"low\":96200.00,\"change\":0.0235,\"timestamp\":1733836800000}"
```

### 9.3 WebSocket推送验证

```bash
wscat -c ws://localhost:8083/ws/market
{"subscribe": "BTC-USDT"}

# 预期返回 (price24hChange 为小数形式):
# {"type":"tick","symbol":"BTC-USDT","price":97500.25,
#  "price24hMax":98500.00,"price24hMin":96200.00,
#  "price24hChange":0.0235,"odds":[...],"timestamp":1733836800000}
```

## 10. 注意事项

1. **分布式锁**: 使用 `DistributedLock` 组件（基于 `distributedLockRedisTemplate`），确保多实例环境下不重复执行
2. **涨跌幅格式**: 返回小数形式（如 `0.0235`），前端负责转换为百分比显示（`2.35%`）
3. **24小时前价格**: 查询 `[now - 24h - 1min, now]` 范围内最早的价格，系统启动初期使用最早可用数据
4. **历史价格缓存**: 使用简化格式 `{timestamp, price}`，Score 为毫秒时间戳
5. **推送延迟优化**: 在 WebSocket 推送前即时刷新 Redis 数据，确保推送最新价格
6. **服务启动清空缓存**: `IndexPriceCollectorTask` 启动时清空 `BO:History:Price:*` 缓存，避免旧数据残留
