# 统一赔率获取 (预备工作)

## 1. 概述

### 1.1 目标
在接入动态赔率计算模块之前，先将现有分散的赔率获取逻辑统一到一处，为后续动态赔率接入做准备。

### 1.2 当前问题
赔率获取逻辑分散在两个服务中：

| 服务 | 位置 | 当前实现 |
|------|------|---------|
| option-order-service | OrderService.createOrder() | `orderConfig.getDefaultOdds()` → 1.90 |
| option-market-service | MarketTickCacheService.buildOddsList() | 本地常量 `DEFAULT_ODDS` → 1.95 |

**问题：**
- 赔率来源不统一，难以维护
- 后续接入动态赔率需要同时修改两处代码
- DurationConfig 表已有 baseOdds 字段未被利用

---

## 2. 目标架构

### 2.1 方案：Redis 共享赔率数据

`order-service` 负责写入赔率到 Redis，`market-service` 直接从 Redis 读取。

```
┌────────────────────────────────────────────────────────────┐
│                    统一赔率获取架构                          │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  option-order-service                                      │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  OddsService                                          │  │
│  │  ├── getOdds(symbol, duration) → 本地调用             │  │
│  │  └── refreshOddsCache() → 写入 Redis                 │  │
│  │                                                       │  │
│  │  数据来源: bo_duration_config.base_odds              │  │
│  │  降级方案: orderConfig.defaultOdds (1.90)            │  │
│  └──────────────────────────────────────────────────────┘  │
│                           │                                │
│                           ▼                                │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  Redis                                                │  │
│  │  Key: BO:Odds:{symbol}                               │  │
│  │  Value: {"1": 1.95, "3": 1.95, "5": 1.95, "15": 1.95} │  │
│  └──────────────────────────────────────────────────────┘  │
│                           │                                │
└───────────────────────────┼────────────────────────────────┘
                            │
                            ▼
┌────────────────────────────────────────────────────────────┐
│  option-market-service                                      │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  MarketTickCacheService                               │  │
│  │  └── buildOddsList(symbol) → 直接读取 Redis          │  │
│  └──────────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────────┘
```

### 2.2 优势

| 对比项 | RPC 方案 | Redis 方案 |
|--------|---------|-----------|
| 网络开销 | HTTP 调用 | Redis 读取 |
| 延迟 | ~10ms | ~1ms |
| 可靠性 | 依赖服务可用 | Redis 已有高可用 |
| 复杂度 | 需 RPC 客户端/服务端 | 直接读写 |
| 扩展性 | 需增加接口 | 修改 Redis 数据结构 |

---

## 3. Redis 数据结构设计

### 3.1 Key 设计

```
BO:Odds:{symbol}
```

**示例：**
- `BO:Odds:BTC-USDT`
- `BO:Odds:ETH-USDT`

### 3.2 Value 结构

使用 Hash 结构，field 区分 duration 和方向：

```
BO:Odds:BTC-USDT
├── 1:UP   → "1.95"
├── 1:DOWN → "1.90"
├── 3:UP   → "1.95"
├── 3:DOWN → "1.90"
├── 5:UP   → "1.95"
├── 5:DOWN → "1.90"
└── 15:UP  → "1.95"
    15:DOWN → "1.90"
```

**写入示例：**
```bash
HSET BO:Odds:BTC-USDT \
  "1:UP" "1.95" "1:DOWN" "1.90" \
  "3:UP" "1.95" "3:DOWN" "1.90" \
  "5:UP" "1.95" "5:DOWN" "1.90" \
  "15:UP" "1.95" "15:DOWN" "1.90"
```

**读取：**
```bash
HGETALL BO:Odds:BTC-USDT
```

### 3.3 Field 命名规则

```
{duration}:{direction}
```

| 示例 | 含义 |
|------|------|
| `1:UP` | 1分钟看涨赔率 |
| `1:DOWN` | 1分钟看跌赔率 |
| `5:UP` | 5分钟看涨赔率 |
| `5:DOWN` | 5分钟看跌赔率 |

---

## 4. 实现步骤

### 4.1 Step 1: 添加 Redis Key 常量

**文件：** `option-common-utils/.../CacheConstants.java`

```java
/**
 * 赔率缓存 Key 前缀
 * 完整 Key: BO:Odds:{symbol}
 * Value: Hash, field=duration(分钟), value=odds
 */
String ODDS_KEY_PREFIX = "BO:Odds:";
```

### 4.2 Step 2: 创建 OddsService (order-service)

**文件：** `option-order-service/.../service/OddsService.java`

```java
@Slf4j
@Service
@RequiredArgsConstructor
public class OddsService {

    private final DurationConfigMapper durationConfigMapper;
    private final StringRedisTemplate stringRedisTemplate;
    private final OrderConfig orderConfig;

    // 本地缓存：duration -> OddsPair(upOdds, downOdds)
    private volatile Map<Integer, OddsPair> oddsCache = new ConcurrentHashMap<>();

    @Data
    @AllArgsConstructor
    public static class OddsPair {
        private BigDecimal upOdds;
        private BigDecimal downOdds;
    }

    /**
     * 获取指定交易对、周期、方向的赔率 (供 OrderService 调用)
     */
    public BigDecimal getOdds(String symbol, Integer durationMinutes, String direction) {
        OddsPair pair = oddsCache.get(durationMinutes);
        if (pair != null) {
            return "UP".equalsIgnoreCase(direction) ? pair.getUpOdds() : pair.getDownOdds();
        }

        // 缓存未命中，从 Redis 获取
        String key = CacheConstants.ODDS_KEY_PREFIX + symbol;
        String upKey = durationMinutes + ":UP";
        String downKey = durationMinutes + ":DOWN";

        Object upVal = stringRedisTemplate.opsForHash().get(key, upKey);
        Object downVal = stringRedisTemplate.opsForHash().get(key, downKey);

        if (upVal != null && downVal != null) {
            BigDecimal upOdds = new BigDecimal(upVal.toString());
            BigDecimal downOdds = new BigDecimal(downVal.toString());
            oddsCache.put(durationMinutes, new OddsPair(upOdds, downOdds));
            return "UP".equalsIgnoreCase(direction) ? upOdds : downOdds;
        }

        // 降级使用数据库默认值
        DurationConfig config = durationConfigMapper.findByDuration(durationMinutes);
        if (config != null && config.getBaseOdds() != null) {
            return config.getBaseOdds();
        }

        return orderConfig.getDefaultOdds();
    }

    /**
     * 刷新赔率缓存到 Redis (供定时任务调用)
     * 初期: 使用 baseOdds 作为 UP/DOWN 的默认值
     * 后续: 接入动态计算，UP/DOWN 会有不同值
     */
    public void refreshOddsToRedis(List<String> activeSymbols) {
        List<DurationConfig> configs = durationConfigMapper.findAllEnabled();

        // 构建 {duration}:{direction} -> odds 映射
        Map<String, String> oddsMap = new HashMap<>();
        for (DurationConfig config : configs) {
            int duration = config.getDurationMinutes();
            BigDecimal baseOdds = config.getBaseOdds();

            // 初期: UP/DOWN 使用相同的 baseOdds
            // 后续: 这里会调用动态计算得到不同的 upOdds/downOdds
            BigDecimal upOdds = baseOdds;
            BigDecimal downOdds = baseOdds;

            oddsMap.put(duration + ":UP", upOdds.toPlainString());
            oddsMap.put(duration + ":DOWN", downOdds.toPlainString());

            // 同时更新本地缓存
            oddsCache.put(duration, new OddsPair(upOdds, downOdds));
        }

        // 写入每个活跃 symbol
        for (String symbol : activeSymbols) {
            String key = CacheConstants.ODDS_KEY_PREFIX + symbol;
            stringRedisTemplate.opsForHash().putAll(key, oddsMap);
        }

        log.info("Refreshed odds to Redis for {} symbols, {} durations",
                 activeSymbols.size(), configs.size());
    }
}
```

### 4.3 Step 3: 修改 OrderService

**文件：** `option-order-service/.../service/OrderService.java`

```java
// 修改前
BigDecimal odds = orderConfig.getDefaultOdds();

// 修改后 (需要传入 direction)
BigDecimal odds = oddsService.getOdds(symbol, durationMinutes, direction);
```

### 4.4 Step 4: 修改 MarketTickCacheService

**文件：** `option-market-service/.../cache/MarketTickCacheService.java`

```java
// 本地赔率缓存：symbol -> (duration -> OddsPair)
private final Map<String, Map<Integer, OddsPair>> oddsCache = new ConcurrentHashMap<>();

@Data
@AllArgsConstructor
private static class OddsPair {
    private BigDecimal upOdds;
    private BigDecimal downOdds;
}

/**
 * 从 Redis 刷新赔率到本地缓存
 * 由 MarketDataRefreshTask 调用
 */
public void refreshOddsFromRedis() {
    for (String symbol : activeSymbols) {
        try {
            String key = CacheConstants.ODDS_KEY_PREFIX + symbol;
            Map<Object, Object> entries = stringRedisTemplate.opsForHash().entries(key);

            if (!entries.isEmpty()) {
                Map<Integer, OddsPair> symbolOdds = new HashMap<>();

                // 解析 Redis 数据: "1:UP" -> "1.95", "1:DOWN" -> "1.90"
                Map<Integer, BigDecimal> upOddsMap = new HashMap<>();
                Map<Integer, BigDecimal> downOddsMap = new HashMap<>();

                for (Map.Entry<Object, Object> entry : entries.entrySet()) {
                    String field = entry.getKey().toString();  // "1:UP" or "1:DOWN"
                    String[] parts = field.split(":");
                    if (parts.length == 2) {
                        Integer duration = Integer.parseInt(parts[0]);
                        BigDecimal odds = new BigDecimal(entry.getValue().toString());
                        if ("UP".equals(parts[1])) {
                            upOddsMap.put(duration, odds);
                        } else {
                            downOddsMap.put(duration, odds);
                        }
                    }
                }

                // 合并为 OddsPair
                for (Integer duration : SUPPORTED_DURATIONS) {
                    BigDecimal upOdds = upOddsMap.getOrDefault(duration, DEFAULT_UP_ODDS);
                    BigDecimal downOdds = downOddsMap.getOrDefault(duration, DEFAULT_DOWN_ODDS);
                    symbolOdds.put(duration, new OddsPair(upOdds, downOdds));
                }

                oddsCache.put(symbol, symbolOdds);
            }
        } catch (Exception e) {
            log.error("Failed to refresh odds for symbol: {}", symbol, e);
        }
    }
}

/**
 * 构建赔率列表
 */
private List<OddsDTO> buildOddsList(String symbol) {
    Map<Integer, OddsPair> symbolOdds = oddsCache.get(symbol);

    return SUPPORTED_DURATIONS.stream()
            .map(duration -> {
                OddsPair pair = (symbolOdds != null)
                    ? symbolOdds.get(duration)
                    : null;
                return OddsDTO.builder()
                        .duration(duration)
                        .upOdds(pair != null ? pair.getUpOdds() : DEFAULT_UP_ODDS)
                        .downOdds(pair != null ? pair.getDownOdds() : DEFAULT_DOWN_ODDS)
                        .build();
            })
            .collect(Collectors.toList());
}
```

### 4.5 Step 5: 添加赔率刷新服务 (持续运行 + 按 Symbol 分布式锁)

**order-service 写入 Redis (持续运行、多线程、按 symbol 分布式锁)：**

```java
@Slf4j
@Component
@RequiredArgsConstructor
public class OddsRefreshRunner implements ApplicationRunner {

    private final OddsService oddsService;
    private final SymbolService symbolService;
    private final StringRedisTemplate stringRedisTemplate;

    // 分布式锁 Key 前缀 (每个 symbol 一个锁)
    private static final String LOCK_KEY_PREFIX = "BO:Lock:Odds:";
    private static final long LOCK_EXPIRE_MS = 2000; // 2秒过期

    // 专用线程池
    private final ExecutorService executor = Executors.newFixedThreadPool(
        Runtime.getRuntime().availableProcessors(),
        new ThreadFactoryBuilder().setNameFormat("odds-calc-%d").build()
    );

    private volatile boolean running = true;
    private final String instanceId = UUID.randomUUID().toString();

    @Override
    public void run(ApplicationArguments args) {
        Thread mainThread = new Thread(this::runLoop, "odds-refresh-main");
        mainThread.setDaemon(true);
        mainThread.start();
        log.info("OddsRefreshRunner started, instanceId={}", instanceId);
    }

    private void runLoop() {
        while (running) {
            long startTime = System.currentTimeMillis();

            try {
                List<String> activeSymbols = symbolService.getActiveSymbolNames();
                if (!activeSymbols.isEmpty()) {
                    refreshAllSymbols(activeSymbols);
                }
            } catch (Exception e) {
                log.error("Odds refresh loop error", e);
            }

            // 控制刷新频率
            long elapsed = System.currentTimeMillis() - startTime;
            if (elapsed < 1000) {
                try {
                    Thread.sleep(1000 - elapsed);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
    }

    private void refreshAllSymbols(List<String> symbols) {
        // 并行处理所有 symbol，每个 symbol 单独竞争锁
        List<CompletableFuture<Void>> futures = symbols.stream()
            .map(symbol -> CompletableFuture.runAsync(
                () -> refreshSymbolWithLock(symbol),
                executor
            ))
            .collect(Collectors.toList());

        try {
            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .get(2000, TimeUnit.MILLISECONDS);
        } catch (TimeoutException e) {
            log.warn("Odds refresh timeout, {} symbols", symbols.size());
        } catch (Exception e) {
            log.error("Odds refresh failed", e);
        }
    }

    /**
     * 带分布式锁的单 symbol 刷新
     * 每个 symbol 独立加锁，多实例可并行处理不同 symbol
     */
    private void refreshSymbolWithLock(String symbol) {
        String lockKey = LOCK_KEY_PREFIX + symbol;

        // 尝试获取该 symbol 的锁
        Boolean acquired = stringRedisTemplate.opsForValue().setIfAbsent(
            lockKey,
            instanceId,
            Duration.ofMillis(LOCK_EXPIRE_MS)
        );

        if (Boolean.TRUE.equals(acquired)) {
            try {
                oddsService.refreshOddsForSymbol(symbol);
            } catch (Exception e) {
                log.error("Failed to refresh odds for symbol: {}", symbol, e);
            }
            // 锁自然过期，不主动释放
        }
        // 未获取到锁说明其他实例正在处理，跳过
    }

    @PreDestroy
    public void stop() {
        running = false;
        executor.shutdown();
        log.info("OddsRefreshRunner stopped");
    }
}
```

**OddsService 单 symbol 刷新：**

```java
/**
 * 刷新单个 symbol 的赔率到 Redis
 * 供多线程调用
 */
public void refreshOddsForSymbol(String symbol) {
    try {
        List<DurationConfig> configs = getCachedConfigs();
        Map<String, String> oddsMap = new HashMap<>();

        for (DurationConfig config : configs) {
            int duration = config.getDurationMinutes();
            BigDecimal baseOdds = config.getBaseOdds();

            // 初期: UP/DOWN 使用相同的 baseOdds
            // 后续: 这里调用动态计算
            oddsMap.put(duration + ":UP", baseOdds.toPlainString());
            oddsMap.put(duration + ":DOWN", baseOdds.toPlainString());
        }

        String key = CacheConstants.ODDS_KEY_PREFIX + symbol;
        stringRedisTemplate.opsForHash().putAll(key, oddsMap);
    } catch (Exception e) {
        log.error("Failed to refresh odds for symbol: {}", symbol, e);
    }
}
```

**market-service 读取 Redis：**
```java
// 在现有 refreshFromRedis() 方法中添加
public void refreshFromRedis() {
    // ... 现有逻辑 ...

    // 刷新赔率 (随价格一起刷新)
    refreshOddsFromRedis();
}
```

---

## 5. 数据流

```
┌─────────────────────────────────────────────────────────────────┐
│                    数据流 (持续运行)                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  OddsRefreshRunner (order-service, 持续运行)                     │
│  ┌───────────┐    ┌───────────────────────────┐                │
│  │ 获取活跃   │───▶│     线程池并行处理          │                │
│  │ Symbols   │    │  ┌─────┐ ┌─────┐ ┌─────┐  │                │
│  └───────────┘    │  │ BTC │ │ ETH │ │ ... │  │                │
│        ▲          │  └──┬──┘ └──┬──┘ └──┬──┘  │                │
│        │          └─────┼───────┼───────┼─────┘                │
│        │                │       │       │                       │
│   while(running)        ▼       ▼       ▼                       │
│        │          ┌─────────────────────────┐                  │
│        └──────────│         Redis           │                  │
│                   │  BO:Odds:BTC-USDT       │                  │
│                   │  BO:Odds:ETH-USDT       │                  │
│                   │  BO:Odds:...            │                  │
│                   └─────────────────────────┘                  │
│                              │                                  │
│       ┌──────────────────────┼──────────────────────┐          │
│       │                      │                      │          │
│       ▼                      ▼                      ▼          │
│  ┌─────────┐          ┌───────────┐          ┌───────────┐    │
│  │ 下单    │          │ 行情推送   │          │ WebSocket │    │
│  │本地缓存 │          │ 读Redis   │          │ 推送客户端 │    │
│  └─────────┘          └───────────┘          └───────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 6. 性能优化

### 6.1 持续运行 vs 定时任务

| 对比项 | 定时任务 (@Scheduled) | 持续运行 (ApplicationRunner) |
|--------|----------------------|------------------------------|
| 调度开销 | 有 | 无 |
| 任务重叠 | 可能重叠 | 顺序执行，无重叠 |
| 灵活性 | 固定间隔 | 可根据计算时间动态调整 |
| 适用场景 | 轻量任务 | **CPU密集型计算** |

### 6.2 分布式部署 (按 Symbol 分布式锁)

每个 symbol 独立加锁，多实例可并行处理不同 symbol：

```
┌─────────────────────────────────────────────────────────────────┐
│                   多实例并行处理架构                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   order-service-1              order-service-2                  │
│   ┌───────────────────┐        ┌───────────────────┐           │
│   │ BTC-USDT: lock ✓  │        │ BTC-USDT: skip    │           │
│   │ ETH-USDT: skip    │        │ ETH-USDT: lock ✓  │           │
│   │ SOL-USDT: lock ✓  │        │ SOL-USDT: skip    │           │
│   │ BNB-USDT: skip    │        │ BNB-USDT: lock ✓  │           │
│   └─────────┬─────────┘        └─────────┬─────────┘           │
│             │                            │                      │
│             ▼                            ▼                      │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │                        Redis                             │  │
│   │  BO:Lock:Odds:BTC-USDT = instance-1  (TTL: 2s)          │  │
│   │  BO:Lock:Odds:ETH-USDT = instance-2  (TTL: 2s)          │  │
│   │  BO:Lock:Odds:SOL-USDT = instance-1  (TTL: 2s)          │  │
│   │  BO:Lock:Odds:BNB-USDT = instance-2  (TTL: 2s)          │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

| 配置项 | 值 | 说明 |
|--------|---|------|
| 锁 Key | BO:Lock:Odds:{symbol} | 每个 symbol 一个锁 |
| 锁过期 | 2秒 | 自动释放，防止死锁 |
| 获取方式 | SETNX | 原子操作 |

**优势：**
- 多实例并行处理，充分利用资源
- 负载自动均衡，先抢到锁的先处理
- 单实例故障只影响部分 symbol，其他实例可接管
- 水平扩展能力强

### 6.3 多线程设计

| 配置项 | 值 | 说明 |
|--------|---|------|
| 线程池大小 | CPU 核心数 | JNI 计算是 CPU 密集型 |
| 任务超时 | 2000ms | 预留缓冲时间 |
| 刷新间隔 | ≥1000ms | 每轮计算完成后检查 |

### 6.4 初期 vs 后续

| 阶段 | 计算逻辑 | 单 symbol 耗时 | 并行需求 |
|------|---------|---------------|---------|
| 初期 (固定赔率) | 读本地缓存 | <1ms | 低 (可串行) |
| 后续 (动态赔率) | JNI 计算 | ~10-50ms | 高 (必须并行) |

### 6.5 Redis 批量写入优化

当 symbol 数量较多时，可使用 Pipeline 批量写入：

```java
/**
 * 批量刷新所有 symbol 的赔率 (Pipeline 优化)
 */
public void refreshAllOddsBatch(List<String> symbols) {
    Map<String, String> oddsMap = buildOddsMap();

    stringRedisTemplate.executePipelined((RedisCallback<Object>) connection -> {
        for (String symbol : symbols) {
            byte[] key = (CacheConstants.ODDS_KEY_PREFIX + symbol).getBytes();
            Map<byte[], byte[]> hashData = new HashMap<>();
            oddsMap.forEach((k, v) -> hashData.put(k.getBytes(), v.getBytes()));
            connection.hMSet(key, hashData);
        }
        return null;
    });
}
```

### 6.6 后续动态赔率计算架构

```
┌─────────────────────────────────────────────────────────────┐
│              动态赔率计算 (每秒、多线程)                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌──────────────────────────────────────────────────────┐  │
│   │  OddsRefreshTask (每秒调度)                           │  │
│   │                                                       │  │
│   │  for each symbol (并行):                              │  │
│   │    1. 获取当前价格 (Redis)                            │  │
│   │    2. 获取波动率预测 (Redis)                          │  │
│   │    3. 调用 JNI 计算赔率 (CPU 密集)                    │  │
│   │    4. 写入 Redis                                      │  │
│   └──────────────────────────────────────────────────────┘  │
│                                                             │
│   线程池配置:                                               │
│   - 类型: FixedThreadPool                                   │
│   - 大小: CPU 核心数 (JNI 计算是 CPU 密集型)                │
│   - 超时: 800ms                                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 7. 修改文件列表

```
BinaryOption/
├── option-common-utils/
│   └── src/main/java/com/binaryoption/commonutils/constants/
│       └── CacheConstants.java                   # [修改] 添加 ODDS_KEY_PREFIX
│
├── option-order-service/
│   └── src/main/java/com/binaryoption/orderservice/
│       ├── service/
│       │   ├── OddsService.java                  # [新增] 赔率服务
│       │   └── OrderService.java                 # [修改] 使用 OddsService
│       └── runner/
│           └── OddsRefreshRunner.java            # [新增] 持续运行的赔率刷新服务
│
└── option-market-service/
    └── src/main/java/com/binaryoption/marketservice/cache/
        └── MarketTickCacheService.java           # [修改] 从 Redis 读取赔率
```

**文件统计：**
| 类型 | 数量 |
|------|------|
| 新增 Java 文件 | 2 |
| 修改 Java 文件 | 3 |

---

## 8. 测试验证

### 8.1 Redis 数据验证

```bash
# 查看赔率数据
redis-cli HGETALL BO:Odds:BTC-USDT

# 预期输出
# 1) "1:UP"
# 2) "1.95"
# 3) "1:DOWN"
# 4) "1.90"
# 5) "3:UP"
# 6) "1.95"
# 7) "3:DOWN"
# 8) "1.90"
# ...
```

### 8.2 行情 WebSocket 验证

```bash
wscat -c ws://localhost:8083/ws/market
> {"action":"subscribe","symbols":["BTC-USDT"]}

# 检查返回的 odds 数组，应该包含不同的 upOdds 和 downOdds
# {
#   "symbol": "BTC-USDT",
#   "odds": [
#     {"duration": 1, "upOdds": 1.95, "downOdds": 1.90},
#     {"duration": 3, "upOdds": 1.95, "downOdds": 1.90},
#     ...
#   ]
# }
```

### 8.3 下单验证

```bash
# 看涨订单
curl -X POST http://localhost:8082/api/orders/create \
  -H "Content-Type: application/json" \
  -d '{"symbol":"BTC-USDT","direction":"UP","amount":100,"duration":5}'
# 预期: odds = 1.95

# 看跌订单
curl -X POST http://localhost:8082/api/orders/create \
  -H "Content-Type: application/json" \
  -d '{"symbol":"BTC-USDT","direction":"DOWN","amount":100,"duration":5}'
# 预期: odds = 1.90
```

---

## 9. 后续工作

完成本预备工作后，接入动态赔率只需修改 `OddsService.refreshOddsToRedis()`：

```java
// 当前 (固定赔率，UP/DOWN 相同)
BigDecimal baseOdds = config.getBaseOdds();
BigDecimal upOdds = baseOdds;
BigDecimal downOdds = baseOdds;

// 后续 (动态赔率，UP/DOWN 不同)
OddsPair dynamicOdds = oddsCalculatorService.calcOdds(symbol, duration);
if (dynamicOdds != null) {
    upOdds = dynamicOdds.getUpOdds();
    downOdds = dynamicOdds.getDownOdds();
}
oddsMap.put(duration + ":UP", upOdds.toPlainString());
oddsMap.put(duration + ":DOWN", downOdds.toPlainString());
```

**参考文档：** [12. 赔率计算模块调用(方案).md](./12.%20赔率计算模块调用(方案).md)
