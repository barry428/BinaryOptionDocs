# 二元期权平台技术实现（BTSE集成篇）

## 1. BTSE API统一管理 **[v1.7新增]**

### 1.1 设计背景

为了更好地管理与BTSE的所有交互，我们将所有BTSE API调用统一管理，包括：
- **用户认证**：登录状态验证、用户信息获取
- **赔率计算**：实时赔率获取、动态调整
- **资金划转**：充值、提现、自动划转
- **行情数据**：价格推送、K线数据

### 1.2 统一API客户端设计

#### 1.2.1 BTSE API客户端接口

```java
@Component
public interface BtseApiClient {
    // ========== 用户认证相关 ==========
    // 验证用户登录状态
    BtseAuthResponse verifyUserAuth(String externalUserId, String token);
    
    // 获取用户信息
    BtseUserInfo getUserInfo(String externalUserId);
    
    // 刷新用户Token
    BtseTokenResponse refreshToken(String refreshToken);
    
    // ========== 赔率计算相关 ==========
    // 获取实时赔率
    BtseOddsResponse getCurrentOdds(String symbol, Integer duration);
    
    // 获取历史赔率
    List<BtseOddsHistory> getOddsHistory(String symbol, LocalDateTime start, LocalDateTime end);
    
    // ========== 资金管理相关 ==========
    // 查询用户BTSE余额
    BtseBalanceResponse getBalance(String userId, String currency);
    
    // 执行资金划转
    BtseTransferResponse transfer(BtseTransferRequest request);
    
    // 查询划转状态
    BtseTransferStatus getTransferStatus(String transferId);
    
    // ========== 行情数据相关 ==========
    // 订阅实时行情
    void subscribeMarketData(String symbol, MarketDataCallback callback);
    
    // 获取K线数据
    List<BtseKlineData> getKlineData(String symbol, String interval, Integer limit);
}
```

#### 1.2.2 BTSE API客户端实现

```java
@Component
@Slf4j
public class BtseApiClientImpl implements BtseApiClient {
    
    @Autowired
    private RestTemplate restTemplate;
    
    @Autowired
    private BtseConfig btseConfig;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    // ========== 用户认证相关实现 ==========
    
    @Override
    @BtseApiCall
    public BtseAuthResponse verifyUserAuth(String externalUserId, String token) {
        String url = btseConfig.getBaseUrl() + “/api/v1/user/verify“;
        
        HttpHeaders headers = createAuthHeaders();
        headers.setBearerAuth(token);
        
        Map<String, Object> requestBody = Map.of(“userId“, externalUserId);
        HttpEntity<Map<String, Object>> entity = new HttpEntity<>(requestBody, headers);
        
        try {
            ResponseEntity<BtseAuthResponse> response = restTemplate.postForEntity(
                url, entity, BtseAuthResponse.class);
            
            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                return response.getBody();
            } else {
                throw new BtseApiException(“AUTH_FAILED“, “BTSE用户认证失败“);
            }
        } catch (Exception e) {
            log.error(“BTSE auth verification failed: userId={}“, externalUserId, e);
            throw new BtseApiException(“AUTH_FAILED“, “BTSE认证服务异常“);
        }
    }
    
    @Override
    @BtseApiCall
    public BtseUserInfo getUserInfo(String externalUserId) {
        String url = btseConfig.getBaseUrl() + “/api/v1/user/info/“ + externalUserId;
        
        HttpHeaders headers = createAuthHeaders();
        HttpEntity<Void> entity = new HttpEntity<>(headers);
        
        try {
            ResponseEntity<BtseUserInfo> response = restTemplate.exchange(
                url, HttpMethod.GET, entity, BtseUserInfo.class);
            
            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                return response.getBody();
            } else {
                throw new BtseApiException(“USER_NOT_FOUND“, “BTSE用户不存在“);
            }
        } catch (Exception e) {
            log.error(“Get BTSE user info failed: userId={}“, externalUserId, e);
            throw new BtseApiException(“SERVICE_ERROR“, “获取用户信息失败“);
        }
    }
    
    // ========== 赔率计算相关实现 ==========
    
    @Override
    @BtseApiCall
    @Cacheable(value = “btse_odds“, key = “#symbol + '_' + #duration“, unless = “#result == null“)
    public BtseOddsResponse getCurrentOdds(String symbol, Integer duration) {
        String url = btseConfig.getBaseUrl() + “/api/v1/odds/current“;
        
        HttpHeaders headers = createAuthHeaders();
        
        Map<String, Object> params = Map.of(
            “symbol“, symbol,
            “duration“, duration
        );
        
        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(url);
        params.forEach(builder::queryParam);
        
        HttpEntity<Void> entity = new HttpEntity<>(headers);
        
        try {
            ResponseEntity<BtseOddsResponse> response = restTemplate.exchange(
                builder.toUriString(), HttpMethod.GET, entity, BtseOddsResponse.class);
            
            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                return response.getBody();
            } else {
                throw new BtseApiException(“ODDS_NOT_AVAILABLE“, “无法获取实时赔率“);
            }
        } catch (Exception e) {
            log.error(“Get BTSE odds failed: symbol={}, duration={}“, symbol, duration, e);
            throw new BtseApiException(“SERVICE_ERROR“, “获取赔率失败“);
        }
    }
    
    // ========== 资金管理相关实现 ==========
    
    @Override
    @BtseApiCall
    public BtseBalanceResponse getBalance(String userId, String currency) {
        String url = btseConfig.getBaseUrl() + “/api/v1/user/balance“;
        
        HttpHeaders headers = createAuthHeaders();
        
        Map<String, Object> params = Map.of(
            “userId“, userId,
            “currency“, currency
        );
        
        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(url);
        params.forEach(builder::queryParam);
        
        HttpEntity<Void> entity = new HttpEntity<>(headers);
        
        try {
            ResponseEntity<BtseBalanceResponse> response = restTemplate.exchange(
                builder.toUriString(), HttpMethod.GET, entity, BtseBalanceResponse.class);
            
            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                return response.getBody();
            } else {
                throw new BtseApiException(“BALANCE_QUERY_FAILED“, “查询余额失败“);
            }
        } catch (Exception e) {
            log.error(“Get BTSE balance failed: userId={}, currency={}“, userId, currency, e);
            throw new BtseApiException(“SERVICE_ERROR“, “查询余额异常“);
        }
    }
    
    @Override
    @BtseApiCall
    public BtseTransferResponse transfer(BtseTransferRequest request) {
        String url = btseConfig.getBaseUrl() + “/api/v1/transfer“;
        
        HttpHeaders headers = createAuthHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        
        HttpEntity<BtseTransferRequest> entity = new HttpEntity<>(request, headers);
        
        try {
            ResponseEntity<BtseTransferResponse> response = restTemplate.postForEntity(
                url, entity, BtseTransferResponse.class);
            
            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                BtseTransferResponse transferResponse = response.getBody();
                
                // 记录转账日志
                recordTransferLog(request, transferResponse);
                
                return transferResponse;
            } else {
                throw new BtseApiException(“TRANSFER_FAILED“, “BTSE划转失败“);
            }
        } catch (Exception e) {
            log.error(“BTSE transfer failed: request={}“, request, e);
            recordTransferError(request, e);
            throw new BtseApiException(“TRANSFER_ERROR“, “划转异常: “ + e.getMessage());
        }
    }
    
    // ========== 辅助方法 ==========
    
    private HttpHeaders createAuthHeaders() {
        HttpHeaders headers = new HttpHeaders();
        headers.set(“X-API-KEY“, btseConfig.getApiKey());
        headers.set(“X-API-SECRET“, btseConfig.getApiSecret());
        headers.set(“Content-Type“, “application/json“);
        return headers;
    }
    
    private void recordTransferLog(BtseTransferRequest request, BtseTransferResponse response) {
        BtseTransferLog log = BtseTransferLog.builder()
            .userId(request.getUserId())
            .direction(request.getDirection())
            .amount(request.getAmount())
            .currency(request.getCurrency())
            .transferId(response.getTransferId())
            .status(response.isSuccess() ? “SUCCESS“ : “FAILED“)
            .requestTime(LocalDateTime.now())
            .responseTime(LocalDateTime.now())
            .build();
        
        // 异步记录日志
        transferLogService.saveAsync(log);
    }
    
    private void recordTransferError(BtseTransferRequest request, Exception error) {
        BtseTransferLog log = BtseTransferLog.builder()
            .userId(request.getUserId())
            .direction(request.getDirection())
            .amount(request.getAmount())
            .currency(request.getCurrency())
            .status(“ERROR“)
            .errorMessage(error.getMessage())
            .requestTime(LocalDateTime.now())
            .build();
        
        transferLogService.saveAsync(log);
    }
}
```

### 1.3 统一配置管理

```yaml
btse:
  api:
    base-url: https://api.btse.com
    websocket-url: wss://ws.btse.com
    auth:
      api-key: ${BTSE_API_KEY}
      api-secret: ${BTSE_API_SECRET}
    timeout:
      connect: 5000
      read: 10000
    retry:
      max-attempts: 3
      delay: 1000
    rate-limit:
      requests-per-second: 10
      burst-capacity: 20
```

```java
@Configuration
@ConfigurationProperties(prefix = “btse.api“)
@Data
public class BtseConfig {
    private String baseUrl;
    private String websocketUrl;
    private Auth auth;
    private Timeout timeout;
    private Retry retry;
    private RateLimit rateLimit;
    
    @Data
    public static class Auth {
        private String apiKey;
        private String apiSecret;
    }
    
    @Data
    public static class Timeout {
        private int connect;
        private int read;
    }
    
    @Data
    public static class Retry {
        private int maxAttempts;
        private long delay;
    }
    
    @Data
    public static class RateLimit {
        private int requestsPerSecond;
        private int burstCapacity;
    }
}
```

### 1.4 统一异常处理

```java
@Component
public class BtseApiExceptionHandler {
    
    @ExceptionHandler(BtseApiException.class)
    public ApiResponse<Void> handleBtseApiException(BtseApiException e) {
        log.error(“BTSE API调用失败: {}“, e.getMessage(), e);
        
        return switch (e.getErrorCode()) {
            case “AUTH_FAILED“ -> ApiResponse.error(401, “BTSE认证失败“);
            case “INSUFFICIENT_BALANCE“ -> ApiResponse.error(400, “BTSE余额不足“);
            case “RATE_LIMIT“ -> ApiResponse.error(429, “请求过于频繁“);
            case “SERVICE_UNAVAILABLE“ -> ApiResponse.error(503, “BTSE服务暂时不可用“);
            case “TRANSFER_FAILED“ -> ApiResponse.error(500, “BTSE划转失败“);
            default -> ApiResponse.error(500, “BTSE服务异常“);
        };
    }
}

@Getter
public class BtseApiException extends RuntimeException {
    private final String errorCode;
    
    public BtseApiException(String errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }
    
    public BtseApiException(String errorCode, String message, Throwable cause) {
        super(message, cause);
        this.errorCode = errorCode;
    }
}
```

## 2. 用户认证集成 **[v1.7新增]**

### 2.1 登录流程改造

```java
@Service
public class UserAuthService {
    
    @Autowired
    private BtseApiClient btseApiClient;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private AccountService accountService;
    
    @Autowired
    private JwtUtil jwtUtil;
    
    public LoginResponse login(LoginRequest request) {
        try {
            // 1. 验证BTSE用户登录状态
            BtseAuthResponse authResponse = btseApiClient.verifyUserAuth(
                request.getExternalUserId(), 
                request.getBtseToken()
            );
            
            if (!authResponse.isValid()) {
                throw new AuthenticationException(“BTSE认证失败“);
            }
            
            // 2. 获取或创建本地用户
            User user = userRepository.findByExternalId(request.getExternalUserId())
                .orElseGet(() -> createUserFromBtse(authResponse));
            
            // 3. 检查用户状态
            if (user.getStatus() != 1) {
                throw new AuthenticationException(“用户账户已被禁用“);
            }
            
            // 4. 生成本地JWT Token
            String jwtToken = jwtUtil.generateToken(user);
            
            // 5. 更新登录时间和Token缓存
            updateLoginInfo(user, request.getBtseToken());
            
            return LoginResponse.builder()
                .userId(user.getId())
                .externalId(user.getExternalId())
                .token(jwtToken)
                .nickname(user.getNickname())
                .email(user.getEmail())
                .btseUserInfo(authResponse.getUserInfo())
                .build();
                
        } catch (BtseApiException e) {
            log.error(“BTSE authentication failed: userId={}“, request.getExternalUserId(), e);
            throw new AuthenticationException(“BTSE认证服务异常，请稍后重试“);
        }
    }
    
    private User createUserFromBtse(BtseAuthResponse authResponse) {
        BtseUserInfo userInfo = authResponse.getUserInfo();
        
        User user = new User();
        user.setExternalId(userInfo.getUserId());
        user.setNickname(userInfo.getNickname());
        user.setEmail(userInfo.getEmail());
        user.setPhone(userInfo.getPhone());
        user.setStatus(1); // 默认正常状态
        user.setCreateTime(LocalDateTime.now());
        user.setUpdateTime(LocalDateTime.now());
        
        user = userRepository.save(user);
        
        // 创建默认账户
        accountService.createDefaultAccounts(user.getId());
        
        log.info(“Created new user from BTSE: userId={}, externalId={}“, 
            user.getId(), user.getExternalId());
        
        return user;
    }
    
    private void updateLoginInfo(User user, String btseToken) {
        // 更新最后登录时间
        user.setUpdateTime(LocalDateTime.now());
        userRepository.save(user);
        
        // 缓存BTSE Token用于后续API调用
        String tokenKey = “btse_token:“ + user.getExternalId();
        redisTemplate.opsForValue().set(tokenKey, btseToken, Duration.ofHours(24));
    }
}
```

### 2.2 Token刷新机制

```java
@Component
public class BtseTokenRefreshScheduler {
    
    @Autowired
    private BtseApiClient btseApiClient;
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Autowired
    private UserRepository userRepository;
    
    @Scheduled(fixedDelay = 3600000) // 每小时执行一次
    public void refreshExpiredTokens() {
        log.info(“Starting BTSE token refresh task“);
        
        // 获取所有活跃用户的Token
        Set<String> tokenKeys = redisTemplate.keys(“btse_token:*“);
        
        for (String tokenKey : tokenKeys) {
            String externalUserId = tokenKey.replace(“btse_token:“, ““);
            
            try {
                refreshUserToken(externalUserId);
            } catch (Exception e) {
                log.error(“刷新BTSE Token失败: externalUserId={}“, externalUserId, e);
                
                // 刷新失败，清除缓存
                redisTemplate.delete(tokenKey);
            }
        }
        
        log.info(“BTSE token refresh task completed“);
    }
    
    private void refreshUserToken(String externalUserId) {
        String tokenKey = “btse_token:“ + externalUserId;
        String refreshTokenKey = “btse_refresh_token:“ + externalUserId;
        
        String refreshToken = redisTemplate.opsForValue().get(refreshTokenKey);
        if (refreshToken == null) {
            log.warn(“No refresh token found for user: {}“, externalUserId);
            return;
        }
        
        try {
            BtseTokenResponse newToken = btseApiClient.refreshToken(refreshToken);
            
            if (newToken.isSuccess()) {
                // 更新缓存中的Token
                redisTemplate.opsForValue().set(tokenKey, newToken.getAccessToken(), Duration.ofHours(24));
                redisTemplate.opsForValue().set(refreshTokenKey, newToken.getRefreshToken(), Duration.ofDays(30));
                
                log.info(“Successfully refreshed BTSE token for user: {}“, externalUserId);
            } else {
                log.warn(“BTSE token refresh failed for user: {}, reason: {}“, 
                    externalUserId, newToken.getMessage());
            }
        } catch (BtseApiException e) {
            log.error(“BTSE token refresh API error for user: {}“, externalUserId, e);
            throw e;
        }
    }
}
```

## 3. 赔率计算集成 **[v1.7新增]**

### 3.1 实时赔率获取

```java
@Service
public class OddsCalculationService {
    
    @Autowired
    private BtseApiClient btseApiClient;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private DurationConfigRepository durationConfigRepository;
    
    public BigDecimal calculateOdds(String symbol, Integer duration) {
        // 1. 尝试从缓存获取
        String cacheKey = String.format(“odds:%s:%d“, symbol, duration);
        BigDecimal cachedOdds = (BigDecimal) redisTemplate.opsForValue().get(cacheKey);
        
        if (cachedOdds != null) {
            return cachedOdds;
        }
        
        try {
            // 2. 从BTSE获取实时赔率
            BtseOddsResponse oddsResponse = btseApiClient.getCurrentOdds(symbol, duration);
            
            // 3. 应用本地调整策略
            BigDecimal adjustedOdds = applyLocalAdjustment(oddsResponse.getBaseOdds(), symbol, duration);
            
            // 4. 缓存赔率（5秒过期）
            redisTemplate.opsForValue().set(cacheKey, adjustedOdds, Duration.ofSeconds(5));
            
            return adjustedOdds;
            
        } catch (BtseApiException e) {
            log.warn(“Failed to get odds from BTSE, using fallback: symbol={}, duration={}“, 
                symbol, duration, e);
            
            // 降级策略：使用本地配置的默认赔率
            return getFallbackOdds(symbol, duration);
        }
    }
    
    private BigDecimal applyLocalAdjustment(BigDecimal baseOdds, String symbol, Integer duration) {
        // 获取本地配置的调整参数
        DurationConfig config = durationConfigRepository.findByDurationMinutes(duration);
        
        if (config == null) {
            return baseOdds;
        }
        
        // 应用手续费率调整
        BigDecimal adjustedOdds = baseOdds.multiply(BigDecimal.ONE.subtract(config.getFeeRate()));
        
        // 应用本地赔率配置
        if (config.getBaseOdds() != null) {
            adjustedOdds = adjustedOdds.multiply(config.getBaseOdds()).divide(new BigDecimal(“1.9“), 4, RoundingMode.HALF_UP);
        }
        
        // 确保赔率在合理范围内
        BigDecimal minOdds = new BigDecimal(“1.1“);
        BigDecimal maxOdds = new BigDecimal(“2.5“);
        
        if (adjustedOdds.compareTo(minOdds) < 0) {
            adjustedOdds = minOdds;
        } else if (adjustedOdds.compareTo(maxOdds) > 0) {
            adjustedOdds = maxOdds;
        }
        
        return adjustedOdds;
    }
    
    private BigDecimal getFallbackOdds(String symbol, Integer duration) {
        DurationConfig config = durationConfigRepository.findByDurationMinutes(duration);
        return config != null ? config.getBaseOdds() : new BigDecimal(“1.9“);
    }
}
```

### 3.2 赔率推送服务

```java
@Component
public class OddsPushService {
    
    @Autowired
    private OddsCalculationService oddsCalculationService;
    
    @Autowired
    private SymbolConfigRepository symbolConfigRepository;
    
    @Autowired
    private DurationConfigRepository durationConfigRepository;
    
    @Autowired
    private WebSocketService webSocketService;
    
    @EventListener
    public void onMarketDataUpdate(MarketDataEvent event) {
        // 当市场数据更新时，重新计算并推送赔率
        List<SymbolConfig> activeSymbols = symbolConfigRepository.findByEnabled(true);
        
        for (SymbolConfig symbol : activeSymbols) {
            List<DurationConfig> durations = durationConfigRepository.findByEnabled(true);
            
            for (DurationConfig duration : durations) {
                try {
                    BigDecimal newOdds = oddsCalculationService.calculateOdds(
                        symbol.getSymbol(), duration.getDurationMinutes());
                    
                    // 推送给订阅的客户端
                    OddsUpdateMessage message = OddsUpdateMessage.builder()
                        .type(“odds_update“)
                        .symbol(symbol.getSymbol())
                        .duration(duration.getDurationMinutes())
                        .odds(newOdds)
                        .timestamp(System.currentTimeMillis())
                        .build();
                    
                    String topic = “/topic/odds/“ + symbol.getSymbol();
                    webSocketService.broadcast(topic, message);
                    
                } catch (Exception e) {
                    log.error(“Failed to calculate and push odds: symbol={}, duration={}“, 
                        symbol.getSymbol(), duration.getDurationMinutes(), e);
                }
            }
        }
    }
    
    @Scheduled(fixedDelay = 10000) // 每10秒执行一次
    public void scheduledOddsUpdate() {
        onMarketDataUpdate(new MarketDataEvent(“SCHEDULED_UPDATE“));
    }
}
```

## 4. BTSE直接划转集成 **[v1.6新增]**

### 4.1 设计目标

- **简化用户操作**：无需预先充值，下单时自动从BTSE划转
- **资金安全**：盈利自动返回BTSE，减少平台资金沉淀
- **原子性保证**：划转失败则下单失败，确保资金一致性

### 4.2 下单流程改造

```java
@Service
@Transactional(rollbackFor = Exception.class)
public class OrderService {
    
    @Autowired
    private BtseApiClient btseApiClient;
    
    @Autowired
    private AccountService accountService;
    
    @Autowired
    private RiskControlService riskControlService;
    
    public OrderResponse createOrder(OrderRequest request) {
        // 1. 风控校验
        RiskCheckResult riskResult = riskControlService.checkBetLimit(
            request.getUserId(), request.getAmount(), request.getAccountType());
        
        if (!riskResult.isPass()) {
            throw new BusinessException(400, riskResult.getMessage());
        }
        
        // 2. 查询BTSE余额（v1.6新增）
        BtseBalanceResponse btseBalance = btseApiClient.getBalance(
            request.getExternalUserId(), “USDT“
        );
        
        if (btseBalance.getAvailable().compareTo(request.getAmount()) < 0) {
            throw new InsufficientBalanceException(“BTSE余额不足“);
        }
        
        // 3. 执行BTSE转入（v1.6新增）
        BtseTransferRequest transferIn = BtseTransferRequest.builder()
            .userId(request.getExternalUserId())
            .direction(“IN“)
            .amount(request.getAmount())
            .currency(“USDT“)
            .orderId(generateOrderId())
            .reason(“下单资金转入“)
            .build();
            
        BtseTransferResponse transferResult = btseApiClient.transfer(transferIn);
        
        if (!transferResult.isSuccess()) {
            throw new TransferFailedException(“BTSE划转失败: “ + transferResult.getMessage());
        }
        
        try {
            // 4. 增加平台账户余额
            accountService.addBalance(request.getUserId(), request.getAmount(), 
                “BTSE转入“, transferResult.getTransferId());
            
            // 5. 冻结资金
            accountService.freezeBalance(request.getUserId(), request.getAmount());
            
            // 6. 创建订单
            Order order = buildOrder(request);
            order.setBtseTransferId(transferResult.getTransferId());
            order = orderRepository.save(order);
            
            // 7. 更新风控使用量
            riskControlService.updateBetLimitUsage(request.getUserId(), request.getAmount());
            
            return OrderResponse.success(order);
            
        } catch (Exception e) {
            log.error(“Order creation failed after BTSE transfer, need manual reconciliation: transferId={}“, 
                transferResult.getTransferId(), e);
            
            // 记录需要人工处理的转账
            recordPendingReconciliation(transferResult, request, e);
            
            throw new BusinessException(500, “订单创建失败，资金已转入，请联系客服处理“);
        }
    }
    
    private void recordPendingReconciliation(BtseTransferResponse transfer, OrderRequest request, Exception error) {
        PendingReconciliation reconciliation = PendingReconciliation.builder()
            .transferId(transfer.getTransferId())
            .userId(request.getUserId())
            .externalUserId(request.getExternalUserId())
            .amount(request.getAmount())
            .direction(“IN“)
            .status(“PENDING“)
            .errorMessage(error.getMessage())
            .createTime(LocalDateTime.now())
            .build();
        
        pendingReconciliationRepository.save(reconciliation);
        
        // 发送告警
        alertService.sendAlert(“TRANSFER_RECONCILIATION_NEEDED“, reconciliation.getId());
    }
}
```

### 4.3 结算流程改造

```java
@Service
public class OrderSettlementService {
    
    @Autowired
    private BtseApiClient btseApiClient;
    
    @Autowired
    private AccountService accountService;
    
    public void settleOrder(Order order) {
        try {
            // 1. 计算盈亏
            BigDecimal profit = calculateProfit(order);
            
            if (profit.compareTo(BigDecimal.ZERO) > 0) {
                // 盈利场景：派奖并转回BTSE
                settleWinOrder(order, profit);
            } else if (profit.compareTo(BigDecimal.ZERO) == 0) {
                // 平局场景：退还本金并转回BTSE
                settleDrawOrder(order);
            } else {
                // 亏损场景：扣除冻结资金，资金留在平台
                settleLoseOrder(order, profit);
            }
            
        } catch (Exception e) {
            log.error(“Order settlement failed: orderId={}“, order.getId(), e);
            order.setStatus(“SETTLEMENT_FAILED“);
            orderRepository.save(order);
            
            // 发送告警
            alertService.sendAlert(“ORDER_SETTLEMENT_FAILED“, order.getId());
        }
    }
    
    private void settleWinOrder(Order order, BigDecimal profit) {
        // 1. 计算手续费和净盈利
        BigDecimal fee = profit.multiply(new BigDecimal(“0.1“)); // 10%手续费
        BigDecimal netProfit = profit.subtract(fee);
        BigDecimal totalAmount = order.getAmount().add(netProfit); // 本金 + 净盈利
        
        // 2. 解冻资金并派奖
        accountService.unfreezeAndCredit(order.getUserId(), order.getAmount(), totalAmount);
        
        // 3. 自动转出到BTSE（v1.6新增）
        BtseTransferRequest transferOut = BtseTransferRequest.builder()
            .userId(order.getExternalUserId())
            .direction(“OUT“)
            .amount(totalAmount)
            .currency(“USDT“)
            .orderId(order.getId())
            .reason(“盈利资金转出“)
            .build();
            
        try {
            BtseTransferResponse transferResult = btseApiClient.transfer(transferOut);
            
            if (transferResult.isSuccess()) {
                // 4. 扣减平台账户余额
                accountService.deductBalance(order.getUserId(), totalAmount, 
                    “BTSE转出“, transferResult.getTransferId());
                
                // 5. 更新订单状态
                order.setStatus(“WIN“);
                order.setProfit(netProfit);
                order.setFee(fee);
                order.setBtseTransferOutId(transferResult.getTransferId());
                order.setSettleTime(LocalDateTime.now());
                orderRepository.save(order);
                
            } else {
                // 转出失败，记录异常待人工处理
                handleTransferOutFailure(order, transferOut, “盈利转出失败“);
            }
        } catch (BtseApiException e) {
            handleTransferOutFailure(order, transferOut, e.getMessage());
        }
    }
    
    private void settleDrawOrder(Order order) {
        // 1. 退还冻结资金
        accountService.unfreezeAndCredit(order.getUserId(), order.getAmount(), order.getAmount());
        
        // 2. 自动转出到BTSE
        BtseTransferRequest transferOut = BtseTransferRequest.builder()
            .userId(order.getExternalUserId())
            .direction(“OUT“)
            .amount(order.getAmount())
            .currency(“USDT“)
            .orderId(order.getId())
            .reason(“平局本金转出“)
            .build();
            
        try {
            BtseTransferResponse transferResult = btseApiClient.transfer(transferOut);
            
            if (transferResult.isSuccess()) {
                accountService.deductBalance(order.getUserId(), order.getAmount(), 
                    “BTSE转出“, transferResult.getTransferId());
                
                order.setStatus(“DRAW“);
                order.setProfit(BigDecimal.ZERO);
                order.setFee(BigDecimal.ZERO);
                order.setBtseTransferOutId(transferResult.getTransferId());
                order.setSettleTime(LocalDateTime.now());
                orderRepository.save(order);
                
            } else {
                handleTransferOutFailure(order, transferOut, “平局转出失败“);
            }
        } catch (BtseApiException e) {
            handleTransferOutFailure(order, transferOut, e.getMessage());
        }
    }
    
    private void settleLoseOrder(Order order, BigDecimal profit) {
        // 亏损场景：扣除冻结资金，不转出（资金已在平台）
        accountService.deductFrozenBalance(order.getUserId(), order.getAmount());
        
        order.setStatus(“LOSE“);
        order.setProfit(profit); // 负数
        order.setFee(BigDecimal.ZERO);
        order.setSettleTime(LocalDateTime.now());
        orderRepository.save(order);
    }
    
    private void handleTransferOutFailure(Order order, BtseTransferRequest transferRequest, String errorMessage) {
        log.error(“BTSE转出失败，订单ID: {}, 错误: {}“, order.getId(), errorMessage);
        
        // 记录转出失败，待人工处理
        PendingReconciliation reconciliation = PendingReconciliation.builder()
            .orderId(order.getId())
            .transferId(null)
            .userId(order.getUserId())
            .externalUserId(order.getExternalUserId())
            .amount(transferRequest.getAmount())
            .direction(“OUT“)
            .status(“FAILED“)
            .errorMessage(errorMessage)
            .createTime(LocalDateTime.now())
            .build();
        
        pendingReconciliationRepository.save(reconciliation);
        
        // 更新订单状态为转出失败
        order.setStatus(order.getStatus() + “_TRANSFER_FAILED“);
        orderRepository.save(order);
        
        // 发送告警
        alertService.sendAlert(“BTSE_TRANSFER_OUT_FAILED“, order.getId());
    }
}
```

## 5. 监控与容错

### 5.1 API调用监控

```java
@Aspect
@Component
public class BtseApiMonitorAspect {
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    @Around(“@annotation(BtseApiCall)“)
    public Object monitorApiCall(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().getName();
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            Object result = joinPoint.proceed();
            
            // 记录成功调用
            meterRegistry.counter(“btse.api.calls“, “method“, methodName, “status“, “success“).increment();
            
            return result;
        } catch (Exception e) {
            // 记录失败调用
            meterRegistry.counter(“btse.api.calls“, “method“, methodName, “status“, “error“).increment();
            
            // 发送告警
            if (isCritical(methodName)) {
                alertService.sendAlert(“BTSE_API_FAILURE“, methodName, e.getMessage());
            }
            
            throw e;
        } finally {
            sample.stop(Timer.builder(“btse.api.duration“)
                .description(“BTSE API call duration“)
                .tag(“method“, methodName)
                .register(meterRegistry));
        }
    }
    
    private boolean isCritical(String methodName) {
        return Set.of(“transfer“, “getBalance“, “verifyUserAuth“).contains(methodName);
    }
}
```

### 5.2 降级策略

```java
@Component
public class BtseApiFallbackService {
    
    @Autowired
    private DurationConfigRepository durationConfigRepository;
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @HystrixCommand(fallbackMethod = “getOddsFallback“)
    public BigDecimal getOdds(String symbol, Integer duration) {
        return btseApiClient.getCurrentOdds(symbol, duration).getBaseOdds();
    }
    
    public BigDecimal getOddsFallback(String symbol, Integer duration) {
        // 降级策略：使用本地配置的默认赔率
        DurationConfig config = durationConfigRepository.findByDurationMinutes(duration);
        return config != null ? config.getBaseOdds() : new BigDecimal(“1.9“);
    }
    
    @HystrixCommand(fallbackMethod = “verifyAuthFallback“)
    public boolean verifyUserAuth(String userId, String token) {
        return btseApiClient.verifyUserAuth(userId, token).isValid();
    }
    
    public boolean verifyAuthFallback(String userId, String token) {
        // 降级策略：检查本地缓存的认证状态
        String authKey = “auth_cache:“ + userId;
        String cachedAuth = redisTemplate.opsForValue().get(authKey);
        
        // 如果缓存中有效，允许通过（但时间较短）
        return cachedAuth != null && “valid“.equals(cachedAuth);
    }
}
```

### 5.3 补偿机制

```java
@Component
public class BtseReconciliationService {
    
    @Autowired
    private PendingReconciliationRepository pendingReconciliationRepository;
    
    @Autowired
    private BtseApiClient btseApiClient;
    
    @Scheduled(fixedDelay = 300000) // 每5分钟执行一次
    public void processFailedTransfers() {
        List<PendingReconciliation> pendingList = pendingReconciliationRepository
            .findByStatusAndCreateTimeBefore(“PENDING“, LocalDateTime.now().minusMinutes(5));
        
        for (PendingReconciliation pending : pendingList) {
            try {
                // 重试BTSE转账
                BtseTransferRequest retryRequest = BtseTransferRequest.builder()
                    .userId(pending.getExternalUserId())
                    .direction(pending.getDirection())
                    .amount(pending.getAmount())
                    .currency(“USDT“)
                    .orderId(pending.getOrderId())
                    .reason(“补偿重试“)
                    .build();
                
                BtseTransferResponse response = btseApiClient.transfer(retryRequest);
                
                if (response.isSuccess()) {
                    pending.setStatus(“COMPLETED“);
                    pending.setTransferId(response.getTransferId());
                    pending.setCompletedTime(LocalDateTime.now());
                    pendingReconciliationRepository.save(pending);
                    
                    log.info(“Successfully reconciled transfer: id={}, transferId={}“, 
                        pending.getId(), response.getTransferId());
                } else {
                    pending.setRetryCount(pending.getRetryCount() + 1);
                    pending.setLastError(response.getMessage());
                    
                    if (pending.getRetryCount() >= 3) {
                        pending.setStatus(“FAILED“);
                        alertService.sendAlert(“TRANSFER_RECONCILIATION_FAILED“, pending.getId());
                    }
                    
                    pendingReconciliationRepository.save(pending);
                }
                
            } catch (Exception e) {
                log.error(“Failed to reconcile transfer: id={}“, pending.getId(), e);
                
                pending.setRetryCount(pending.getRetryCount() + 1);
                pending.setLastError(e.getMessage());
                
                if (pending.getRetryCount() >= 3) {
                    pending.setStatus(“FAILED“);
                    alertService.sendAlert(“TRANSFER_RECONCILIATION_FAILED“, pending.getId());
                }
                
                pendingReconciliationRepository.save(pending);
            }
        }
    }
}
```

## 6. BTSE API Mock方案

### 6.1 Mock设计原则

为便于开发和测试，设计BTSE API的Mock方案：

- **开发环境**：完全使用Mock数据，不依赖真实BTSE API
- **测试环境**：可配置使用Mock或真实API
- **生产环境**：仅使用真实BTSE API
- **数据真实性**：Mock数据尽可能模拟真实场景
- **异常模拟**：支持各种异常情况的模拟

### 6.2 Mock配置

```yaml
btse:
  mock:
    enabled: ${BTSE_MOCK_ENABLED:true}  # 开发环境默认启用Mock
    scenarios:
      auth-failure-rate: 0.05  # 5%认证失败率
      transfer-failure-rate: 0.02  # 2%转账失败率
      balance-insufficient-rate: 0.1  # 10%余额不足率
      api-timeout-rate: 0.01  # 1%API超时率
    delays:
      min-delay: 100  # 最小延迟(ms)
      max-delay: 1000  # 最大延迟(ms)
    test-users:
      # 预定义测试用户数据
      - external-id: "btse_test_001"
        balance: "10000.00"
        nickname: "测试用户001"
        email: "test001@btse.com"
      - external-id: "btse_test_002"
        balance: "50000.00"
        nickname: "测试用户002"
        email: "test002@btse.com"
      - external-id: "btse_poor_user"
        balance: "5.00"
        nickname: "余额不足用户"
        email: "poor@btse.com"
```

### 6.3 Mock实现

#### 6.3.1 Mock客户端实现

```java
@Component
@Profile({"dev", "test"})
@ConditionalOnProperty(name = "btse.mock.enabled", havingValue = "true")
@Slf4j
public class BtseMockApiClient implements BtseApiClient {
    
    @Autowired
    private BtseMockConfig mockConfig;
    
    @Autowired
    private BtseMockDataService mockDataService;
    
    // ========== 用户认证Mock ==========
    
    @Override
    public BtseAuthResponse verifyUserAuth(String externalUserId, String token) {
        simulateDelay();
        
        // 模拟认证失败
        if (shouldSimulateFailure("auth-failure-rate")) {
            throw new BtseApiException("AUTH_FAILED", "Mock: 用户认证失败");
        }
        
        // 特殊测试用户
        if ("btse_invalid_user".equals(externalUserId)) {
            return BtseAuthResponse.builder()
                .valid(false)
                .message("用户不存在")
                .build();
        }
        
        BtseUserInfo userInfo = mockDataService.getMockUserInfo(externalUserId);
        
        return BtseAuthResponse.builder()
            .valid(true)
            .message("认证成功")
            .userInfo(userInfo)
            .timestamp(System.currentTimeMillis())
            .build();
    }
    
    @Override
    public BtseUserInfo getUserInfo(String externalUserId) {
        simulateDelay();
        
        if (shouldSimulateFailure("api-timeout-rate")) {
            throw new BtseApiException("TIMEOUT", "Mock: API超时");
        }
        
        return mockDataService.getMockUserInfo(externalUserId);
    }
    
    @Override
    public BtseTokenResponse refreshToken(String refreshToken) {
        simulateDelay();
        
        return BtseTokenResponse.builder()
            .success(true)
            .accessToken("mock_access_token_" + System.currentTimeMillis())
            .refreshToken("mock_refresh_token_" + System.currentTimeMillis())
            .expiresAt(LocalDateTime.now().plusHours(24))
            .build();
    }
    
    // ========== 赔率计算Mock ==========
    
    @Override
    public BtseOddsResponse getCurrentOdds(String symbol, Integer duration) {
        simulateDelay();
        
        if (shouldSimulateFailure("api-timeout-rate")) {
            throw new BtseApiException("SERVICE_UNAVAILABLE", "Mock: 赔率服务不可用");
        }
        
        // 根据时间和交易对生成动态赔率
        BigDecimal baseOdds = generateDynamicOdds(symbol, duration);
        
        return BtseOddsResponse.builder()
            .symbol(symbol)
            .duration(duration)
            .baseOdds(baseOdds)
            .spread(new BigDecimal("0.05"))
            .timestamp(System.currentTimeMillis())
            .build();
    }
    
    @Override
    public List<BtseOddsHistory> getOddsHistory(String symbol, LocalDateTime start, LocalDateTime end) {
        simulateDelay();
        
        List<BtseOddsHistory> history = new ArrayList<>();
        LocalDateTime current = start;
        
        while (current.isBefore(end)) {
            BigDecimal odds = generateDynamicOdds(symbol, 5); // 5分钟周期
            
            history.add(BtseOddsHistory.builder()
                .symbol(symbol)
                .odds(odds)
                .timestamp(current)
                .build());
            
            current = current.plusMinutes(5);
        }
        
        return history;
    }
    
    // ========== 资金管理Mock ==========
    
    @Override
    public BtseBalanceResponse getBalance(String userId, String currency) {
        simulateDelay();
        
        if (shouldSimulateFailure("api-timeout-rate")) {
            throw new BtseApiException("TIMEOUT", "Mock: 查询余额超时");
        }
        
        BigDecimal balance = mockDataService.getMockBalance(userId, currency);
        
        return BtseBalanceResponse.builder()
            .userId(userId)
            .currency(currency)
            .available(balance)
            .frozen(new BigDecimal("100.00")) // 模拟100 USDT冻结
            .total(balance.add(new BigDecimal("100.00")))
            .timestamp(System.currentTimeMillis())
            .build();
    }
    
    @Override
    public BtseTransferResponse transfer(BtseTransferRequest request) {
        simulateDelay();
        
        // 模拟转账失败
        if (shouldSimulateFailure("transfer-failure-rate")) {
            return BtseTransferResponse.builder()
                .success(false)
                .transferId(null)
                .message("Mock: 转账失败 - 网络异常")
                .errorCode("NETWORK_ERROR")
                .timestamp(System.currentTimeMillis())
                .build();
        }
        
        // 模拟余额不足
        if (shouldSimulateFailure("balance-insufficient-rate") || 
            "btse_poor_user".equals(request.getUserId())) {
            return BtseTransferResponse.builder()
                .success(false)
                .transferId(null)
                .message("Mock: 余额不足")
                .errorCode("INSUFFICIENT_BALANCE")
                .timestamp(System.currentTimeMillis())
                .build();
        }
        
        // 更新Mock余额
        if ("IN".equals(request.getDirection())) {
            mockDataService.addMockBalance(request.getUserId(), request.getCurrency(), request.getAmount());
        } else {
            mockDataService.subtractMockBalance(request.getUserId(), request.getCurrency(), request.getAmount());
        }
        
        String transferId = "MOCK_TRANSFER_" + System.currentTimeMillis() + "_" + 
            RandomStringUtils.randomAlphanumeric(8);
        
        return BtseTransferResponse.builder()
            .success(true)
            .transferId(transferId)
            .message("转账成功")
            .actualAmount(request.getAmount())
            .fee(request.getAmount().multiply(new BigDecimal("0.001"))) // 0.1%手续费
            .timestamp(System.currentTimeMillis())
            .build();
    }
    
    @Override
    public BtseTransferStatus getTransferStatus(String transferId) {
        simulateDelay();
        
        // Mock转账ID都视为成功
        if (transferId.startsWith("MOCK_TRANSFER_")) {
            return BtseTransferStatus.builder()
                .transferId(transferId)
                .status("COMPLETED")
                .completedAt(LocalDateTime.now().minusMinutes(1))
                .build();
        }
        
        return BtseTransferStatus.builder()
            .transferId(transferId)
            .status("NOT_FOUND")
            .build();
    }
    
    // ========== 行情数据Mock ==========
    
    @Override
    public void subscribeMarketData(String symbol, MarketDataCallback callback) {
        // 启动Mock数据推送线程
        mockDataService.startMockMarketDataPush(symbol, callback);
    }
    
    @Override
    public List<BtseKlineData> getKlineData(String symbol, String interval, Integer limit) {
        simulateDelay();
        
        return mockDataService.generateMockKlineData(symbol, interval, limit);
    }
    
    // ========== 辅助方法 ==========
    
    private void simulateDelay() {
        try {
            int delay = ThreadLocalRandom.current().nextInt(
                mockConfig.getDelays().getMinDelay(),
                mockConfig.getDelays().getMaxDelay()
            );
            Thread.sleep(delay);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    private boolean shouldSimulateFailure(String rateConfigKey) {
        double rate = mockConfig.getScenarios().getOrDefault(rateConfigKey, 0.0);
        return Math.random() < rate;
    }
    
    private BigDecimal generateDynamicOdds(String symbol, Integer duration) {
        // 基于时间和交易对生成动态赔率
        long seed = System.currentTimeMillis() / 10000 + symbol.hashCode() + duration;
        Random random = new Random(seed);
        
        // 基础赔率在1.5-2.5之间波动
        double baseOdds = 1.5 + random.nextDouble() * 1.0;
        return BigDecimal.valueOf(baseOdds).setScale(4, RoundingMode.HALF_UP);
    }
}
```

#### 6.3.2 Mock数据服务

```java
@Service
@ConditionalOnProperty(name = "btse.mock.enabled", havingValue = "true")
@Slf4j
public class BtseMockDataService {
    
    @Autowired
    private BtseMockConfig mockConfig;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private final Map<String, ScheduledFuture<?>> marketDataTasks = new ConcurrentHashMap<>();
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(5);
    
    // 获取Mock用户信息
    public BtseUserInfo getMockUserInfo(String externalUserId) {
        // 先尝试从配置的测试用户中查找
        BtseMockConfig.TestUser testUser = mockConfig.getTestUsers().stream()
            .filter(user -> user.getExternalId().equals(externalUserId))
            .findFirst()
            .orElse(null);
        
        if (testUser != null) {
            return BtseUserInfo.builder()
                .userId(testUser.getExternalId())
                .nickname(testUser.getNickname())
                .email(testUser.getEmail())
                .phone("+1234567890")
                .verified(true)
                .kycLevel(2)
                .build();
        }
        
        // 生成默认Mock用户信息
        return BtseUserInfo.builder()
            .userId(externalUserId)
            .nickname("Mock用户_" + externalUserId.substring(Math.max(0, externalUserId.length() - 6)))
            .email("mock_" + externalUserId + "@btse.com")
            .phone("+1234567890")
            .verified(true)
            .kycLevel(1)
            .build();
    }
    
    // 获取Mock余额
    public BigDecimal getMockBalance(String userId, String currency) {
        String balanceKey = "mock_balance:" + userId + ":" + currency;
        String balance = (String) redisTemplate.opsForValue().get(balanceKey);
        
        if (balance != null) {
            return new BigDecimal(balance);
        }
        
        // 从配置的测试用户中获取初始余额
        BtseMockConfig.TestUser testUser = mockConfig.getTestUsers().stream()
            .filter(user -> user.getExternalId().equals(userId))
            .findFirst()
            .orElse(null);
        
        BigDecimal initialBalance = testUser != null ? 
            new BigDecimal(testUser.getBalance()) : new BigDecimal("10000.00");
        
        // 缓存到Redis
        redisTemplate.opsForValue().set(balanceKey, initialBalance.toString(), Duration.ofDays(1));
        
        return initialBalance;
    }
    
    // 增加Mock余额
    public void addMockBalance(String userId, String currency, BigDecimal amount) {
        String balanceKey = "mock_balance:" + userId + ":" + currency;
        BigDecimal currentBalance = getMockBalance(userId, currency);
        BigDecimal newBalance = currentBalance.add(amount);
        
        redisTemplate.opsForValue().set(balanceKey, newBalance.toString(), Duration.ofDays(1));
        
        log.info("Mock balance updated: userId={}, currency={}, +{}, balance={}", 
            userId, currency, amount, newBalance);
    }
    
    // 扣减Mock余额
    public void subtractMockBalance(String userId, String currency, BigDecimal amount) {
        String balanceKey = "mock_balance:" + userId + ":" + currency;
        BigDecimal currentBalance = getMockBalance(userId, currency);
        BigDecimal newBalance = currentBalance.subtract(amount);
        
        if (newBalance.compareTo(BigDecimal.ZERO) < 0) {
            newBalance = BigDecimal.ZERO;
        }
        
        redisTemplate.opsForValue().set(balanceKey, newBalance.toString(), Duration.ofDays(1));
        
        log.info("Mock balance updated: userId={}, currency={}, -{}, balance={}", 
            userId, currency, amount, newBalance);
    }
    
    // 生成Mock K线数据
    public List<BtseKlineData> generateMockKlineData(String symbol, String interval, Integer limit) {
        List<BtseKlineData> klineData = new ArrayList<>();
        
        long intervalMs = parseIntervalToMs(interval);
        long endTime = System.currentTimeMillis();
        long startTime = endTime - (limit * intervalMs);
        
        BigDecimal basePrice = getBasePriceForSymbol(symbol);
        Random random = new Random();
        
        for (int i = 0; i < limit; i++) {
            long openTime = startTime + (i * intervalMs);
            long closeTime = openTime + intervalMs - 1;
            
            // 生成随机价格波动
            double change = (random.nextDouble() - 0.5) * 0.02; // ±1%波动
            BigDecimal openPrice = basePrice.multiply(BigDecimal.valueOf(1 + change));
            
            double highChange = Math.abs(random.nextDouble()) * 0.01; // +0-1%
            double lowChange = -Math.abs(random.nextDouble()) * 0.01; // -0-1%
            
            BigDecimal highPrice = openPrice.multiply(BigDecimal.valueOf(1 + highChange));
            BigDecimal lowPrice = openPrice.multiply(BigDecimal.valueOf(1 + lowChange));
            
            double closeChange = (random.nextDouble() - 0.5) * 0.01; // ±0.5%
            BigDecimal closePrice = openPrice.multiply(BigDecimal.valueOf(1 + closeChange));
            
            BigDecimal volume = BigDecimal.valueOf(1000 + random.nextInt(9000)); // 1000-10000
            
            klineData.add(BtseKlineData.builder()
                .symbol(symbol)
                .interval(interval)
                .openTime(openTime)
                .closeTime(closeTime)
                .openPrice(openPrice.setScale(8, RoundingMode.HALF_UP))
                .highPrice(highPrice.setScale(8, RoundingMode.HALF_UP))
                .lowPrice(lowPrice.setScale(8, RoundingMode.HALF_UP))
                .closePrice(closePrice.setScale(8, RoundingMode.HALF_UP))
                .volume(volume.setScale(8, RoundingMode.HALF_UP))
                .build());
            
            basePrice = closePrice; // 下一根K线的基准价格
        }
        
        return klineData;
    }
    
    // 启动Mock行情数据推送
    public void startMockMarketDataPush(String symbol, MarketDataCallback callback) {
        String taskKey = symbol + "_" + callback.hashCode();
        
        // 避免重复启动
        if (marketDataTasks.containsKey(taskKey)) {
            return;
        }
        
        BigDecimal basePrice = getBasePriceForSymbol(symbol);
        AtomicReference<BigDecimal> currentPrice = new AtomicReference<>(basePrice);
        Random random = new Random();
        
        ScheduledFuture<?> task = scheduler.scheduleAtFixedRate(() -> {
            try {
                // 生成价格变动
                double change = (random.nextDouble() - 0.5) * 0.002; // ±0.1%波动
                BigDecimal newPrice = currentPrice.get().multiply(BigDecimal.valueOf(1 + change));
                currentPrice.set(newPrice);
                
                // 推送价格更新
                MarketDataUpdate update = MarketDataUpdate.builder()
                    .symbol(symbol)
                    .price(newPrice.setScale(8, RoundingMode.HALF_UP))
                    .volume(BigDecimal.valueOf(100 + random.nextInt(900)))
                    .timestamp(System.currentTimeMillis())
                    .build();
                
                callback.onMarketDataUpdate(update);
                
            } catch (Exception e) {
                log.error("Mock market data push failed for symbol: {}", symbol, e);
            }
        }, 1, 1, TimeUnit.SECONDS);
        
        marketDataTasks.put(taskKey, task);
        
        log.info("Started mock market data push for symbol: {}", symbol);
    }
    
    // 停止Mock行情数据推送
    public void stopMockMarketDataPush(String symbol, MarketDataCallback callback) {
        String taskKey = symbol + "_" + callback.hashCode();
        ScheduledFuture<?> task = marketDataTasks.remove(taskKey);
        
        if (task != null) {
            task.cancel(false);
            log.info("Stopped mock market data push for symbol: {}", symbol);
        }
    }
    
    // 辅助方法
    private BigDecimal getBasePriceForSymbol(String symbol) {
        return switch (symbol.toUpperCase()) {
            case "BTC/USDT", "BTCUSDT" -> new BigDecimal("45000.00");
            case "ETH/USDT", "ETHUSDT" -> new BigDecimal("3000.00");
            case "BNB/USDT", "BNBUSDT" -> new BigDecimal("400.00");
            default -> new BigDecimal("100.00");
        };
    }
    
    private long parseIntervalToMs(String interval) {
        return switch (interval.toLowerCase()) {
            case "1m" -> 60 * 1000L;
            case "5m" -> 5 * 60 * 1000L;
            case "15m" -> 15 * 60 * 1000L;
            case "1h" -> 60 * 60 * 1000L;
            case "1d" -> 24 * 60 * 60 * 1000L;
            default -> 60 * 1000L;
        };
    }
}
```

### 6.4 Mock配置类

```java
@Configuration
@ConfigurationProperties(prefix = "btse.mock")
@ConditionalOnProperty(name = "btse.mock.enabled", havingValue = "true")
@Data
public class BtseMockConfig {
    
    private boolean enabled = false;
    private Map<String, Double> scenarios = new HashMap<>();
    private Delays delays = new Delays();
    private List<TestUser> testUsers = new ArrayList<>();
    
    @Data
    public static class Delays {
        private int minDelay = 100;
        private int maxDelay = 1000;
    }
    
    @Data
    public static class TestUser {
        private String externalId;
        private String balance;
        private String nickname;
        private String email;
    }
}
```

### 6.5 测试场景配置

```java
@TestConfiguration
@Profile("test")
public class BtseMockTestConfig {
    
    @Bean
    @Primary
    public BtseApiClient testBtseApiClient() {
        return new BtseMockApiClient();
    }
    
    // 特殊测试场景Bean
    @Bean
    public BtseMockScenarios mockScenarios() {
        return new BtseMockScenarios();
    }
}

@Component
@ConditionalOnProperty(name = "btse.mock.enabled", havingValue = "true")
public class BtseMockScenarios {
    
    @Autowired
    private BtseApiClient btseApiClient;
    
    // 模拟认证失败场景
    public void simulateAuthFailure() {
        // 通过特殊用户ID触发认证失败
        try {
            btseApiClient.verifyUserAuth("btse_invalid_user", "invalid_token");
        } catch (BtseApiException e) {
            log.info("Successfully simulated auth failure: {}", e.getMessage());
        }
    }
    
    // 模拟余额不足场景
    public void simulateInsufficientBalance() {
        BtseTransferRequest request = BtseTransferRequest.builder()
            .userId("btse_poor_user")
            .direction("OUT")
            .amount(new BigDecimal("10000.00"))
            .currency("USDT")
            .build();
        
        BtseTransferResponse response = btseApiClient.transfer(request);
        assert !response.isSuccess();
        assert "INSUFFICIENT_BALANCE".equals(response.getErrorCode());
    }
    
    // 模拟网络异常场景
    public void simulateNetworkError() {
        // 通过配置高失败率触发网络异常
        for (int i = 0; i < 100; i++) {
            try {
                btseApiClient.getCurrentOdds("BTC/USDT", 5);
            } catch (BtseApiException e) {
                if ("TIMEOUT".equals(e.getErrorCode())) {
                    log.info("Successfully simulated network timeout");
                    break;
                }
            }
        }
    }
}
```

### 6.6 单元测试示例

```java
@SpringBootTest
@ActiveProfiles("test")
@TestPropertySource(properties = {
    "btse.mock.enabled=true",
    "btse.mock.scenarios.auth-failure-rate=0.0",
    "btse.mock.scenarios.transfer-failure-rate=0.0"
})
class BtseMockApiClientTest {
    
    @Autowired
    private BtseApiClient btseApiClient;
    
    @Autowired
    private BtseMockScenarios mockScenarios;
    
    @Test
    void testUserAuthSuccess() {
        BtseAuthResponse response = btseApiClient.verifyUserAuth("btse_test_001", "valid_token");
        
        assertThat(response.isValid()).isTrue();
        assertThat(response.getUserInfo()).isNotNull();
        assertThat(response.getUserInfo().getUserId()).isEqualTo("btse_test_001");
    }
    
    @Test
    void testUserAuthFailure() {
        assertThatThrownBy(() -> 
            btseApiClient.verifyUserAuth("btse_invalid_user", "invalid_token"))
            .isInstanceOf(BtseApiException.class)
            .hasMessageContaining("AUTH_FAILED");
    }
    
    @Test
    void testGetBalance() {
        BtseBalanceResponse response = btseApiClient.getBalance("btse_test_001", "USDT");
        
        assertThat(response.getAvailable()).isGreaterThan(BigDecimal.ZERO);
        assertThat(response.getCurrency()).isEqualTo("USDT");
        assertThat(response.getUserId()).isEqualTo("btse_test_001");
    }
    
    @Test
    void testTransferSuccess() {
        BtseTransferRequest request = BtseTransferRequest.builder()
            .userId("btse_test_001")
            .direction("IN")
            .amount(new BigDecimal("100.00"))
            .currency("USDT")
            .build();
        
        BtseTransferResponse response = btseApiClient.transfer(request);
        
        assertThat(response.isSuccess()).isTrue();
        assertThat(response.getTransferId()).isNotNull();
        assertThat(response.getTransferId()).startsWith("MOCK_TRANSFER_");
    }
    
    @Test
    void testTransferInsufficientBalance() {
        BtseTransferRequest request = BtseTransferRequest.builder()
            .userId("btse_poor_user")
            .direction("OUT")
            .amount(new BigDecimal("10000.00"))
            .currency("USDT")
            .build();
        
        BtseTransferResponse response = btseApiClient.transfer(request);
        
        assertThat(response.isSuccess()).isFalse();
        assertThat(response.getErrorCode()).isEqualTo("INSUFFICIENT_BALANCE");
    }
    
    @Test
    void testGetOdds() {
        BtseOddsResponse response = btseApiClient.getCurrentOdds("BTC/USDT", 5);
        
        assertThat(response.getSymbol()).isEqualTo("BTC/USDT");
        assertThat(response.getDuration()).isEqualTo(5);
        assertThat(response.getBaseOdds()).isBetween(new BigDecimal("1.5"), new BigDecimal("2.5"));
    }
    
    @Test
    void testGetKlineData() {
        List<BtseKlineData> klineData = btseApiClient.getKlineData("BTC/USDT", "1m", 10);
        
        assertThat(klineData).hasSize(10);
        assertThat(klineData.get(0).getSymbol()).isEqualTo("BTC/USDT");
        assertThat(klineData.get(0).getInterval()).isEqualTo("1m");
    }
}
```

### 6.7 集成测试配置

```yaml
# application-integration-test.yml
btse:
  mock:
    enabled: true
    scenarios:
      auth-failure-rate: 0.1
      transfer-failure-rate: 0.05
      balance-insufficient-rate: 0.2
      api-timeout-rate: 0.02
    delays:
      min-delay: 50
      max-delay: 200
    test-users:
      - external-id: "integration_test_user_001"
        balance: "50000.00"
        nickname: "集成测试用户001"
        email: "integration001@test.com"
      - external-id: "integration_test_user_002"
        balance: "100000.00"
        nickname: "集成测试用户002"
        email: "integration002@test.com"
      - external-id: "integration_poor_user"
        balance: "10.00"
        nickname: "余额不足测试用户"
        email: "poor@test.com"

# 日志配置，便于调试
logging:
  level:
    com.binaryoption.btse.mock: DEBUG
```

### 6.8 Mock数据管理工具

```java
@RestController
@RequestMapping("/mock/btse")
@Profile({"dev", "test"})
@ConditionalOnProperty(name = "btse.mock.enabled", havingValue = "true")
public class BtseMockController {
    
    @Autowired
    private BtseMockDataService mockDataService;
    
    @Autowired
    private BtseMockConfig mockConfig;
    
    // 重置用户余额
    @PostMapping("/users/{userId}/balance/reset")
    public ApiResponse<Void> resetBalance(@PathVariable String userId, 
                                        @RequestParam String currency,
                                        @RequestParam BigDecimal amount) {
        String balanceKey = "mock_balance:" + userId + ":" + currency;
        redisTemplate.opsForValue().set(balanceKey, amount.toString(), Duration.ofDays(1));
        
        return ApiResponse.success(null, "余额重置成功");
    }
    
    // 设置失败率
    @PostMapping("/scenarios/{scenario}/rate")
    public ApiResponse<Void> setFailureRate(@PathVariable String scenario, 
                                          @RequestParam Double rate) {
        mockConfig.getScenarios().put(scenario, rate);
        return ApiResponse.success(null, "失败率设置成功");
    }
    
    // 获取Mock配置
    @GetMapping("/config")
    public ApiResponse<BtseMockConfig> getConfig() {
        return ApiResponse.success(mockConfig);
    }
    
    // 清理Mock数据
    @DeleteMapping("/data/clear")
    public ApiResponse<Void> clearMockData() {
        Set<String> keys = redisTemplate.keys("mock_balance:*");
        if (keys != null && !keys.isEmpty()) {
            redisTemplate.delete(keys);
        }
        return ApiResponse.success(null, "Mock数据清理完成");
    }
}
```

通过以上Mock方案，可以在开发和测试环境中完全模拟BTSE API的各种场景，包括正常响应、异常情况、网络超时等，大大提高了开发和测试的效率。

---
**文档版本**: v1.7  
**最后更新**: 2025年8月04日  
**维护者**: Barry  
**相关文档**: [详细设计概述](./207_01_详细设计概述.md), [业务流程设计](./207_05_业务流程设计.md), [技术实现基础](./207_06_技术实现_基础.md)