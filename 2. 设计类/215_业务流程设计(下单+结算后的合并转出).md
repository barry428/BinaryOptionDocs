# 业务流程设计：轮次结算后的合并转出

## 方案概述

### 现状问题
- **转出频繁**：每个订单结算后立即转出，造成大量小额转出
- **手续费高**：多次转出产生更多手续费成本
- **日志冗余**：每个订单一条转出记录，日志量大
- **性能影响**：结算过程中频繁调用BTSE转出API

### 优化目标
- **合并转出**：每个轮次每个用户最多一次转出
- **减少手续费**：合并多个订单的收益，减少转出次数
- **提升性能**：减少BTSE API调用频率
- **状态跟踪**：完整的转账状态管理和补偿机制

## 业务流程设计

### 1. 整体流程
```
用户下单 → 订单结算 → 轮次结算完成 → 合并收益转出 → 状态跟踪
```

### 2. 详细流程

#### 阶段1：下单阶段（保持不变）
```
1. 用户下单
2. BTSE自动转入（REAL账户）- transfer_type: ORDER_IN
3. 冻结资金（balance → frozen_balance）
4. 记录user_round关联（首次下单，status: PENDING）
```

#### 阶段2：订单结算阶段（简化转出）
```
1. 计算订单盈亏
2. 更新订单状态（WIN/LOSE）
3. 账户资金结算（frozen_balance → balance）
4. ❌ 删除：订单级自动转出
```

#### 阶段3：轮次结算完成（新增合并转出）
```
1. 更新轮次状态为SETTLED
2. 统计用户轮次数据写入user_round（status: SETTLED）
3. 🆕 合并收益转出逻辑：
   - 计算转出金额：总投注金额 + 净收益
   - 转出条件：最终金额 > 0
   - 更新user_round状态：TRANSFERRED
   - 创建btse_transfer_log记录（transfer_type: ROUND_OUT）
   - 补偿机制更新最终状态：TRANSFER_SUCCESS/TRANSFER_FAILED
```

## 转出逻辑设计

### 1. 转出条件判断
```java
// REAL账户且(总投注金额 + 净收益) > 0 才转出
BigDecimal finalAmount = totalAmount.add(netProfit);
if (BusinessConstants.AccountType.REAL.equals(accountType) && 
    finalAmount.compareTo(BigDecimal.ZERO) > 0) {
    executeRoundMergedTransferOut(userId, accountType, totalAmount, netProfit, roundId);
} else {
    // 更新user_round状态为SKIPPED
    userRoundMapper.updateTransferStatus(userId, roundId, accountType, 
        BusinessConstants.UserRoundStatus.SKIPPED);
}
```

### 2. 转出金额计算
```
转出条件：总投注金额 + 净收益 > 0
转出金额：总投注金额 + 净收益

- 总投注金额：用户在该轮次的所有下单金额（totalAmount）
- 净收益：所有订单profit字段的总和（netProfit，可为负值）
- 最终金额：totalAmount + netProfit
- 转出条件：最终金额 > 0
```

### 3. 状态管理
```
user_round.status 状态流转：
PENDING → SETTLED → TRANSFERRED → TRANSFER_SUCCESS/TRANSFER_FAILED
                 → SKIPPED (如果金额<=0或DEMO账户)
```

### 4. 示例场景

#### 场景1：用户盈利
```
用户在轮次6008有3个订单：
- 订单1：投注100，盈利80
- 订单2：投注50，亏损50  
- 订单3：投注200，盈利150

计算：
- 总投注：100 + 50 + 200 = 350
- 净收益：80 + (-50) + 150 = 180
- 最终金额：350 + 180 = 530
- 转出条件：530 > 0 ✅
- 转出金额：530
- user_round.status: PENDING → SETTLED → TRANSFERRED → TRANSFER_SUCCESS
```

#### 场景2：用户亏损
```
用户在轮次6009有2个订单：
- 订单1：投注100，亏损100
- 订单2：投注50，亏损50

计算：
- 总投注：100 + 50 = 150  
- 净收益：(-100) + (-50) = -150
- 最终金额：150 + (-150) = 0
- 转出条件：0 > 0 ❌
- 转出金额：0（不转出）
- user_round.status: PENDING → SETTLED → SKIPPED
```

## 数据库表结构

### 1. user_round表（新增状态跟踪）

#### MySQL版本
```sql
CREATE TABLE user_round (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT NOT NULL,
    round_id BIGINT NOT NULL,
    account_type VARCHAR(10) NOT NULL,
    first_order_time TIMESTAMP NULL,
    last_settle_time TIMESTAMP NULL,
    total_orders INTEGER DEFAULT 0,
    total_amount DECIMAL(18,8) DEFAULT 0,
    net_profit DECIMAL(18,8) DEFAULT 0,
    status VARCHAR(20) DEFAULT 'PENDING',  -- 🆕 转账状态跟踪
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_user_round_account (user_id, round_id, account_type),
    INDEX idx_user_settle_time (user_id, last_settle_time),
    INDEX idx_user_round_status (status)
);
```

#### PostgreSQL版本
```sql
CREATE TABLE user_round (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    round_id BIGINT NOT NULL,
    account_type VARCHAR(10) NOT NULL,
    first_order_time TIMESTAMP,
    last_settle_time TIMESTAMP,
    total_orders INTEGER DEFAULT 0,
    total_amount DECIMAL(18,8) DEFAULT 0,
    net_profit DECIMAL(18,8) DEFAULT 0,
    status VARCHAR(20) DEFAULT 'PENDING',  -- 🆕 转账状态跟踪
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT uk_user_round_account UNIQUE (user_id, round_id, account_type)
);

CREATE INDEX IF NOT EXISTS idx_user_settle_time ON user_round(user_id, last_settle_time);
CREATE INDEX IF NOT EXISTS idx_user_round_status ON user_round(status);

COMMENT ON COLUMN user_round.status IS '状态：PENDING-待结算，SETTLED-已结算，TRANSFERRED-转账中，TRANSFER_SUCCESS-转账成功，TRANSFER_FAILED-转账失败，SKIPPED-跳过';
```

### 2. btse_transfer_log表（新建完整表结构）

#### MySQL版本
```sql
CREATE TABLE btse_transfer_log (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    trace_id VARCHAR(100) NOT NULL,
    user_id BIGINT NOT NULL,
    transfer_type VARCHAR(20) NOT NULL,  -- 🆕 转账类型
    refer_id BIGINT,                     -- 🆕 关联ID（订单ID或轮次ID）
    direction VARCHAR(10) NOT NULL,      -- IN/OUT
    amount DECIMAL(18,8) NOT NULL,
    currency VARCHAR(10) DEFAULT 'USDT',
    transfer_id VARCHAR(100),            -- BTSE转账ID
    api_method VARCHAR(50),
    status VARCHAR(20) DEFAULT 'PENDING',
    error_message TEXT,
    request_data TEXT,
    response_data TEXT,
    retry_count INTEGER DEFAULT 0,
    environment VARCHAR(20),
    is_mock BOOLEAN DEFAULT FALSE,
    request_time TIMESTAMP NULL,
    response_time TIMESTAMP NULL,
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_user_id (user_id),
    INDEX idx_trace_id (trace_id),
    INDEX idx_transfer_id (transfer_id),
    INDEX idx_status (status),
    INDEX idx_refer_type (refer_id, transfer_type),
    INDEX idx_direction_status (direction, status)
);
```

#### PostgreSQL版本
```sql
CREATE TABLE btse_transfer_log (
    id BIGSERIAL PRIMARY KEY,
    trace_id VARCHAR(100) NOT NULL,
    user_id BIGINT NOT NULL,
    transfer_type VARCHAR(20) NOT NULL,  -- 🆕 转账类型
    refer_id BIGINT,                     -- 🆕 关联ID（订单ID或轮次ID）
    direction VARCHAR(10) NOT NULL,      -- IN/OUT
    amount DECIMAL(18,8) NOT NULL,
    currency VARCHAR(10) DEFAULT 'USDT',
    transfer_id VARCHAR(100),            -- BTSE转账ID
    api_method VARCHAR(50),
    status VARCHAR(20) DEFAULT 'PENDING',
    error_message TEXT,
    request_data TEXT,
    response_data TEXT,
    retry_count INTEGER DEFAULT 0,
    environment VARCHAR(20),
    is_mock BOOLEAN DEFAULT FALSE,
    request_time TIMESTAMP,
    response_time TIMESTAMP,
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_user_id ON btse_transfer_log(user_id);
CREATE INDEX IF NOT EXISTS idx_trace_id ON btse_transfer_log(trace_id);
CREATE INDEX IF NOT EXISTS idx_transfer_id ON btse_transfer_log(transfer_id);
CREATE INDEX IF NOT EXISTS idx_status ON btse_transfer_log(status);
CREATE INDEX IF NOT EXISTS idx_refer_type ON btse_transfer_log(refer_id, transfer_type);
CREATE INDEX IF NOT EXISTS idx_direction_status ON btse_transfer_log(direction, status);
```

#### 状态说明
```
user_round.status 状态：
- PENDING: 待结算
- SETTLED: 已结算，等待转账
- TRANSFERRED: 转账中
- TRANSFER_SUCCESS: 转账成功
- TRANSFER_FAILED: 转账失败
- SKIPPED: 跳过转账（金额<=0或DEMO账户）

btse_transfer_log.transfer_type 类型：
- ORDER_IN: 订单转入
- ORDER_OUT: 订单转出（单笔结算）
- ROUND_OUT: 轮次合并转出
- MANUAL_IN: 手动转入
- MANUAL_OUT: 手动转出
```

### 3. 转账类型枚举
```java
public static class TransferType {
    public static final String ORDER_IN = "ORDER_IN";      // 订单转入
    public static final String ORDER_OUT = "ORDER_OUT";    // 订单转出（单笔结算）
    public static final String ROUND_OUT = "ROUND_OUT";    // 轮次合并转出
    public static final String MANUAL_IN = "MANUAL_IN";    // 手动转入
    public static final String MANUAL_OUT = "MANUAL_OUT";  // 手动转出
}
```

## 技术实现要点

### 1. 转账类型判断
```java
// 根据业务场景设置不同的transfer_type
if (orderId != null) {
    transferType = direction.equals("IN") ? TransferType.ORDER_IN : TransferType.ORDER_OUT;
} else if (roundId != null) {
    transferType = TransferType.ROUND_OUT;
} else {
    transferType = direction.equals("IN") ? TransferType.MANUAL_IN : TransferType.MANUAL_OUT;
}
```

### 2. 合并转出实现
```java
@Transactional
private void executeRoundMergedTransferOut(Long userId, String accountType, 
                                         BigDecimal totalAmount, BigDecimal netProfit, Long roundId) {
    BigDecimal finalAmount = totalAmount.add(netProfit);
    
    if (finalAmount.compareTo(BigDecimal.ZERO) <= 0) {
        userRoundMapper.updateTransferStatus(userId, roundId, accountType, UserRoundStatus.SKIPPED);
        return;
    }
    
    // 更新状态为TRANSFERRED
    userRoundMapper.updateTransferStatus(userId, roundId, accountType, UserRoundStatus.TRANSFERRED);
    
    // 调用转账API（创建btse_transfer_log记录）
    var result = btseTransferRpcClient.transferToBtseWithRound(userId, accountType, finalAmount, 
                                                              "轮次合并转出", roundId);
    
    if (!result.isSuccess()) {
        // 失败回滚状态
        userRoundMapper.updateTransferStatus(userId, roundId, accountType, UserRoundStatus.TRANSFER_FAILED);
    }
    // 成功的最终状态由补偿机制更新
}
```

### 3. 补偿机制增强
```java
// 补偿时根据transfer_type回写user_round状态
private void updateUserRoundStatusAfterTransfer(BtseTransferLog transferLog, String status) {
    if (TransferType.ROUND_OUT.equals(transferLog.getTransferType())) {
        userRoundRpcClient.updateTransferStatus(
            transferLog.getUserId(),
            transferLog.getReferId(),  // roundId
            AccountType.REAL,
            status  // TRANSFER_SUCCESS/TRANSFER_FAILED
        );
    }
}
```

### 4. 关联查询
```java
// 通过btse_transfer_log查询轮次转账状态
SELECT * FROM btse_transfer_log 
WHERE user_id = ? AND refer_id = ? AND transfer_type = 'ROUND_OUT'
ORDER BY create_time DESC LIMIT 1;

// 通过user_round查询转账状态
SELECT status FROM user_round 
WHERE user_id = ? AND round_id = ? AND account_type = 'REAL';
```

## 优势分析

### 1. 性能优势
- **减少API调用**：一个轮次多个订单合并为一次转出
- **降低延迟**：结算流程更快，转出异步进行
- **状态管理**：user_round表提供快速状态查询

### 2. 成本优势  
- **手续费节省**：减少转出次数，降低手续费成本
- **日志精简**：每轮次每用户一条记录，便于审计
- **存储优化**：避免冗余外键，通过业务逻辑关联

### 3. 数据一致性
- **事务保证**：user_round状态更新与btse_transfer_log创建在同一事务
- **补偿机制**：跨服务状态同步，确保最终一致性
- **状态追踪**：完整的状态流转记录

### 4. 可维护性
- **清晰的类型分类**：ORDER_IN/ORDER_OUT/ROUND_OUT/MANUAL_IN/MANUAL_OUT
- **业务逻辑关联**：通过refer_id + transfer_type查询关联记录
- **状态可视化**：user_round.status直接反映转账进度

## 风险控制

### 1. 异常处理
- 转出失败不影响订单结算
- user_round状态回滚机制
- 详细的错误日志和监控

### 2. 跨服务一致性
- RPC调用失败的重试机制
- 补偿定时任务回写状态
- 幂等性保证

### 3. 数据审计
- btse_transfer_log完整记录所有转账
- user_round状态变更可追踪
- 支持管理后台查询和处理

## 实施完成情况

✅ **已完成**：
1. 新增UserRoundStatus状态常量定义
2. 完善TransferType类型分类（新增ORDER_OUT）
3. 实现轮次合并转出逻辑和事务管理
4. 建立跨服务RPC状态同步机制
5. 更新补偿机制支持状态回写
6. 简化数据关联（移除冗余transfer_id字段）

🔄 **待测试**：
1. 完整业务流程测试
2. 补偿机制验证
3. 状态一致性检查