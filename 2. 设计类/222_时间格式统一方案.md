# 时间格式统一方案

## 1. 需求背景

系统中所有接口返回的时间字段需要统一转换为时间戳格式（毫秒），以便前端统一处理。

## 2. 技术方案选择

### 2.1 方案对比

| 方案 | 优点 | 缺点 | 推荐度 |
|------|------|------|--------|
| 修改数据库字段类型 | - | 破坏数据库标准结构，不利于维护 | ❌ |
| 在每个DTO上添加注解 | 灵活控制 | 重复工作量大，容易遗漏 | ⭐⭐ |
| **全局Jackson配置** | 统一处理，一处配置 | 所有时间字段都会转换 | ⭐⭐⭐⭐⭐ |
| 自定义响应拦截器 | 可以精细控制 | 实现复杂，性能开销 | ⭐⭐⭐ |

### 2.2 选择理由

选择**全局Jackson配置**方案，原因如下：
1. **统一性**：一处配置，全局生效
2. **可维护性**：修改方便，集中管理
3. **性能好**：Jackson原生支持，性能最优
4. **灵活性**：支持特殊字段使用注解覆盖

## 3. 实现方案

### 3.1 全局配置类

在 `option-common-utils` 模块创建全局Jackson配置：

```java
// option-common-utils/src/main/java/com/binaryoption/commonutils/config/GlobalJacksonConfig.java
@Configuration
@ConditionalOnClass(ObjectMapper.class)
public class GlobalJacksonConfig {
    
    @Bean
    public Jackson2ObjectMapperBuilderCustomizer jsonCustomizer() {
        return builder -> {
            SimpleModule module = new SimpleModule();
            
            // LocalDateTime序列化为时间戳（毫秒）
            module.addSerializer(LocalDateTime.class, new JsonSerializer<LocalDateTime>() {
                @Override
                public void serialize(LocalDateTime value, JsonGenerator gen, SerializerProvider serializers) 
                        throws IOException {
                    if (value != null) {
                        long timestamp = value.toInstant(ZoneOffset.of("+8")).toEpochMilli();
                        gen.writeNumber(timestamp);
                    }
                }
            });
            
            // LocalDateTime反序列化
            module.addDeserializer(LocalDateTime.class, new JsonDeserializer<LocalDateTime>() {
                @Override
                public LocalDateTime deserialize(JsonParser p, DeserializationContext ctxt) 
                        throws IOException {
                    Long timestamp = p.getValueAsLong();
                    if (timestamp != null) {
                        return LocalDateTime.ofInstant(
                            Instant.ofEpochMilli(timestamp), 
                            ZoneId.of("Asia/Shanghai")
                        );
                    }
                    return null;
                }
            });
            
            builder.modules(module);
        };
    }
}
```

### 3.2 自动配置

通过 `spring.factories` 实现自动配置：

```properties
# option-common-utils/src/main/resources/META-INF/spring.factories
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.binaryoption.commonutils.config.GlobalJacksonConfig
```

### 3.3 特殊处理

如果某些字段需要保持原格式，可以使用注解覆盖：

```java
public class OrderDTO {
    // 默认转换为时间戳
    private LocalDateTime createTime;
    
    // 保持ISO格式
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime displayTime;
    
    // 强制转换为时间戳
    @JsonFormat(shape = JsonFormat.Shape.NUMBER)
    private LocalDateTime timestamp;
}
```

## 4. 影响范围

### 4.1 受影响的字段

所有 `LocalDateTime` 类型字段将自动转换为时间戳，包括但不限于：
- `createTime` - 创建时间
- `updateTime` - 更新时间
- `startTime` - 开始时间
- `endTime` - 结束时间
- `lockTime` - 锁定时间
- `settleTime` - 结算时间
- `expiration` - 过期时间

### 4.2 转换示例

**转换前（ISO格式）**：
```json
{
  "createTime": "2025-08-17T10:30:00",
  "updateTime": "2025-08-17T10:35:00"
}
```

**转换后（时间戳）**：
```json
{
  "createTime": 1723865400000,
  "updateTime": 1723865700000
}
```

## 5. 其他配置

### 5.1 Long类型精度保护

JavaScript中Number类型最大安全整数为 2^53-1，超过会精度丢失。配置Long类型序列化为字符串：

```java
module.addSerializer(Long.class, ToStringSerializer.instance);
module.addSerializer(Long.TYPE, ToStringSerializer.instance);
```

### 5.2 BigDecimal精度保持

金额类型保持数字格式，不转换为字符串：

```java
module.addSerializer(BigDecimal.class, new JsonSerializer<BigDecimal>() {
    @Override
    public void serialize(BigDecimal value, JsonGenerator gen, SerializerProvider serializers) 
            throws IOException {
        if (value != null) {
            gen.writeNumber(value);
        }
    }
});
```

## 6. 测试验证

### 6.1 测试接口

调用任意返回时间字段的接口，验证时间格式：

```bash
# 获取交易轮次
curl http://localhost:8080/api/public/order/round/current/1

# 预期响应
{
  "data": {
    "rounds": [{
      "startTime": 1723865400000,  # 时间戳格式
      "endTime": 1723866000000,
      "lockTime": 1723865970000
    }]
  }
}
```

### 6.2 验证点

1. ✅ LocalDateTime字段转换为时间戳
2. ✅ Long类型ID转换为字符串
3. ✅ BigDecimal金额保持数字格式
4. ✅ 支持反序列化（请求体中的时间戳可以正确解析）

## 7. 注意事项

### 7.1 时区处理

- 默认使用东八区（Asia/Shanghai）
- 时间戳为毫秒级（JavaScript标准）
- 数据库存储仍使用LocalDateTime

### 7.2 兼容性

- 前端需要处理时间戳格式
- 旧版本客户端可能需要适配
- 建议提供版本控制机制

### 7.3 性能影响

- Jackson原生序列化，性能影响极小
- 无需额外的转换层
- 不影响数据库查询性能

## 8. 回滚方案

如需回滚到ISO格式，只需修改GlobalJacksonConfig：

```java
// 改为使用ISO格式
mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
```

或者通过配置文件控制：

```yaml
spring:
  jackson:
    serialization:
      write-dates-as-timestamps: false  # false=ISO格式, true=时间戳
```

## 9. 总结

通过全局Jackson配置，实现了：
1. **统一的时间格式**：所有时间字段自动转换为时间戳
2. **灵活的控制**：支持注解覆盖特殊需求
3. **最小的改动**：无需修改现有代码
4. **良好的性能**：使用Jackson原生能力
5. **易于维护**：集中配置，便于管理