# 对账方案设计

## 1. 背景

二元期权交易平台需要验证账户数据的一致性，确保：
- 账户余额计算正确
- 交易流水与余额匹配
- BTSE转账记录与账户充提记录一致
- 订单盈亏与账户统计匹配

## 2. 对账维度

### 2.1 账户余额平衡
**公式**: `total_deposit - total_withdraw - balance - frozen_balance + total_profit - total_loss = 0`

**验证逻辑**: 
- 所有资金流入减去流出，应该等于当前持有的资金

### 2.2 交易流水汇总
**验证**: `balance + frozen_balance = SUM(account_transaction.amount + account_transaction.frozen_amount)`

**说明**: 
- 当前账户总资金应该等于所有交易流水中amount和frozen_amount的累计变化
- account_transaction记录了每笔交易对balance和frozen_balance的影响

### 2.3 BTSE转账记录（仅REAL账户）
**验证**: 
- `total_deposit = SUM(btse_transfer_log.amount WHERE direction='IN' AND status='SUCCESS')`
- `total_withdraw = SUM(btse_transfer_log.amount WHERE direction='OUT' AND status='SUCCESS')`

### 2.4 订单盈亏统计
**验证**:
- `total_profit = SUM(option_order.profit WHERE status='WIN' AND profit > 0)`
- `total_loss = SUM(ABS(option_order.profit) WHERE status='LOSE' AND profit < 0)`

## 3. 对账类型

### 3.1 单个用户对账（结果区分DEMO/REAL）
- 输入：userId
- 返回：该用户的DEMO和REAL账户分别的四项检查结果
- 接口：`POST /rpc/reconciliation/user/{userId}`
- 返回格式：`List<ReconciliationDTO>` （包含DEMO和REAL两个结果）

### 3.2 全量对账（所有用户合并处理）（结果区分DEMO/REAL）
- 输入：无（或可选的accountType过滤）
- 返回：所有DEMO账户合并结果 + 所有REAL账户合并结果
- 接口：`POST /rpc/reconciliation/batch`
- 返回格式：`List<ReconciliationDTO>` （包含DEMO汇总和REAL汇总两个结果）

**全量对账SQL示例**:
```sql
-- DEMO账户汇总对账
SELECT 
  SUM(total_deposit) - SUM(total_withdraw) - SUM(balance) - SUM(frozen_balance) + SUM(total_profit) - SUM(total_loss) as balance_diff
FROM account WHERE account_type = 'DEMO';

-- REAL账户汇总对账  
SELECT 
  SUM(total_deposit) - SUM(total_withdraw) - SUM(balance) - SUM(frozen_balance) + SUM(total_profit) - SUM(total_loss) as balance_diff
FROM account WHERE account_type = 'REAL';

-- 其他三项检查类似，分别对DEMO和REAL进行汇总
```

## 4. 实现方案

### 4.1 单个用户对账
```java
public List<ReconciliationDTO> reconcileUserAccounts(Long userId) {
    List<ReconciliationDTO> results = new ArrayList<>();
    
    // 对该用户的DEMO账户进行对账
    ReconciliationDTO demoResult = reconcileUserByAccountType(userId, "DEMO");
    if (demoResult != null) results.add(demoResult);
    
    // 对该用户的REAL账户进行对账  
    ReconciliationDTO realResult = reconcileUserByAccountType(userId, "REAL");
    if (realResult != null) results.add(realResult);
    
    return results;
}
```

### 4.2 全量对账（所有用户合并）
```java
public List<ReconciliationDTO> reconcileBatch() {
    List<ReconciliationDTO> results = new ArrayList<>();
    
    // 所有DEMO账户汇总对账
    ReconciliationDTO demoResult = reconcileBatchByAccountType("DEMO");
    results.add(demoResult);
    
    // 所有REAL账户汇总对账
    ReconciliationDTO realResult = reconcileBatchByAccountType("REAL");
    results.add(realResult);
    
    return results;
}

private ReconciliationDTO reconcileBatchByAccountType(String accountType) {
    // 执行4条聚合SQL查询，针对指定账户类型
    // 返回该账户类型的汇总对账结果
}
```

## 5. 数据库改动（最小化）

### 5.1 common-service新增Mapper方法（3个）

#### AccountMapper
```java
// 账户余额平衡检查 
BigDecimal getBalanceDiffByAccountType(@Param("accountType") String accountType);
```
对应SQL：
```sql
SELECT SUM(total_deposit) - SUM(total_withdraw) - SUM(balance) - SUM(frozen_balance) + SUM(total_profit) - SUM(total_loss)
FROM account WHERE account_type = #{accountType}
```

#### AccountTransactionMapper  
```java
// 交易流水汇总检查
BigDecimal getTransactionSumByAccountType(@Param("accountType") String accountType);
```
对应SQL：
```sql
SELECT COALESCE(SUM(at.amount + COALESCE(at.frozen_amount, 0)), 0)
FROM account_transaction at 
JOIN account a ON at.account_id = a.id 
WHERE a.account_type = #{accountType}
```

#### BtseTransferLogMapper
```java
// BTSE转账记录检查 
BigDecimal getBtseTransferSumByDirection(@Param("direction") String direction, @Param("status") String status);
```
对应SQL：
```sql
SELECT COALESCE(SUM(amount), 0) 
FROM btse_transfer_log 
WHERE direction = #{direction} AND status = #{status}
```

### 5.2 OrderService增加批量统计RPC接口

#### 在order-service新增接口：
```java
// OrderStatRpcController
@GetMapping("/batch/profit/{accountType}")
public Result<BigDecimal> getBatchOrderProfit(@PathVariable String accountType);

@GetMapping("/batch/loss/{accountType}")  
public Result<BigDecimal> getBatchOrderLoss(@PathVariable String accountType);
```

#### 对应的Mapper方法：
```java
// OrderMapper
BigDecimal sumProfitByAccountType(@Param("accountType") String accountType);
BigDecimal sumLossByAccountType(@Param("accountType") String accountType);
```

#### 在common-service调用：
```java
// ReconciliationService中通过OrderStatRpcClient调用
orderStatRpcClient.getBatchOrderProfit(accountType);
orderStatRpcClient.getBatchOrderLoss(accountType);
```

## 6. 误差容忍

- 单账户对账：0.01元误差
- 批量对账：1.00元误差（考虑大数据量的精度累积）

## 7. 接口设计

### 7.1 单个用户对账
- `POST /rpc/reconciliation/user/{userId}` → `List<ReconciliationDTO>`
- 返回该用户的DEMO和REAL账户对账结果（最多2个）

### 7.2 全量对账
- `POST /rpc/reconciliation/batch` → `List<ReconciliationDTO>`  
- 返回所有用户的DEMO账户汇总结果 + 所有用户的REAL账户汇总结果（固定2个）

## 8. 实现重点

1. **最小改动原则**：只修改reconcileUserAccounts和reconcileBatch方法
2. **精简Mapper方法**：每个表只新增1-2个汇总方法，避免过度设计
3. **结果标准化**：都返回List<ReconciliationDTO>，区分DEMO和REAL
4. **简单有效**：每种账户类型通过少量Mapper方法解决对账问题

## 9. 验收标准

1. ✅ 单个用户对账返回DEMO和REAL两个结果
2. ✅ 全量对账返回所有DEMO汇总和所有REAL汇总两个结果  
3. ✅ 交易流水汇总公式修正为：balance + frozen_balance = SUM(amount + frozen_amount)
4. ✅ BTSE转账检查仅对REAL账户进行
5. ✅ 前端界面支持两种对账操作
6. ✅ 代码改动最小化，避免过度设计

这个方案符合"几个SQL就解决的问题"的要求，避免了过度复杂的设计。