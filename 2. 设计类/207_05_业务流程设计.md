# 二元期权平台业务流程设计

## 1. 用户注册登录流程 **[v1.8更新：支持本地注册和BTSE认证并存]**

### 1.1 流程图

```mermaid
sequenceDiagram
    participant U as 用户
    participant G as Gateway
    participant C as Common-Service
    participant B as BTSE-API
    participant DB as Database

    U->>G: 登录请求(BTSE Token)
    G->>C: 转发登录请求
    C->>B: 验证BTSE用户认证  %% v1.7新增
    alt BTSE认证成功
        B->>C: 返回用户信息
        C->>DB: 查询本地用户
        alt 用户不存在
            C->>B: 获取BTSE用户详情  %% v1.7新增
            C->>DB: 创建用户记录
            C->>DB: 创建默认账户(实盘+模拟)
        end
        C->>C: 生成本地JWT Token
        C->>G: 返回登录成功
        G->>U: 登录成功(JWT Token)
    else BTSE认证失败
        B->>C: 认证失败
        C->>G: 返回认证失败错误
        G->>U: 登录失败
    end
```

### 1.2 流程说明

**v1.8更新要点**：
- 支持本地注册和BTSE认证双模式
- 测试环境使用本地注册，生产环境使用BTSE认证
- 自动创建DEMO和REAL两种账户类型

**核心步骤**：
1. **认证方式选择**：根据环境配置选择本地或BTSE认证
2. **用户创建**：本地注册或BTSE用户同步
3. **账户初始化**：自动创建实盘和模拟账户（余额初始为0）
4. **JWT生成**：生成本地JWT Token用于后续请求
5. **账户余额管理**：DEMO账户可领取体验金，REAL账户需BTSE充值

### 1.3 数据变化

```sql
-- 创建用户记录
INSERT INTO user (external_id, nickname, email, status, create_time, update_time)
VALUES ('btse_user_123', 'BTSE用户', 'user@btse.com', 1, NOW(), NOW());

-- 创建实盘账户
INSERT INTO account (user_id, account_type, currency, balance, create_time, update_time)
VALUES (1, 'REAL', 'USDT', '0.0000000000000000', NOW(), NOW());

-- 创建模拟账户（初始余额为0，需通过API领取）
INSERT INTO account (user_id, account_type, currency, balance, create_time, update_time)
VALUES (1, 'DEMO', 'USDT', '0.0000000000000000', NOW(), NOW());
```

## 2. 下单交易流程 **[v2.0更新：PENDING预订单机制与BTSE集成]**

### 2.1 流程图

```mermaid
sequenceDiagram
    participant U as 用户
    participant G as Gateway
    participant O as Order-Service
    participant C as Common-Service
    participant B as BTSE-API
    participant DB as Database

    U->>G: 下单请求
    G->>O: 转发下单请求
    O->>O: 风控校验
    alt 风控通过
        alt DEMO账户
            O->>C: 检查本地余额
            alt 余额充足
                O->>C: 冻结资金
                O->>DB: 创建订单(状态:ACTIVE)
                O->>G: 返回下单成功
                G->>U: 下单成功
            else 余额不足
                O->>G: 返回余额不足错误
                G->>U: 下单失败
            end
        else REAL账户
            O->>DB: 创建预订单(状态:PENDING)  %% v2.0新增
            O->>C: RPC调用BTSE转入(orderId作为clientTransferId)
            C->>B: 检查BTSE余额并执行转入
            alt BTSE转入成功
                C->>DB: 记录BTSE转入日志(PENDING状态)
                C->>C: 原子性增加frozen_balance
                C->>DB: 更新转入日志状态为SUCCESS
                C->>O: 返回转入成功
                O->>DB: 更新订单状态为ACTIVE
                O->>G: 返回下单成功
                G->>U: 下单成功
            else BTSE转入失败
                C->>DB: 记录BTSE转入日志(FAILED状态)
                C->>O: 返回转入失败
                O->>DB: 更新订单状态为CANCELLED
                O->>G: 返回转入失败错误
                G->>U: 下单失败
            end
        end
    else 风控拦截
        O->>DB: 记录风控日志
        O->>G: 返回风控错误
        G->>U: 下单失败
    end
```

### 2.2 流程说明

**v2.0更新要点**：
- DEMO账户使用本地余额，REAL账户使用BTSE余额
- REAL账户采用预订单机制（PENDING状态）确保Client Transfer ID唯一性
- 原子性账户操作避免并发问题
- 资金流向优化：REAL账户资金直接进入frozen_balance，绕过balance
- 完整的BTSE转账日志记录

**核心步骤**：
1. **风控校验**：检查用户状态、下注限额、频次限制
2. **账户类型判断**：
   - DEMO：检查本地余额，直接创建ACTIVE订单
   - REAL：创建PENDING预订单，使用订单ID进行BTSE转入
3. **REAL账户处理流程**：
   - 先创建PENDING预订单获取唯一订单ID
   - 使用订单ID作为clientTransferId调用BTSE转入
   - BTSE转入成功后原子性增加frozen_balance
   - 更新订单状态为ACTIVE
4. **资金处理差异**：
   - DEMO：balance → frozen_balance（本地操作）
   - REAL：BTSE → frozen_balance（绕过balance字段）
5. **日志记录**：
   - btse_transfer_log表记录转账详情
   - account_transaction表记录账户变化
   - 支持后续补偿机制查询

### 2.3 风控规则

**金额限制**：
- 单笔最小金额：10 USDT
- 单笔最大金额：10,000 USDT
- 日累计限额：50,000 USDT

**频次限制**：
- 每分钟最多5笔订单
- 每小时最多100笔订单

**用户状态检查**：
- 用户状态正常
- 未在黑名单中
- 已同意风险协议

### 2.4 数据变化详解

**DEMO账户下单**：
```sql
-- 1. 风控检查通过后，直接创建ACTIVE订单
INSERT INTO option_order (user_id, account_type, symbol_id, round_id, direction, amount, odds, status, create_time)
VALUES (1, 'DEMO', 1, 123, 'UP', '100.0000000000000000', '1.9000', 'ACTIVE', NOW());

-- 2. 原子性冻结资金 (balance → frozen_balance)
UPDATE account SET 
    balance = balance - 100.0000000000000000,
    frozen_balance = frozen_balance + 100.0000000000000000,
    update_time = NOW()
WHERE id = 1 AND balance >= 100.0000000000000000;  -- 余额检查

-- 3. 记录资金冻结流水
INSERT INTO account_transaction (user_id, account_id, type, amount, frozen_amount, 
    balance_before, balance_after, frozen_before, frozen_after, description, ref_id, ref_type, create_time)
VALUES (1, 1, 'FREEZE_OUT', -100.0000000000000000, 100.0000000000000000,
    100.0000000000000000, 0.0000000000000000, 0.0000000000000000, 100.0000000000000000,
    'DEMO账户下单冻结资金', 1, 'ORDER', NOW());
```

**REAL账户下单**：
```sql
-- 1. 先创建PENDING预订单
INSERT INTO option_order (user_id, account_type, symbol_id, round_id, direction, amount, odds, status, create_time)
VALUES (1, 'REAL', 1, 123, 'UP', '100.0000000000000000', '1.9000', 'PENDING', NOW());

-- 2. 记录BTSE转入日志（PENDING状态）
INSERT INTO btse_transfer_log (user_id, order_id, direction, amount, status, trace_id, create_time)
VALUES (1, 1, 'IN', 100.0000000000000000, 'PENDING', 'ORDER_1_20250813', NOW());

-- 3. BTSE转入成功后，原子性增加frozen_balance（绕过balance）
UPDATE account SET 
    frozen_balance = frozen_balance + 100.0000000000000000,
    total_deposit = total_deposit + 100.0000000000000000,  -- 统计字段
    update_time = NOW()
WHERE user_id = 1 AND account_type = 'REAL';

-- 4. 更新BTSE转入日志状态
UPDATE btse_transfer_log SET 
    status = 'SUCCESS',
    success_time = NOW(),
    response_data = '{"transferId":"btse_123456","status":"success"}'
WHERE trace_id = 'ORDER_1_20250813';

-- 5. 记录转入流水
INSERT INTO account_transaction (user_id, account_id, type, amount, frozen_amount,
    balance_before, balance_after, frozen_before, frozen_after, description, ref_id, ref_type, create_time)
VALUES (1, 1, 'BTSE_IN', 0.0000000000000000, 100.0000000000000000,
    0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 100.0000000000000000,
    'REAL账户BTSE转入下单资金', 1, 'BTSE_TRANSFER', NOW());

-- 6. 更新订单状态为ACTIVE
UPDATE option_order SET 
    status = 'ACTIVE',
    update_time = NOW()
WHERE id = 1;
```

## 3. 自动结算流程 **[v2.0更新：结算与BTSE转出集成]**

### 3.1 流程图

```mermaid
sequenceDiagram
    participant S as 调度任务
    participant O as Order-Service
    participant C as Common-Service
    participant M as Market-Service
    participant B as BTSE-API
    participant DB as Database

    S->>O: 定时触发结算
    O->>DB: 查询待结算回合
    loop 每个回合
        O->>M: 获取结算价格
        O->>DB: 查询回合内ACTIVE状态订单
        loop 每个订单
            O->>O: 计算盈亏
            alt DEMO账户
                alt 盈利
                    O->>O: 计算手续费(10%)
                    O->>C: 解冻资金+派奖到balance
                else 亏损
                    O->>C: 扣除冻结资金
                else 平局
                    O->>C: 退还冻结资金到balance
                end
                O->>DB: 更新订单状态(WIN/LOSE/DRAW)
                O->>C: 记录资金流水
            else REAL账户
                alt 盈利
                    O->>O: 计算手续费(10%)
                    O->>C: 原子性订单结算(扣除frozen_balance+统计更新)
                    O->>C: RPC调用BTSE转出(净利润,带orderId)
                    C->>B: 执行BTSE转出
                    C->>DB: 记录BTSE转出日志
                    C->>O: 返回转出结果
                else 亏损
                    O->>C: 原子性订单结算(扣除frozen_balance+统计更新)
                else 平局
                    O->>C: 原子性订单结算(扣除frozen_balance+统计更新)
                    O->>C: RPC调用BTSE转出(本金退回,带orderId)
                    C->>B: 执行BTSE转出
                    C->>DB: 记录BTSE转出日志
                    C->>O: 返回转出结果
                end
                O->>DB: 更新订单状态(WIN/LOSE/DRAW)
            end
        end
        O->>DB: 更新回合状态为已结算
    end
```

### 3.2 流程说明

**v2.0更新要点**：
- DEMO账户结算资金回到balance，REAL账户结算资金转回BTSE
- REAL账户盈利仅转出净利润（不含本金），平局转出本金
- 结算只处理ACTIVE状态的订单，PENDING订单通过补偿机制处理
- 使用订单ID作为BTSE转出的关联ID，支持后续查询
- 原子性订单结算操作，确保账户余额变更和统计更新的一致性

**结算逻辑**：

1. **订单查询**：
   - 只查询ACTIVE状态的订单
   - 按账户类型分别处理
   - PENDING订单不参与结算

2. **盈亏计算**：
   - 比较订单价格和结算价格
   - 计算实际盈利金额和手续费

3. **资金处理差异**：
   
   **DEMO账户**：
   - WIN：frozen_balance → balance (本金+净利润)
   - LOSE：扣除frozen_balance
   - DRAW：frozen_balance → balance (退还本金)
   
   **REAL账户**：
   - WIN：扣除frozen_balance，净利润转BTSE（不含本金）
   - LOSE：扣除frozen_balance
   - DRAW：扣除frozen_balance，本金转BTSE

4. **状态更新**：
   - 所有结算的订单更新为WIN/LOSE/DRAW
   - 结算完成后更新回合状态为SETTLED

### 3.3 结算时机

**定时结算**：
- 每分钟执行一次
- 查找已到结算时间的回合
- 批量处理所有待结算订单

**手动结算**：
- 管理员紧急处理
- 异常情况下的强制结算
- 需要指定结算价格和原因

**结算示例代码**：
```java
@Transactional
public void settleOrder(Order order, BigDecimal settlePrice) {
    // 1. 检查订单状态 - 只结算ACTIVE订单
    if (!"ACTIVE".equals(order.getStatus())) {
        return; // 非ACTIVE订单跳过
    }
    
    // 2. 计算盈亏
    BigDecimal profit = calculateProfit(order, settlePrice);
    BigDecimal fee = calculateFee(profit);
    String result = profit.compareTo(BigDecimal.ZERO) > 0 ? "WIN" : 
                   profit.compareTo(BigDecimal.ZERO) < 0 ? "LOSE" : "DRAW";
    
    // 3. 根据账户类型处理资金
    if ("DEMO".equals(order.getAccountType())) {
        // DEMO: 资金回到balance
        if ("WIN".equals(result)) {
            accountService.unfreezeAndAddBalance(order.getUserId(), 
                order.getAmount().add(profit).subtract(fee));
        } else if ("LOSE".equals(result)) {
            accountService.deductFrozenBalance(order.getUserId(), order.getAmount());
        } else { // DRAW
            accountService.unfreezeAndAddBalance(order.getUserId(), order.getAmount());
        }
    } else { // REAL账户
        // REAL: 先扣除frozen_balance
        accountService.deductFrozenBalance(order.getUserId(), order.getAmount());
        
        if ("WIN".equals(result)) {
            // 仅转出净利润
            btseTransferService.transferToBtseForSettlement(
                order.getUserId(), "REAL", profit.subtract(fee), order.getId(), "结算盈利");
        } else if ("DRAW".equals(result)) {
            // 转出本金
            btseTransferService.transferToBtseForSettlement(
                order.getUserId(), "REAL", order.getAmount(), order.getId(), "平局退还");
        }
        // LOSE不需要转账，资金已扣除
    }
    
    // 4. 更新订单状态
    updateOrderStatus(order, result, profit, fee, settlePrice);
}
```

### 3.4 各结果的数据变化

**REAL账户盈利结算 (WIN)**：
```sql
-- 1. 更新订单状态
UPDATE option_order SET 
    status = 'WIN',
    expected_profit = 190.0000000000000000,  -- 本金100 + 赔率收益90
    profit = 90.0000000000000000,           -- 实际盈利（不含本金）
    fee = 9.0000000000000000,               -- 10%手续费
    settle_price = 45100.56789012,
    settle_time = NOW()
WHERE id = 1;

-- 2. 扣除冻结资金（本金已冻结）
UPDATE account SET 
    frozen_balance = frozen_balance - 100.0000000000000000
WHERE id = 1;

-- 3. BTSE转出净利润（仅转出盈利部分，本金不转）
INSERT INTO btse_transfer_log (user_id, order_id, direction, amount, status) 
VALUES (1, 1, 'OUT', 81.0000000000000000, 'SUCCESS');  -- 盈利90 - 手续费9

-- 4. 记录流水
INSERT INTO account_transaction (type, amount, remark) 
VALUES ('BET_WIN', 81.0000000000000000, 'REAL账户投注盈利(净利润)');
```

**DEMO账户盈利结算 (WIN)**：
```sql
-- 1. 更新订单状态（同上）

-- 2. 解冻并派发到余额
UPDATE account SET 
    balance = balance + 181.0000000000000000,        -- 本金100 + 盈利90 - 手续费9
    frozen_balance = frozen_balance - 100.0000000000000000
WHERE id = 1;

-- 3. 记录流水
INSERT INTO account_transaction (type, amount, remark) 
VALUES ('BET_WIN', 181.0000000000000000, 'DEMO账户投注盈利(含本金)');
```

**亏损结算 (LOSE)**：
```sql
-- 1. 更新订单状态
UPDATE option_order SET 
    status = 'LOSE',
    profit = -100.0000000000000000,    -- 亏损本金
    fee = 0.0000000000000000,          -- 亏损不收手续费
    settle_price = 44900.98765432,
    settle_time = NOW()
WHERE id = 1;

-- 2. 扣除冻结资金
UPDATE account SET 
    frozen_balance = frozen_balance - 100.0000000000000000,
    total_loss = total_loss + 100.0000000000000000
WHERE id = 1;

-- 3. 记录流水
INSERT INTO account_transaction (type, amount, remark) 
VALUES ('BET_LOSE', -100.0000000000000000, '投注亏损');
```

**平局结算 (DRAW)**：

DEMO账户：
```sql
-- 1. 更新订单状态
UPDATE option_order SET 
    status = 'DRAW',
    profit = 0.0000000000000000,       -- 无盈亏
    fee = 0.0000000000000000,          -- 平局不收手续费
    settle_price = 45000.12345678,     -- 与下单价相同
    settle_time = NOW()
WHERE id = 1;

-- 2. 退还本金到余额
UPDATE account SET 
    balance = balance + 100.0000000000000000,
    frozen_balance = frozen_balance - 100.0000000000000000
WHERE id = 1;

-- 3. 记录流水
INSERT INTO account_transaction (type, amount, remark) 
VALUES ('BET_DRAW', 100.0000000000000000, 'DEMO账户平局退还本金');
```

REAL账户：
```sql
-- 1. 更新订单状态（同上）

-- 2. 扣除冻结资金
UPDATE account SET 
    frozen_balance = frozen_balance - 100.0000000000000000
WHERE id = 1;

-- 3. BTSE转出本金
INSERT INTO btse_transfer_log (user_id, order_id, direction, amount, status) 
VALUES (1, 1, 'OUT', 100.0000000000000000, 'SUCCESS');

-- 4. 记录流水
INSERT INTO account_transaction (type, amount, remark) 
VALUES ('BET_DRAW', 0.0000000000000000, 'REAL账户平局退还本金至BTSE');
```

## 4. 订单状态流转

### 4.1 状态流转图

```mermaid
stateDiagram-v2
    [*] --> PENDING : REAL账户创建预订单
    [*] --> ACTIVE : DEMO账户直接下单
    PENDING --> ACTIVE : BTSE转入成功(转入补偿确认)
    PENDING --> CANCELLED : BTSE转入失败(转入补偿确认)
    ACTIVE --> CANCELLED : 撤单(锁单前)
    ACTIVE --> WIN : 结算盈利
    ACTIVE --> LOSE : 结算亏损  
    ACTIVE --> DRAW : 结算平局
    WIN --> [*]
    LOSE --> [*]
    DRAW --> [*]
    CANCELLED --> [*]
```

### 4.2 状态说明

| 状态 | 含义 | 触发条件 | 后续状态 |
|------|------|----------|----------|
| PENDING | 待确认 | REAL账户创建预订单 | ACTIVE/CANCELLED |
| ACTIVE | 进行中 | DEMO下单或REAL划转成功 | WIN/LOSE/DRAW/CANCELLED |
| WIN | 盈利 | 结算时用户预测正确 | 终态 |
| LOSE | 亏损 | 结算时用户预测错误 | 终态 |
| DRAW | 平局 | 结算价格等于下单价格 | 终态 |
| CANCELLED | 已撤销 | 划转失败/超时/用户撤单 | 终态 |

### 4.3 状态变更规则

**PENDING → ACTIVE**：
- BTSE转入成功（通过转入补偿机制确认）
- 资金成功进入frozen_balance

**PENDING → CANCELLED**：
- BTSE转入失败（通过转入补偿机制确认）

**ACTIVE → 结算状态**：
- 只有ACTIVE订单参与结算
- 根据盈亏结果更新为WIN/LOSE/DRAW

**可撤单条件**：
- 订单状态为ACTIVE
- 未到锁单时间（结束前30秒）
- 用户主动发起撤单请求

## 5. 回合管理流程

### 5.1 回合生命周期

```mermaid
stateDiagram-v2
    [*] --> OPEN : 创建回合
    OPEN --> LOCKED : 到达锁单时间
    LOCKED --> SETTLED : 结算完成
    SETTLED --> [*]
```

### 5.2 回合创建流程

**定时创建机制**：
```java
@Scheduled(fixedDelay = 60000) // 每分钟执行
public void createNewRounds() {
    List<SymbolConfig> symbols = symbolConfigService.getAllEnabled();
    List<DurationConfig> durations = durationConfigService.getAllEnabled();
    
    for (SymbolConfig symbol : symbols) {
        for (DurationConfig duration : durations) {
            createRoundIfNeeded(symbol, duration);
        }
    }
}
```

**回合重叠机制**：
- 5分钟回合：每1分钟创建新回合，同时存在5个重叠回合
- 15分钟回合：每3分钟创建新回合，同时存在5个重叠回合
- 30分钟回合：每6分钟创建新回合，同时存在5个重叠回合

### 5.3 回合数据结构

```sql
INSERT INTO trading_round (
    round_no, symbol_id, duration_minutes, 
    start_time, lock_time, end_time,
    status, create_time
) VALUES (
    'BTC_5M_20250804_1030',  -- 回合编号
    1,                        -- BTC/USDT
    5,                        -- 5分钟周期
    '2025-08-04 10:30:00',   -- 开始时间
    '2025-08-04 10:34:30',   -- 锁单时间(结束前30秒)
    '2025-08-04 10:35:00',   -- 结束时间
    'OPEN',                   -- 状态
    NOW()                     -- 创建时间
);
```

## 6. 风控处理流程

### 6.1 风控检查流程

```mermaid
flowchart TD
    A[下单请求] --> B[用户状态检查]
    B --> C{用户正常?}
    C -->|否| D[记录风控日志]
    C -->|是| E[金额限制检查]
    E --> F{金额合规?}
    F -->|否| D
    F -->|是| G[频次限制检查]
    G --> H{频次合规?}
    H -->|否| D
    H -->|是| I[黑名单检查]
    I --> J{在黑名单?}
    J -->|是| D
    J -->|否| K[风控通过]
    D --> L[阻断交易]
    K --> M[继续交易流程]
```

### 6.2 风控规则配置

**风控配置表数据示例**：
```sql
-- 单笔金额限制
INSERT INTO risk_config (config_key, config_value, config_type, description)
VALUES ('order.min.amount', '10.0000000000000000', 'LIMIT', '单笔最小下注金额');

INSERT INTO risk_config (config_key, config_value, config_type, description)
VALUES ('order.max.amount', '10000.0000000000000000', 'LIMIT', '单笔最大下注金额');

-- 频次限制
INSERT INTO risk_config (config_key, config_value, config_type, description)
VALUES ('order.max.per.minute', '5', 'LIMIT', '每分钟最大下单次数');

INSERT INTO risk_config (config_key, config_value, config_type, description)
VALUES ('order.max.per.hour', '100', 'LIMIT', '每小时最大下单次数');

-- 日累计限额
INSERT INTO risk_config (config_key, config_value, config_type, description)
VALUES ('order.daily.limit', '50000.0000000000000000', 'LIMIT', '日累计下注限额');
```

### 6.3 风控日志记录

```java
public void recordRiskLog(Long userId, String riskType, String action, String description) {
    RiskLog log = RiskLog.builder()
        .userId(userId)
        .riskType(riskType)
        .riskLevel(calculateRiskLevel(riskType))
        .action(action)
        .description(description)
        .createTime(LocalDateTime.now())
        .build();
    
    riskLogRepository.save(log);
}
```

## 7. 补偿机制流程 **[v2.0新增：完整的转账补偿系统]**

### 7.1 转账超时补偿总体流程

```mermaid
flowchart TD
    A[补偿任务触发] --> B[查询超时转账记录]
    B --> C{存在PENDING记录?}
    C -->|否| D[结束]
    C -->|是| E[遍历处理每条记录]
    E --> F[查询BTSE实际状态]
    F --> G{BTSE转账成功?}
    G -->|是| H[成功场景处理]
    H --> I[更新本地状态为SUCCESS]
    I --> J[转入:增加余额/转出:无需处理]
    G -->|否| K[失败场景处理]
    K --> L[更新本地状态为FAILED]
    L --> M[转入:无需处理/转出:退回资金]
    J --> N[记录补偿日志]
    M --> N
    N --> O[继续下一条记录]
    O --> E
```

### 7.2 转账补偿详细流程

```mermaid
flowchart TD
    A[转入补偿] --> B[查询PENDING转入记录]
    B --> C{存在PENDING转入?}
    C -->|否| D[转出补偿]
    C -->|是| E[查询BTSE实际状态]
    E --> F{BTSE转入成功?}
    F -->|是| G[更新状态为SUCCESS]
    G --> H[增加frozen_balance]
    H --> I[更新关联订单为ACTIVE]
    F -->|否| J[更新状态为FAILED] 
    J --> K[更新关联订单为CANCELLED]
    I --> D
    K --> D
    D --> L[查询PENDING转出记录]
    L --> M{存在PENDING转出?}
    M -->|否| N[结束]
    M -->|是| O[查询BTSE实际状态]
    O --> P{BTSE转出成功?}
    P -->|是| Q[更新状态为SUCCESS]
    P -->|否| R[更新状态为FAILED]
    R --> S[退回资金给用户]
    Q --> N
    S --> N
```

### 7.3 补偿机制说明

**触发方式**：
- RPC接口：`/rpc/btse-transfer/compensate-transfer-in`、`/rpc/btse-transfer/compensate-transfer-out`
- 定时任务：每分钟自动执行转账补偿
- 手动触发：管理员通过RPC接口主动调用

**补偿范围**：
1. **转入补偿**：处理PENDING状态的BTSE转入记录，同时处理关联的订单状态
2. **转出补偿**：处理PENDING状态的BTSE转出记录

**补偿逻辑**：

**转入补偿流程**：
1. **查询条件**：status = 'PENDING', direction = 'IN', 创建时间超过阈值
2. **处理策略**：
   - 查询BTSE实际转账状态
   - **如果BTSE显示成功**：
     - 更新本地状态为SUCCESS
     - 增加用户frozen_balance（仅下单转入）
     - 更新关联订单状态为ACTIVE
   - **如果BTSE显示失败**：
     - 更新本地状态为FAILED
     - 更新关联订单状态为CANCELLED（如果有关联订单）

**转出补偿流程**：
1. **查询条件**：status = 'PENDING', direction = 'OUT', 创建时间超过阈值
2. **处理策略**：
   - 查询BTSE实际转账状态
   - **如果BTSE显示成功**：更新本地状态为SUCCESS，无需其他操作
   - **如果BTSE显示失败**：更新本地状态为FAILED，退回资金给用户

### 7.4 补偿机制数据变化

**转入补偿成功场景**：
```sql
-- 1. 更新转入日志状态
UPDATE btse_transfer_log SET 
    status = 'SUCCESS',
    success_time = NOW(),
    response_data = '{"compensation":true,"btseStatus":"success"}'
WHERE trace_id = 'ORDER_1_20250813' AND direction = 'IN';

-- 2. 原子性增加frozen_balance（仅针对下单转入）
UPDATE account SET 
    frozen_balance = frozen_balance + 100.0000000000000000,
    update_time = NOW()
WHERE user_id = 1 AND account_type = 'REAL';

-- 3. 更新关联订单为ACTIVE
UPDATE option_order SET 
    status = 'ACTIVE',
    update_time = NOW()
WHERE id = 1 AND status = 'PENDING';

-- 4. 记录补偿流水
INSERT INTO account_transaction (user_id, account_id, type, amount, frozen_amount,
    description, ref_id, ref_type, create_time)
VALUES (1, 1, 'BTSE_IN', 0.0000000000000000, 100.0000000000000000,
    'BTSE转入补偿确认', 1, 'BTSE_TRANSFER', NOW());
```

**转入补偿失败场景**：
```sql
-- 1. 更新转入日志状态
UPDATE btse_transfer_log SET 
    status = 'FAILED',
    error_message = '补偿检查发现BTSE转入失败',
    update_time = NOW()
WHERE trace_id = 'ORDER_1_20250813' AND direction = 'IN';

-- 2. 更新关联订单为CANCELLED
UPDATE option_order SET 
    status = 'CANCELLED',
    cancel_reason = 'BTSE转入失败',
    update_time = NOW()
WHERE id = 1 AND status = 'PENDING';

-- 注意：转入失败不需要退回资金，因为资金从未成功转入
```

**转出补偿失败场景（需退回资金）**：
```sql
-- 1. 更新转出日志状态
UPDATE btse_transfer_log SET 
    status = 'FAILED',
    error_message = '补偿检查发现BTSE转出失败',
    update_time = NOW()
WHERE trace_id = 'SETTLEMENT_1_20250813' AND direction = 'OUT';

-- 2. 根据转出类型退回资金
-- 如果是结算盈利转出失败，退回到balance
-- 如果是平局本金转出失败，退回到balance
UPDATE account SET 
    balance = balance + 90.0000000000000000,  -- 退回金额
    update_time = NOW()
WHERE user_id = 1 AND account_type = 'REAL';

-- 3. 记录退款流水
INSERT INTO account_transaction (user_id, account_id, type, amount,
    description, ref_id, ref_type, create_time)
VALUES (1, 1, 'REFUND', 90.0000000000000000,
    'BTSE转出失败补偿退款', 1, 'BTSE_TRANSFER', NOW());
```


## 8. 异常处理流程

### 8.1 BTSE API异常处理

```mermaid
flowchart TD
    A[BTSE API调用] --> B{调用成功?}
    B -->|是| C[正常处理]
    B -->|否| D[记录异常日志]
    D --> E{重要操作?}
    E -->|是| F[发送告警]
    E -->|否| G[使用降级策略]
    F --> H[人工介入]
    G --> I[继续处理]
```

### 8.2 数据一致性处理

**BTSE划转失败处理**：
1. **下单时划转失败**：直接返回失败，不创建订单
2. **结算时转出失败**：资金保留在平台，记录异常待处理
3. **补偿机制**：定时任务重试失败的转账操作

**数据库事务处理**：
```java
@Transactional(rollbackFor = Exception.class)
public void settleOrder(Order order) {
    try {
        // 1. 更新订单状态
        updateOrderStatus(order);
        
        // 2. 处理账户资金
        processAccountBalance(order);
        
        // 3. 记录资金流水
        recordTransaction(order);
        
        // 4. BTSE转出（可能失败）
        if (needTransferToBtse(order)) {
            transferToBtse(order);
        }
    } catch (BtseTransferException e) {
        // BTSE转出失败，记录待处理
        recordPendingTransfer(order, e);
        // 不回滚本地事务
    }
}
```

---
**文档版本**: v2.0  
**最后更新**: 2025年8月13日  
**维护者**: Barry  
**更新说明**: 
- v2.0: 完善PENDING预订单机制、BTSE转账集成、补偿机制详细流程
- 新增详细的数据表变化逻辑和SQL示例
- 优化下单、结算、补偿的完整业务流程设计

**相关文档**: [详细设计概述](./207_01_详细设计概述.md), [系统架构设计](./207_02_系统架构设计.md), [API接口设计](./207_04_API接口设计.md), [BTSE API接入方案](./212_BTSE—API接入方案.md)