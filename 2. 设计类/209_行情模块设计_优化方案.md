# 行情数据存储优化方案

## 1. 分层存储策略

### 1.1 数据分级

```yaml
实时数据层（秒级）:
  - 存储位置: Redis内存
  - 保留时间: 1小时
  - 用途: 实时查询、实时推送

近期数据层（分钟级）:
  - 存储位置: MySQL热表
  - 保留时间: 7天
  - 用途: 近期K线查询、订单结算

历史数据层（小时/日级）:
  - 存储位置: MySQL冷表/归档表
  - 保留时间: 永久
  - 用途: 历史报表、数据分析
```

### 1.2 实现代码

```java
@Service
@Slf4j
public class MarketDataStorageService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final MarketDataMapper marketDataMapper;
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(5);
    
    /**
     * 接收实时行情数据
     */
    @EventListener
    public void onMarketData(MarketDataEvent event) {
        String symbol = event.getSymbol();
        BigDecimal price = event.getPrice();
        long timestamp = event.getTimestamp();
        
        // 1. 存储到Redis（秒级数据）
        saveToRedis(symbol, price, timestamp);
        
        // 2. 聚合到分钟数据
        aggregateToMinute(symbol, price, timestamp);
        
        // 3. 实时推送
        pushRealtime(symbol, price, timestamp);
    }
    
    /**
     * 保存到Redis（滑动窗口）
     */
    private void saveToRedis(String symbol, BigDecimal price, long timestamp) {
        String key = "market:tick:" + symbol;
        
        // 使用Redis的Sorted Set，score为时间戳
        redisTemplate.opsForZSet().add(key, 
            new TickData(price, timestamp), 
            timestamp);
        
        // 只保留最近1小时的数据
        long oneHourAgo = timestamp - 3600000;
        redisTemplate.opsForZSet().removeRangeByScore(key, 0, oneHourAgo);
    }
    
    /**
     * 聚合分钟数据
     */
    private void aggregateToMinute(String symbol, BigDecimal price, long timestamp) {
        String minuteKey = getMinuteKey(symbol, timestamp);
        String redisKey = "market:minute:" + minuteKey;
        
        // 使用Redis聚合当前分钟的数据
        MinuteAggregator aggregator = getOrCreateAggregator(redisKey);
        aggregator.addPrice(price);
        
        // 分钟结束时持久化到数据库
        if (isMinuteEnd(timestamp)) {
            persistMinuteData(symbol, aggregator);
        }
    }
}
```

## 2. 数据压缩策略

### 2.1 分钟K线聚合

```java
@Component
@Slf4j
public class KLineAggregationService {
    
    /**
     * 分钟K线数据结构（只保存OHLCV）
     */
    @Data
    public static class MinuteKLine {
        private String symbol;
        private LocalDateTime time;
        private BigDecimal open;      // 开盘价
        private BigDecimal high;      // 最高价
        private BigDecimal low;       // 最低价
        private BigDecimal close;     // 收盘价
        private BigDecimal volume;    // 成交量（如果有）
        private Integer tickCount;    // 价格变动次数
    }
    
    /**
     * 聚合秒级数据到分钟K线
     */
    public MinuteKLine aggregate(String symbol, List<TickData> ticks) {
        if (ticks.isEmpty()) {
            return null;
        }
        
        MinuteKLine kline = new MinuteKLine();
        kline.setSymbol(symbol);
        kline.setOpen(ticks.get(0).getPrice());
        kline.setClose(ticks.get(ticks.size() - 1).getPrice());
        kline.setHigh(ticks.stream()
            .map(TickData::getPrice)
            .max(BigDecimal::compareTo)
            .orElse(BigDecimal.ZERO));
        kline.setLow(ticks.stream()
            .map(TickData::getPrice)
            .min(BigDecimal::compareTo)
            .orElse(BigDecimal.ZERO));
        kline.setTickCount(ticks.size());
        
        return kline;
    }
}
```

### 2.2 定时聚合任务

```java
@Component
@Slf4j
public class MarketDataAggregationJob {
    
    /**
     * 每分钟执行：聚合上一分钟的秒级数据
     */
    @Scheduled(cron = "0 * * * * ?")
    public void aggregateMinuteData() {
        LocalDateTime previousMinute = LocalDateTime.now()
            .truncatedTo(ChronoUnit.MINUTES)
            .minusMinutes(1);
        
        for (String symbol : getActiveSymbols()) {
            try {
                // 从Redis获取上一分钟的所有tick数据
                List<TickData> ticks = getTicksFromRedis(symbol, previousMinute);
                
                if (!ticks.isEmpty()) {
                    // 聚合成分钟K线
                    MinuteKLine kline = aggregationService.aggregate(symbol, ticks);
                    
                    // 保存到数据库
                    marketDataMapper.insertMinuteKLine(kline);
                    
                    // 清理Redis中的过期数据（可选）
                    cleanupRedisData(symbol, previousMinute);
                }
            } catch (Exception e) {
                log.error("聚合{}分钟数据失败", symbol, e);
            }
        }
    }
    
    /**
     * 每小时执行：聚合小时K线
     */
    @Scheduled(cron = "0 0 * * * ?")
    public void aggregateHourlyData() {
        LocalDateTime previousHour = LocalDateTime.now()
            .truncatedTo(ChronoUnit.HOURS)
            .minusHours(1);
        
        for (String symbol : getActiveSymbols()) {
            // 从分钟表聚合成小时数据
            HourlyKLine hourly = marketDataMapper.aggregateToHour(
                symbol, previousHour, previousHour.plusHours(1)
            );
            
            if (hourly != null) {
                marketDataMapper.insertHourlyKLine(hourly);
            }
        }
    }
    
    /**
     * 每天凌晨执行：清理过期数据
     */
    @Scheduled(cron = "0 0 2 * * ?")
    public void cleanupOldData() {
        // 删除7天前的分钟数据
        LocalDateTime cutoffTime = LocalDateTime.now().minusDays(7);
        int deleted = marketDataMapper.deleteMinuteDataBefore(cutoffTime);
        log.info("清理了{}条过期分钟数据", deleted);
    }
}
```

## 3. 查询优化策略

### 3.1 混合查询服务

```java
@Service
public class OptimizedPriceService {
    
    /**
     * 获取最新价格（优先内存）
     */
    public BigDecimal getCurrentPrice(String symbol) {
        // 1. 从本地缓存获取（毫秒级）
        BigDecimal cached = localCache.get(symbol);
        if (cached != null) {
            return cached;
        }
        
        // 2. 从Redis获取最新tick
        TickData latest = getLatestTickFromRedis(symbol);
        if (latest != null) {
            localCache.put(symbol, latest.getPrice());
            return latest.getPrice();
        }
        
        // 3. 从数据库获取最新分钟数据
        MinuteKLine lastMinute = marketDataMapper.findLatestMinute(symbol);
        if (lastMinute != null) {
            return lastMinute.getClose();
        }
        
        throw new PriceNotFoundException(symbol);
    }
    
    /**
     * 获取历史价格（智能路由）
     */
    public List<PricePoint> getHistoricalPrices(String symbol, 
                                                LocalDateTime start, 
                                                LocalDateTime end) {
        Duration duration = Duration.between(start, end);
        
        // 根据时间范围选择数据源
        if (duration.toHours() <= 1) {
            // 1小时内：从Redis获取秒级数据
            return getSecondsFromRedis(symbol, start, end);
        } else if (duration.toDays() <= 7) {
            // 7天内：从分钟表获取
            return getMinutesFromDB(symbol, start, end);
        } else {
            // 7天以上：从小时表获取
            return getHoursFromDB(symbol, start, end);
        }
    }
}
```

## 4. 数据库表设计优化

### 4.1 分区表设计

```sql
-- 分钟数据表（按月分区）
CREATE TABLE `market_data_minute` (
    `id` bigint NOT NULL AUTO_INCREMENT,
    `symbol` varchar(16) NOT NULL,
    `time` datetime NOT NULL,
    `open` decimal(32,16) NOT NULL,
    `high` decimal(32,16) NOT NULL,
    `low` decimal(32,16) NOT NULL,
    `close` decimal(32,16) NOT NULL,
    `tick_count` int NOT NULL DEFAULT 0,
    PRIMARY KEY (`id`, `time`),
    KEY `idx_symbol_time` (`symbol`, `time`)
) ENGINE=InnoDB
PARTITION BY RANGE (TO_DAYS(time)) (
    PARTITION p202501 VALUES LESS THAN (TO_DAYS('2025-02-01')),
    PARTITION p202502 VALUES LESS THAN (TO_DAYS('2025-03-01')),
    -- 更多分区...
);

-- 小时数据表（长期存储）
CREATE TABLE `market_data_hourly` (
    `id` bigint NOT NULL AUTO_INCREMENT,
    `symbol` varchar(16) NOT NULL,
    `time` datetime NOT NULL,
    `open` decimal(32,16) NOT NULL,
    `high` decimal(32,16) NOT NULL,
    `low` decimal(32,16) NOT NULL,
    `close` decimal(32,16) NOT NULL,
    `tick_count` int NOT NULL DEFAULT 0,
    PRIMARY KEY (`id`),
    UNIQUE KEY `uk_symbol_time` (`symbol`, `time`),
    KEY `idx_time` (`time`)
) ENGINE=InnoDB;

-- 创建定期清理分区的存储过程
DELIMITER $$
CREATE PROCEDURE `cleanup_old_partitions`()
BEGIN
    DECLARE cutoff_date DATE DEFAULT DATE_SUB(CURDATE(), INTERVAL 7 DAY);
    DECLARE partition_name VARCHAR(64);
    
    -- 删除7天前的分区
    SELECT PARTITION_NAME INTO partition_name
    FROM INFORMATION_SCHEMA.PARTITIONS
    WHERE TABLE_NAME = 'market_data_minute'
    AND PARTITION_DESCRIPTION < TO_DAYS(cutoff_date)
    LIMIT 1;
    
    IF partition_name IS NOT NULL THEN
        SET @sql = CONCAT('ALTER TABLE market_data_minute DROP PARTITION ', partition_name);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
    END IF;
END$$
DELIMITER ;
```

## 5. 监控和报警

```java
@Component
@Slf4j
public class MarketDataMonitor {
    
    private final MeterRegistry meterRegistry;
    
    @EventListener
    public void onDataReceived(MarketDataEvent event) {
        // 记录接收速率
        meterRegistry.counter("market.data.received", 
            "symbol", event.getSymbol()).increment();
    }
    
    @Scheduled(fixedRate = 60000)
    public void checkDataIntegrity() {
        for (String symbol : getActiveSymbols()) {
            // 检查数据延迟
            long lastUpdate = getLastUpdateTime(symbol);
            long delay = System.currentTimeMillis() - lastUpdate;
            
            if (delay > 5000) { // 5秒无更新
                log.warn("{}行情数据延迟: {}ms", symbol, delay);
                // 发送告警
                alertService.sendAlert("MARKET_DATA_DELAY", symbol, delay);
            }
        }
    }
}
```

## 6. 总结

### 6.1 存储成本对比

| 方案 | 存储量（年） | 存储成本 | 查询性能 |
|------|------------|----------|----------|
| 全量秒级存储 | 3.15亿条 | 极高 | 差 |
| 分层存储方案 | 500万条 | 低 | 优 |

### 6.2 关键优化点

1. **内存缓存**：秒级数据只在Redis保存1小时
2. **数据聚合**：分钟/小时/日级聚合，大幅减少数据量
3. **分区表**：自动清理过期数据，维护性能
4. **智能查询**：根据时间范围自动选择数据源
5. **异步处理**：聚合任务异步执行，不影响实时性

### 6.3 业务影响

- 订单结算：使用分钟级数据足够精确
- 实时展示：使用Redis秒级数据
- 历史查询：使用聚合后的数据，性能更好