# 二元期权平台技术实现（基础篇）

## 1. 后台服务技术实现

### 1.1 数据获取机制

option-admin-service作为后台管理服务，通过多种方式获取数据：

#### 1.1.1 直接数据库查询

```java
@Service
public class AdminUserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private AccountRepository accountRepository;
    
    // 用户列表查询(支持分页、筛选)
    public PageResult<UserVO> getUserList(UserQueryDTO query) {
        // 直接查询数据库，支持复杂条件筛选
        return userRepository.findByConditions(query);
    }
    
    // 用户详情及关联账户信息
    public UserDetailVO getUserDetail(Long userId) {
        User user = userRepository.findById(userId);
        List<Account> accounts = accountRepository.findByUserId(userId);
        return UserDetailVO.builder()
            .user(user)
            .accounts(accounts)
            .build();
    }
}
```

#### 1.1.2 RPC调用业务服务

```java
@Component
public class AdminOrderService {
    
    @Autowired
    private OrderServiceClient orderServiceClient;  // Feign客户端
    
    @Autowired
    private CommonServiceClient commonServiceClient;
    
    // 获取订单详情(通过RPC调用)
    public OrderDetailVO getOrderDetail(Long orderId) {
        OrderDTO order = orderServiceClient.getOrder(orderId);
        UserDTO user = commonServiceClient.getUser(order.getUserId());
        
        return OrderDetailVO.builder()
            .order(order)
            .user(user)
            .build();
    }
    
    // 手动结算回合
    public void manualSettleRound(Long roundId, ManualSettleRequest request) {
        orderServiceClient.manualSettle(roundId, request);
    }
}
```

### 1.2 统计数据实现

#### 1.2.1 定时统计任务

```java
@Component
public class StatsCalculationJob {
    
    @Autowired
    private DailyStatsService dailyStatsService;
    
    @Autowired
    private HourlyStatsService hourlyStatsService;
    
    // 每小时执行一次，计算上一小时统计
    @XxlJob("calculateHourlyStats")
    public void calculateHourlyStats() {
        LocalDateTime lastHour = LocalDateTime.now().minusHours(1)
            .withMinute(0).withSecond(0).withNano(0);
        
        List<SymbolConfig> symbols = symbolConfigService.getAllEnabled();
        
        // 按交易对统计
        for (SymbolConfig symbol : symbols) {
            HourlyStats stats = calculateHourlyStatsForSymbol(lastHour, symbol.getId());
            hourlyStatsService.save(stats);
        }
        
        // 全局统计
        HourlyStats globalStats = calculateHourlyStatsForSymbol(lastHour, null);
        hourlyStatsService.save(globalStats);
    }
    
    // 每日凌晨2点执行，计算昨日统计
    @XxlJob("calculateDailyStats")
    public void calculateDailyStats() {
        LocalDate yesterday = LocalDate.now().minusDays(1);
        
        List<SymbolConfig> symbols = symbolConfigService.getAllEnabled();
        
        // 按交易对统计
        for (SymbolConfig symbol : symbols) {
            DailyStats stats = calculateDailyStatsForSymbol(yesterday, symbol.getId());
            dailyStatsService.save(stats);
        }
        
        // 全局统计
        DailyStats globalStats = calculateDailyStatsForSymbol(yesterday, null);
        dailyStatsService.save(globalStats);
    }
    
    // 计算指定日期和交易对的统计数据
    private DailyStats calculateDailyStatsForSymbol(LocalDate date, Long symbolId) {
        String symbolCondition = symbolId != null ? "AND symbol_id = ?" : "";
        List<Object> params = new ArrayList<>();
        params.add(date);
        if (symbolId != null) params.add(symbolId);
        
        String sql = \"\"\"
            SELECT 
                COUNT(DISTINCT o.user_id) as active_users,
                COUNT(o.id) as total_orders,
                COUNT(CASE WHEN o.status = 'PENDING' THEN 1 END) as pending_orders,
                COUNT(CASE WHEN o.status = 'WIN' THEN 1 END) as win_orders,
                COUNT(CASE WHEN o.status = 'LOSE' THEN 1 END) as lose_orders,
                COUNT(CASE WHEN o.status = 'DRAW' THEN 1 END) as draw_orders,
                COALESCE(SUM(o.amount), 0) as total_volume,
                COALESCE(SUM(CASE WHEN o.profit > 0 THEN o.profit ELSE 0 END), 0) as total_profit,
                COALESCE(SUM(CASE WHEN o.profit < 0 THEN ABS(o.profit) ELSE 0 END), 0) as total_loss,
                COALESCE(SUM(o.fee), 0) as total_fee,
                COALESCE(AVG(o.amount), 0) as avg_order_amount
            FROM option_order o
            WHERE DATE(o.create_time) = ? {symbolCondition}
            \"\"\".replace(\"{symbolCondition}\", symbolCondition);
        
        // 查询新增用户数
        String newUserSql = \"SELECT COUNT(*) FROM user WHERE DATE(create_time) = ?\";
        int newUsers = jdbcTemplate.queryForObject(newUserSql, Integer.class, date);
        
        // 查询总用户数(截止到当日)
        String totalUserSql = \"SELECT COUNT(*) FROM user WHERE DATE(create_time) <= ?\";
        int totalUsers = jdbcTemplate.queryForObject(totalUserSql, Integer.class, date);
        
        return jdbcTemplate.queryForObject(sql, params.toArray(), (rs, rowNum) -> {
            int totalOrders = rs.getInt(\"total_orders\");
            int winOrders = rs.getInt(\"win_orders\");
            BigDecimal winRate = totalOrders > 0 ? 
                BigDecimal.valueOf(winOrders).divide(BigDecimal.valueOf(totalOrders), 4, RoundingMode.HALF_UP) : 
                BigDecimal.ZERO;
            
            return DailyStats.builder()
                .statDate(date)
                .symbolId(symbolId)
                .totalUsers(totalUsers)
                .activeUsers(rs.getInt(\"active_users\"))
                .newUsers(newUsers)
                .totalOrders(totalOrders)
                .pendingOrders(rs.getInt(\"pending_orders\"))
                .winOrders(winOrders)
                .loseOrders(rs.getInt(\"lose_orders\"))
                .drawOrders(rs.getInt(\"draw_orders\"))
                .totalVolume(rs.getBigDecimal(\"total_volume\"))
                .totalProfit(rs.getBigDecimal(\"total_profit\"))
                .totalLoss(rs.getBigDecimal(\"total_loss\"))
                .totalFee(rs.getBigDecimal(\"total_fee\"))
                .winRate(winRate)
                .avgOrderAmount(rs.getBigDecimal(\"avg_order_amount\"))
                .createTime(LocalDateTime.now())
                .updateTime(LocalDateTime.now())
                .build();
        });
    }
}
```

#### 1.2.2 统计查询服务

```java
@Service
public class AdminStatsService {
    
    @Autowired
    private DailyStatsRepository dailyStatsRepository;
    
    @Autowired
    private HourlyStatsRepository hourlyStatsRepository;
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    // 查询历史统计数据(从预计算表)
    public List<DailyStatsVO> getDailyStats(String startDate, String endDate, Long symbolId) {
        LocalDate start = LocalDate.parse(startDate);
        LocalDate end = LocalDate.parse(endDate);
        
        return dailyStatsRepository.findByDateRangeAndSymbol(start, end, symbolId)
            .stream()
            .map(this::convertToVO)
            .collect(Collectors.toList());
    }
    
    // 查询当日实时统计(直接计算)
    public DailyStatsVO getTodayStats(Long symbolId) {
        LocalDate today = LocalDate.now();
        
        // 先尝试从统计表查询
        Optional<DailyStats> cached = dailyStatsRepository.findByStatDateAndSymbolId(today, symbolId);
        if (cached.isPresent()) {
            return convertToVO(cached.get());
        }
        
        // 实时计算当日数据
        return calculateRealtimeStats(today, symbolId);
    }
    
    // 实时监控数据
    public RealtimeMonitorVO getRealtimeMonitor() {
        String sql = \"\"\"
            SELECT 
                (SELECT COUNT(*) FROM trading_round WHERE status IN ('OPEN', 'LOCKED')) as active_rounds,
                (SELECT COUNT(*) FROM option_order WHERE create_time >= DATE_SUB(NOW(), INTERVAL 1 HOUR)) as recent_orders,
                (SELECT COUNT(*) FROM user WHERE create_time >= CURDATE()) as today_new_users,
                (SELECT COUNT(DISTINCT user_id) FROM option_order WHERE create_time >= CURDATE()) as today_active_users
            \"\"\";
        
        return jdbcTemplate.queryForObject(sql, (rs, rowNum) -> 
            RealtimeMonitorVO.builder()
                .activeRounds(rs.getInt(\"active_rounds\"))
                .recentOrders(rs.getInt(\"recent_orders\"))
                .todayNewUsers(rs.getInt(\"today_new_users\"))
                .todayActiveUsers(rs.getInt(\"today_active_users\"))
                .timestamp(System.currentTimeMillis())
                .build());
    }
}
```

### 1.3 配置管理实现

```java
@Service
public class AdminConfigService {
    
    @Autowired
    private RiskConfigRepository riskConfigRepository;
    
    @Autowired
    private SymbolConfigRepository symbolConfigRepository;
    
    @Autowired
    private RedisTemplate redisTemplate;
    
    // 动态更新风控配置
    @Transactional
    public void updateRiskConfig(String configKey, String configValue) {
        RiskConfig config = riskConfigRepository.findByConfigKey(configKey);
        if (config != null) {
            config.setConfigValue(configValue);
            config.setUpdateTime(LocalDateTime.now());
            riskConfigRepository.save(config);
            
            // 更新Redis缓存，供其他服务实时读取
            redisTemplate.opsForHash().put(\"risk_configs\", configKey, configValue);
        }
    }
    
    // 币种配置管理
    public void updateSymbolConfig(Long symbolId, SymbolConfigUpdateRequest request) {
        SymbolConfig config = symbolConfigRepository.findById(symbolId).orElseThrow();
        config.setEnabled(request.getEnabled());
        config.setMinAmount(request.getMinAmount());
        config.setMaxAmount(request.getMaxAmount());
        symbolConfigRepository.save(config);
        
        // 更新Redis缓存
        redisTemplate.opsForHash().put(\"symbol_configs\", symbolId.toString(), 
            JSON.toJSONString(config));
    }
    
    // 黑名单管理
    public void addToBlacklist(Long userId, String reason) {
        // 1. 保存到数据库
        Blacklist blacklist = Blacklist.builder()
            .userId(userId)
            .reason(reason)
            .status((byte)1)
            .startTime(LocalDateTime.now())
            .build();
        blacklistRepository.save(blacklist);
        
        // 2. 添加到Redis集合，供业务服务快速查询
        redisTemplate.opsForSet().add(\"blacklist_users\", userId.toString());
    }
    
    public void removeFromBlacklist(Long userId) {
        // 1. 更新数据库状态
        Blacklist blacklist = blacklistRepository.findByUserIdAndStatus(userId, (byte)1);
        if (blacklist != null) {
            blacklist.setStatus((byte)0);
            blacklist.setUpdateTime(LocalDateTime.now());
            blacklistRepository.save(blacklist);
        }
        
        // 2. 从Redis集合移除
        redisTemplate.opsForSet().remove(\"blacklist_users\", userId.toString());
    }
}
```

## 2. 回合管理策略

### 2.1 回合生成机制

#### 2.1.1 定时任务生成回合

```java
@Component
public class RoundGenerationJob {
    
    @Autowired
    private TradingRoundService tradingRoundService;
    
    @Autowired
    private SymbolConfigService symbolConfigService;
    
    @Autowired
    private DurationConfigService durationConfigService;
    
    @XxlJob(\"generateTradingRounds\")
    public void generateTradingRounds() {
        List<SymbolConfig> symbols = symbolConfigService.getAllEnabled();
        List<DurationConfig> durations = durationConfigService.getAllEnabled();
        
        for (SymbolConfig symbol : symbols) {
            for (DurationConfig duration : durations) {
                createRoundIfNeeded(symbol, duration);
            }
        }
    }
    
    private void createRoundIfNeeded(SymbolConfig symbol, DurationConfig duration) {
        LocalDateTime now = LocalDateTime.now();
        
        // 计算下一个回合的开始时间
        LocalDateTime nextRoundStart = calculateNextRoundStart(now, duration.getDurationMinutes());
        
        // 检查是否已存在该时间的回合
        String roundNo = generateRoundNo(symbol.getSymbol(), duration.getDurationMinutes(), nextRoundStart);
        
        if (!tradingRoundService.existsByRoundNo(roundNo)) {
            TradingRound round = TradingRound.builder()
                .roundNo(roundNo)
                .symbolId(symbol.getId())
                .durationMinutes(duration.getDurationMinutes())
                .startTime(nextRoundStart)
                .lockTime(nextRoundStart.plusMinutes(duration.getDurationMinutes()).minusSeconds(duration.getLockSeconds()))
                .endTime(nextRoundStart.plusMinutes(duration.getDurationMinutes()))
                .status(\"OPEN\")
                .createTime(LocalDateTime.now())
                .updateTime(LocalDateTime.now())
                .build();
                
            tradingRoundService.save(round);
            log.info(\"Created new trading round: {}\", roundNo);
        }
    }
    
    private LocalDateTime calculateNextRoundStart(LocalDateTime now, int durationMinutes) {
        // 根据周期计算下一个整点开始时间
        LocalDateTime roundedNow = now.withSecond(0).withNano(0);
        
        if (durationMinutes == 5) {
            // 5分钟周期：每整5分钟开始 (10:00, 10:05, 10:10...)
            int minute = roundedNow.getMinute();
            int nextMinute = ((minute / 5) + 1) * 5;
            return roundedNow.withMinute(0).plusMinutes(nextMinute);
        } else if (durationMinutes == 15) {
            // 15分钟周期：每整15分钟开始 (10:00, 10:15, 10:30, 10:45)  
            int minute = roundedNow.getMinute();
            int nextMinute = ((minute / 15) + 1) * 15;
            return roundedNow.withMinute(0).plusMinutes(nextMinute);
        } else if (durationMinutes == 30) {
            // 30分钟周期：每整30分钟开始 (10:00, 10:30, 11:00...)
            int minute = roundedNow.getMinute();
            int nextMinute = minute < 30 ? 30 : 60;
            return roundedNow.withMinute(0).plusMinutes(nextMinute);
        }
        
        // 默认下一分钟开始
        return roundedNow.plusMinutes(1);
    }
    
    private String generateRoundNo(String symbol, int duration, LocalDateTime startTime) {
        return String.format(\"%s_%dM_%s\",
            symbol.replace(\"/\", \"\"),
            duration,
            startTime.format(DateTimeFormatter.ofPattern(\"yyyyMMdd_HHmm\")));
    }
}
```

### 2.2 倒计时实现

```java
@Component
public class RoundCountdownService {
    
    @Autowired
    private TradingRoundService tradingRoundService;
    
    public RoundCountdownVO getCurrentCountdown(Long symbolId, Integer duration) {
        TradingRound round = tradingRoundService.getCurrentRound(symbolId, duration);
        if (round == null) {
            return RoundCountdownVO.builder()
                .status(\"NO_ROUND\")
                .remainingSeconds(0)
                .build();
        }
        
        long now = System.currentTimeMillis();
        long lockTime = round.getLockTime().atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();
        long endTime = round.getEndTime().atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();
        
        if (now >= endTime) {
            return RoundCountdownVO.builder()
                .roundId(round.getId())
                .roundNo(round.getRoundNo())
                .status(\"SETTLED\")
                .remainingSeconds(0)
                .build();
        } else if (now >= lockTime) {
            return RoundCountdownVO.builder()
                .roundId(round.getId())
                .roundNo(round.getRoundNo())
                .status(\"LOCKED\")
                .remainingSeconds((int)((endTime - now) / 1000))
                .build();
        } else {
            return RoundCountdownVO.builder()
                .roundId(round.getId())
                .roundNo(round.getRoundNo())
                .status(\"OPEN\")
                .remainingSeconds((int)((lockTime - now) / 1000))
                .lockWarning(now >= lockTime - 30000) // 前30秒警告
                .canOrder(true)
                .build();
        }
    }
}
```

## 3. 风控限额校验实现

### 3.1 Redis滑动窗口限额方案

使用Redis实现用户交易限额校验：

**Redis存储结构**:
```redis
# 用户各维度限额追踪
user_daily_limit:{userId}:{date} = {amount}     # 日限额，24小时过期
user_weekly_limit:{userId}:{week} = {amount}    # 周限额，7天过期  
user_monthly_limit:{userId}:{month} = {amount}  # 月限额，30天过期

# 频次限制
user_minute_count:{userId}:{minute} = {count}   # 分钟频次，1分钟过期
user_hour_count:{userId}:{hour} = {count}       # 小时频次，1小时过期
```

### 3.2 限额校验服务实现

```java
@Service
public class RiskControlService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Autowired
    private RiskConfigRepository riskConfigRepository;
    
    // 下单前限额校验
    public RiskCheckResult checkBetLimit(Long userId, BigDecimal amount, String accountType) {
        LocalDateTime now = LocalDateTime.now();
        
        try {
            // 1. 单笔限额检查
            RiskCheckResult singleCheck = checkSingleBetLimit(amount);
            if (!singleCheck.isPass()) {
                return singleCheck;
            }
            
            // 2. 黑名单检查
            if (isUserBlacklisted(userId)) {
                return RiskCheckResult.block(\"用户已被加入黑名单\");
            }
            
            // 3. 频次限制检查
            RiskCheckResult frequencyCheck = checkFrequencyLimit(userId, now);
            if (!frequencyCheck.isPass()) {
                return frequencyCheck;
            }
            
            // 4. 金额限额检查
            RiskCheckResult amountCheck = checkAmountLimit(userId, amount, now);
            if (!amountCheck.isPass()) {
                return amountCheck;
            }
            
            return RiskCheckResult.pass();
            
        } catch (Exception e) {
            log.error(\"Risk check failed for user: {}\", userId, e);
            // 风控异常时选择保守策略：阻断
            return RiskCheckResult.block(\"风控系统异常，请稍后重试\");
        }
    }
    
    private RiskCheckResult checkSingleBetLimit(BigDecimal amount) {
        BigDecimal minAmount = getRiskConfigValue(\"MIN_BET_AMOUNT\", \"10\");
        BigDecimal maxAmount = getRiskConfigValue(\"MAX_BET_AMOUNT\", \"10000\");
        
        if (amount.compareTo(minAmount) < 0) {
            return RiskCheckResult.block(\"单笔投注金额不能低于\" + minAmount);
        }
        
        if (amount.compareTo(maxAmount) > 0) {
            return RiskCheckResult.block(\"单笔投注金额不能超过\" + maxAmount);
        }
        
        return RiskCheckResult.pass();
    }
    
    private RiskCheckResult checkFrequencyLimit(Long userId, LocalDateTime now) {
        // 分钟频次检查
        String minuteKey = String.format(\"user_minute_count:%d:%s\", 
            userId, now.format(DateTimeFormatter.ofPattern(\"yyyyMMddHHmm\")));
        
        Integer minuteCount = getCountFromRedis(minuteKey);
        Integer maxPerMinute = getRiskConfigValue(\"MAX_BET_PER_MINUTE\", \"5\").intValue();
        
        if (minuteCount >= maxPerMinute) {
            return RiskCheckResult.block(\"每分钟最多允许下单\" + maxPerMinute + \"次\");
        }
        
        // 小时频次检查
        String hourKey = String.format(\"user_hour_count:%d:%s\", 
            userId, now.format(DateTimeFormatter.ofPattern(\"yyyyMMddHH\")));
        
        Integer hourCount = getCountFromRedis(hourKey);
        Integer maxPerHour = getRiskConfigValue(\"MAX_BET_PER_HOUR\", \"100\").intValue();
        
        if (hourCount >= maxPerHour) {
            return RiskCheckResult.block(\"每小时最多允许下单\" + maxPerHour + \"次\");
        }
        
        return RiskCheckResult.pass();
    }
    
    private RiskCheckResult checkAmountLimit(Long userId, BigDecimal amount, LocalDateTime now) {
        LocalDate today = now.toLocalDate();
        
        // 日限额检查
        String dailyKey = String.format(\"user_daily_limit:%d:%s\", 
            userId, today.format(DateTimeFormatter.ofPattern(\"yyyyMMdd\")));
        
        BigDecimal dailyUsed = getAmountFromRedis(dailyKey);
        BigDecimal dailyLimit = getRiskConfigValue(\"DAILY_BET_LIMIT\", \"100000\");
        
        if (dailyUsed.add(amount).compareTo(dailyLimit) > 0) {
            return RiskCheckResult.block(String.format(\"日投注额度超限，当前已用:%.2f，限额:%.2f\", 
                dailyUsed, dailyLimit));
        }
        
        // 周限额检查
        String weekKey = String.format(\"user_weekly_limit:%d:%s\", 
            userId, getWeekKey(today));
        
        BigDecimal weeklyUsed = getAmountFromRedis(weekKey);
        BigDecimal weeklyLimit = getRiskConfigValue(\"WEEKLY_BET_LIMIT\", \"500000\");
        
        if (weeklyUsed.add(amount).compareTo(weeklyLimit) > 0) {
            return RiskCheckResult.block(\"周投注额度超限\");
        }
        
        // 月限额检查
        String monthlyKey = String.format(\"user_monthly_limit:%d:%s\", 
            userId, today.format(DateTimeFormatter.ofPattern(\"yyyyMM\")));
        
        BigDecimal monthlyUsed = getAmountFromRedis(monthlyKey);
        BigDecimal monthlyLimit = getRiskConfigValue(\"MONTHLY_BET_LIMIT\", \"2000000\");
        
        if (monthlyUsed.add(amount).compareTo(monthlyLimit) > 0) {
            return RiskCheckResult.block(\"月投注额度超限\");
        }
        
        return RiskCheckResult.pass();
    }
    
    // 下单成功后更新限额使用量
    public void updateBetLimitUsage(Long userId, BigDecimal amount) {
        LocalDateTime now = LocalDateTime.now();
        LocalDate today = now.toLocalDate();
        
        // 更新频次计数
        String minuteKey = String.format(\"user_minute_count:%d:%s\", 
            userId, now.format(DateTimeFormatter.ofPattern(\"yyyyMMddHHmm\")));
        String hourKey = String.format(\"user_hour_count:%d:%s\", 
            userId, now.format(DateTimeFormatter.ofPattern(\"yyyyMMddHH\")));
        
        redisTemplate.opsForValue().increment(minuteKey);
        redisTemplate.expire(minuteKey, Duration.ofMinutes(1));
        
        redisTemplate.opsForValue().increment(hourKey);
        redisTemplate.expire(hourKey, Duration.ofHours(1));
        
        // 更新金额限额
        String dailyKey = String.format(\"user_daily_limit:%d:%s\", 
            userId, today.format(DateTimeFormatter.ofPattern(\"yyyyMMdd\")));
        String weeklyKey = String.format(\"user_weekly_limit:%d:%s\", 
            userId, getWeekKey(today));
        String monthlyKey = String.format(\"user_monthly_limit:%d:%s\", 
            userId, today.format(DateTimeFormatter.ofPattern(\"yyyyMM\")));
        
        redisTemplate.opsForValue().increment(dailyKey, amount.doubleValue());
        redisTemplate.expire(dailyKey, Duration.ofDays(1));
        
        redisTemplate.opsForValue().increment(weeklyKey, amount.doubleValue());
        redisTemplate.expire(weeklyKey, Duration.ofDays(7));
        
        redisTemplate.opsForValue().increment(monthlyKey, amount.doubleValue());
        redisTemplate.expire(monthlyKey, Duration.ofDays(30));
    }
    
    // 撤单时减少使用量
    public void reduceBetLimitUsage(Long userId, BigDecimal amount) {
        LocalDateTime now = LocalDateTime.now();
        LocalDate today = now.toLocalDate();
        
        String dailyKey = String.format(\"user_daily_limit:%d:%s\", 
            userId, today.format(DateTimeFormatter.ofPattern(\"yyyyMMdd\")));
        String weeklyKey = String.format(\"user_weekly_limit:%d:%s\", 
            userId, getWeekKey(today));
        String monthlyKey = String.format(\"user_monthly_limit:%d:%s\", 
            userId, today.format(DateTimeFormatter.ofPattern(\"yyyyMM\")));
        
        redisTemplate.opsForValue().increment(dailyKey, -amount.doubleValue());
        redisTemplate.opsForValue().increment(weeklyKey, -amount.doubleValue());
        redisTemplate.opsForValue().increment(monthlyKey, -amount.doubleValue());
    }
    
    // 辅助方法
    private boolean isUserBlacklisted(Long userId) {
        return redisTemplate.opsForSet().isMember(\"blacklist_users\", userId.toString());
    }
    
    private BigDecimal getRiskConfigValue(String configKey, String defaultValue) {
        String value = (String) redisTemplate.opsForHash().get(\"risk_configs\", configKey);
        return new BigDecimal(value != null ? value : defaultValue);
    }
    
    private BigDecimal getAmountFromRedis(String key) {
        String value = redisTemplate.opsForValue().get(key);
        return value != null ? new BigDecimal(value) : BigDecimal.ZERO;
    }
    
    private Integer getCountFromRedis(String key) {
        String value = redisTemplate.opsForValue().get(key);
        return value != null ? Integer.valueOf(value) : 0;
    }
    
    private String getWeekKey(LocalDate date) {
        WeekFields weekFields = WeekFields.of(Locale.getDefault());
        int year = date.getYear();
        int week = date.get(weekFields.weekOfYear());
        return String.format(\"%d%02d\", year, week);
    }
}
```

## 4. 实时数据推送

### 4.1 WebSocket连接管理

```java
@Component
@ServerEndpoint(\"/ws/market/{symbol}\")
public class MarketWebSocketHandler {
    
    private static final Map<String, Set<Session>> symbolSessions = new ConcurrentHashMap<>();
    private static final Map<Session, String> sessionSymbols = new ConcurrentHashMap<>();
    
    @OnOpen
    public void onOpen(Session session, @PathParam(\"symbol\") String symbol) {
        symbolSessions.computeIfAbsent(symbol, k -> ConcurrentHashMap.newKeySet()).add(session);
        sessionSymbols.put(session, symbol);
        
        log.info(\"WebSocket connected: session={}, symbol={}\", session.getId(), symbol);
        
        // 发送当前价格
        sendCurrentPrice(session, symbol);
    }
    
    @OnClose
    public void onClose(Session session) {
        String symbol = sessionSymbols.remove(session);
        if (symbol != null) {
            Set<Session> sessions = symbolSessions.get(symbol);
            if (sessions != null) {
                sessions.remove(session);
                if (sessions.isEmpty()) {
                    symbolSessions.remove(symbol);
                }
            }
        }
        
        log.info(\"WebSocket disconnected: session={}, symbol={}\", session.getId(), symbol);
    }
    
    @OnError
    public void onError(Session session, Throwable error) {
        log.error(\"WebSocket error: session={}\", session.getId(), error);
        try {
            session.close();
        } catch (IOException e) {
            log.error(\"Error closing WebSocket session\", e);
        }
    }
    
    // 广播价格更新
    public static void broadcastPriceUpdate(String symbol, PriceUpdateMessage message) {
        Set<Session> sessions = symbolSessions.get(symbol);
        if (sessions != null && !sessions.isEmpty()) {
            String messageJson = JSON.toJSONString(message);
            
            Iterator<Session> iterator = sessions.iterator();
            while (iterator.hasNext()) {
                Session session = iterator.next();
                try {
                    if (session.isOpen()) {
                        session.getBasicRemote().sendText(messageJson);
                    } else {
                        iterator.remove();
                        sessionSymbols.remove(session);
                    }
                } catch (IOException e) {
                    log.error(\"Error sending WebSocket message\", e);
                    iterator.remove();
                    sessionSymbols.remove(session);
                }
            }
        }
    }
    
    private void sendCurrentPrice(Session session, String symbol) {
        try {
            // 从缓存获取当前价格
            PriceSnapshot currentPrice = priceService.getCurrentPrice(symbol);
            if (currentPrice != null) {
                PriceUpdateMessage message = PriceUpdateMessage.builder()
                    .type(\"price_update\")
                    .symbol(symbol)
                    .price(currentPrice.getPrice())
                    .timestamp(currentPrice.getTimestamp())
                    .build();
                
                session.getBasicRemote().sendText(JSON.toJSONString(message));
            }
        } catch (IOException e) {
            log.error(\"Error sending current price\", e);
        }
    }
}
```

### 4.2 价格数据推送服务

```java
@Service
public class MarketDataPushService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    // 处理BTSE价格推送
    @EventListener
    public void handlePriceUpdate(PriceUpdateEvent event) {
        PriceSnapshot snapshot = event.getPriceSnapshot();
        String symbol = snapshot.getSymbol();
        
        // 1. 更新Redis缓存
        String priceKey = \"market:price:\" + symbol;
        redisTemplate.opsForValue().set(priceKey, snapshot, Duration.ofMinutes(5));
        
        // 2. 推送给WebSocket订阅者
        PriceUpdateMessage message = PriceUpdateMessage.builder()
            .type(\"price_update\")
            .symbol(symbol)
            .price(snapshot.getPrice())
            .volume(snapshot.getVolume())
            .timestamp(snapshot.getTimestamp())
            .build();
        
        MarketWebSocketHandler.broadcastPriceUpdate(symbol, message);
        
        // 3. 检查是否需要更新回合倒计时
        updateRoundCountdown(symbol);
    }
    
    private void updateRoundCountdown(String symbol) {
        // 获取该交易对的所有活跃回合
        List<TradingRound> activeRounds = tradingRoundService.getActiveRoundsBySymbol(symbol);
        
        for (TradingRound round : activeRounds) {
            RoundCountdownVO countdown = roundCountdownService.getCurrentCountdown(
                round.getSymbolId(), round.getDurationMinutes());
            
            if (countdown != null) {
                CountdownUpdateMessage message = CountdownUpdateMessage.builder()
                    .type(\"countdown_update\")
                    .symbol(symbol)
                    .duration(round.getDurationMinutes())
                    .roundId(round.getId())
                    .roundNo(round.getRoundNo())
                    .status(countdown.getStatus())
                    .remainingSeconds(countdown.getRemainingSeconds())
                    .lockWarning(countdown.isLockWarning())
                    .canOrder(countdown.isCanOrder())
                    .build();
                
                MarketWebSocketHandler.broadcastPriceUpdate(symbol, message);
            }
        }
    }
}
```

---
**文档版本**: v1.7  
**最后更新**: 2025年8月04日  
**维护者**: Barry  
**相关文档**: [详细设计概述](./207_01_详细设计概述.md), [系统架构设计](./207_02_系统架构设计.md), [业务流程设计](./207_05_业务流程设计.md)