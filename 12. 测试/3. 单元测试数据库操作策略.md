# 单元测试中的数据库操作策略

## 1. 数据库测试的不同层级

### 1.1 测试分类对比

| 测试类型 | 数据库处理 | 速度 | 真实性 | 适用场景 |
|---------|-----------|------|--------|----------|
| **纯单元测试** | Mock/不涉及 | 很快(<100ms) | 低 | 业务逻辑测试 |
| **Repository测试** | 内存数据库 | 快(1-5s) | 中 | 数据访问层测试 |
| **集成测试** | 真实数据库 | 慢(10-30s) | 高 | 端到端流程测试 |

## 2. 单元测试中的数据库策略

### 2.1 策略1: Mock数据库操作（推荐用于Service层）

#### **适用场景**
- 测试业务逻辑，不关心数据库实现
- 需要快速反馈
- 测试异常情况和边界条件

#### **实现方式**
```java
@ExtendWith(MockitoExtension.class)
class OrderServiceUnitTest {
    
    @Mock
    private OrderMapper orderMapper; // Mock MyBatis Mapper
    
    @Mock
    private AccountServiceRpcClient accountRpcClient;
    
    @InjectMocks
    private OrderService orderService;
    
    @Test
    @DisplayName("创建订单 - 成功场景")
    void createOrder_Success() {
        // Given: Mock数据库操作
        when(orderMapper.insert(any(Order.class)))
            .thenAnswer(invocation -> {
                Order order = invocation.getArgument(0);
                order.setId(12345L); // 模拟数据库生成的ID
                return 1; // 模拟插入成功
            });
        
        when(orderMapper.selectById(12345L))
            .thenReturn(createMockOrder(12345L));
        
        // Mock外部RPC调用
        when(accountRpcClient.freezeBalance(any()))
            .thenReturn(Result.success(true));
        
        // When: 执行业务方法
        CreateOrderDTO request = CreateOrderDTO.builder()
            .userId(1L)
            .symbolId(1L)
            .amount(new BigDecimal("100"))
            .direction("UP")
            .accountType("DEMO")
            .build();
        
        Result<OrderDTO> result = orderService.createOrder(request);
        
        // Then: 验证业务逻辑
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getData().getId()).isEqualTo(12345L);
        
        // 验证数据库操作被正确调用
        verify(orderMapper).insert(argThat(order -> 
            order.getUserId().equals(1L) && 
            order.getAmount().equals(new BigDecimal("100"))));
        verify(accountRpcClient).freezeBalance(any());
    }
    
    @Test
    @DisplayName("创建订单 - 数据库异常")
    void createOrder_DatabaseException() {
        // Given: Mock数据库异常
        when(orderMapper.insert(any(Order.class)))
            .thenThrow(new RuntimeException("Database connection failed"));
        
        // When & Then: 验证异常处理
        CreateOrderDTO request = CreateOrderDTO.builder()
            .userId(1L)
            .amount(new BigDecimal("100"))
            .build();
        
        assertThatThrownBy(() -> orderService.createOrder(request))
            .isInstanceOf(BusinessException.class)
            .hasMessageContaining("订单创建失败");
    }
    
    private Order createMockOrder(Long id) {
        return Order.builder()
            .id(id)
            .userId(1L)
            .symbolId(1L)
            .amount(new BigDecimal("100"))
            .direction("UP")
            .status("ACTIVE")
            .createdAt(LocalDateTime.now())
            .build();
    }
}
```

#### **优点**
- ✅ 极快的执行速度
- ✅ 不依赖外部数据库
- ✅ 可以模拟各种异常情况
- ✅ 专注于业务逻辑测试

#### **缺点**
- ❌ 无法发现SQL语法错误
- ❌ 无法测试数据库约束
- ❌ Mock可能与真实行为不一致

### 2.2 策略2: 内存数据库测试（推荐用于Repository层）

#### **适用场景**
- 测试MyBatis Mapper的SQL逻辑
- 验证数据库约束和索引
- 测试复杂查询和事务

#### **H2内存数据库实现**
```java
@DataJpaTest // Spring Boot的Repository测试注解
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@Sql(scripts = {
    "classpath:sql/schema.sql",    // 表结构
    "classpath:sql/test-data.sql" // 测试数据
})
class OrderMapperTest {
    
    @Autowired
    private OrderMapper orderMapper;
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Test
    @DisplayName("插入订单并查询")
    void insertAndSelectOrder() {
        // Given: 准备测试数据
        Order order = Order.builder()
            .userId(1L)
            .symbolId(1L)
            .amount(new BigDecimal("100.00"))
            .direction("UP")
            .accountType("DEMO")
            .status("ACTIVE")
            .createdAt(LocalDateTime.now())
            .build();
        
        // When: 执行数据库操作
        int result = orderMapper.insert(order);
        entityManager.flush(); // 强制执行SQL
        
        // Then: 验证插入结果
        assertThat(result).isEqualTo(1);
        assertThat(order.getId()).isNotNull();
        
        // 验证查询
        Order found = orderMapper.selectById(order.getId());
        assertThat(found).isNotNull();
        assertThat(found.getUserId()).isEqualTo(1L);
        assertThat(found.getAmount()).isEqualByComparingTo(new BigDecimal("100.00"));
    }
    
    @Test
    @DisplayName("按用户ID查询订单")
    void selectByUserId() {
        // Given: 插入测试数据
        insertTestOrders();
        
        // When: 按用户ID查询
        List<Order> orders = orderMapper.selectByUserId(1L);
        
        // Then: 验证查询结果
        assertThat(orders).hasSize(2);
        assertThat(orders).allMatch(order -> order.getUserId().equals(1L));
    }
    
    @Test
    @DisplayName("批量更新订单状态")
    void batchUpdateStatus() {
        // Given: 插入测试数据
        List<Long> orderIds = insertTestOrders();
        
        // When: 批量更新状态
        int updatedCount = orderMapper.batchUpdateStatus(orderIds, "SETTLED");
        entityManager.flush();
        
        // Then: 验证更新结果
        assertThat(updatedCount).isEqualTo(orderIds.size());
        
        List<Order> updatedOrders = orderMapper.selectByIds(orderIds);
        assertThat(updatedOrders).allMatch(order -> "SETTLED".equals(order.getStatus()));
    }
    
    @Test
    @DisplayName("测试数据库约束")
    void testDatabaseConstraints() {
        // Given: 创建违反约束的数据
        Order invalidOrder = Order.builder()
            .userId(null) // 违反非空约束
            .amount(new BigDecimal("100"))
            .build();
        
        // When & Then: 验证约束生效
        assertThatThrownBy(() -> {
            orderMapper.insert(invalidOrder);
            entityManager.flush();
        }).isInstanceOf(DataIntegrityViolationException.class);
    }
    
    private List<Long> insertTestOrders() {
        List<Order> orders = Arrays.asList(
            createTestOrder(1L, "UP", "100"),
            createTestOrder(1L, "DOWN", "200"),
            createTestOrder(2L, "UP", "150")
        );
        
        return orders.stream()
            .map(order -> {
                orderMapper.insert(order);
                return order.getId();
            })
            .collect(Collectors.toList());
    }
    
    private Order createTestOrder(Long userId, String direction, String amount) {
        return Order.builder()
            .userId(userId)
            .symbolId(1L)
            .amount(new BigDecimal(amount))
            .direction(direction)
            .accountType("DEMO")
            .status("ACTIVE")
            .createdAt(LocalDateTime.now())
            .build();
    }
}
```

#### **配置文件**
```yaml
# application-test.yml
spring:
  datasource:
    url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    username: sa
    password: 
    driver-class-name: org.h2.Driver
  
  h2:
    console:
      enabled: true
  
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        
# MyBatis配置
mybatis:
  mapper-locations: classpath:mapper/*.xml
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
```

#### **测试数据SQL**
```sql
-- src/test/resources/sql/test-data.sql
INSERT INTO bo_user (id, username, external_id, status, created_at) VALUES
(1, 'testuser1', 'ext001', 'ACTIVE', CURRENT_TIMESTAMP),
(2, 'testuser2', 'ext002', 'ACTIVE', CURRENT_TIMESTAMP);

INSERT INTO bo_account (id, user_id, account_type, balance, frozen_balance, created_at) VALUES
(1, 1, 'DEMO', 10000.00, 0.00, CURRENT_TIMESTAMP),
(2, 1, 'REAL', 0.00, 0.00, CURRENT_TIMESTAMP),
(3, 2, 'DEMO', 5000.00, 0.00, CURRENT_TIMESTAMP);

INSERT INTO bo_trading_round (id, symbol_id, round_no, duration_minutes, status, open_time, close_time) VALUES
(1, 1, 202501011200, 5, 'OPEN', CURRENT_TIMESTAMP, DATEADD('MINUTE', 5, CURRENT_TIMESTAMP));
```

### 2.3 策略3: TestContainers（真实数据库）

#### **适用场景**
- 需要测试特定数据库功能（如PostgreSQL的JSON操作）
- 验证数据库性能
- 集成测试

#### **实现方式**
```java
@SpringBootTest
@Testcontainers
@Transactional
class OrderServiceIntegrationTest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:13")
            .withDatabaseName("test_binary_option")
            .withUsername("test")
            .withPassword("test")
            .withInitScript("sql/init-schema.sql");
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }
    
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private OrderMapper orderMapper;
    
    @Test
    @DisplayName("完整订单流程 - 真实数据库")
    void completeOrderFlow() {
        // Given: 准备真实的测试数据
        setupTestData();
        
        // When: 执行完整的订单创建流程
        CreateOrderDTO request = CreateOrderDTO.builder()
            .userId(1L)
            .symbolId(1L)
            .amount(new BigDecimal("100"))
            .direction("UP")
            .accountType("DEMO")
            .build();
        
        Result<OrderDTO> result = orderService.createOrder(request);
        
        // Then: 验证数据库状态
        assertThat(result.isSuccess()).isTrue();
        
        // 验证订单已保存到数据库
        Order savedOrder = orderMapper.selectById(result.getData().getId());
        assertThat(savedOrder).isNotNull();
        assertThat(savedOrder.getStatus()).isEqualTo("ACTIVE");
        
        // 验证相关数据的一致性
        verifyDatabaseConsistency(savedOrder);
    }
    
    @Test
    @DisplayName("并发订单创建测试")
    void concurrentOrderCreation() throws InterruptedException {
        // 测试数据库的并发处理能力
        int threadCount = 10;
        CountDownLatch latch = new CountDownLatch(threadCount);
        List<CompletableFuture<Result<OrderDTO>>> futures = new ArrayList<>();
        
        for (int i = 0; i < threadCount; i++) {
            final int index = i;
            CompletableFuture<Result<OrderDTO>> future = CompletableFuture.supplyAsync(() -> {
                try {
                    CreateOrderDTO request = CreateOrderDTO.builder()
                        .userId(1L)
                        .symbolId(1L)
                        .amount(new BigDecimal("10"))
                        .direction(index % 2 == 0 ? "UP" : "DOWN")
                        .accountType("DEMO")
                        .build();
                    
                    return orderService.createOrder(request);
                } finally {
                    latch.countDown();
                }
            });
            futures.add(future);
        }
        
        latch.await();
        
        // 验证所有订单都成功创建
        List<Result<OrderDTO>> results = futures.stream()
            .map(CompletableFuture::join)
            .collect(Collectors.toList());
        
        assertThat(results).allMatch(Result::isSuccess);
        
        // 验证数据库中的订单数量
        List<Order> allOrders = orderMapper.selectByUserId(1L);
        assertThat(allOrders).hasSize(threadCount);
    }
    
    private void setupTestData() {
        // 设置测试需要的基础数据
    }
    
    private void verifyDatabaseConsistency(Order order) {
        // 验证数据库状态的一致性
    }
}
```

### 2.4 策略4: 事务回滚测试

#### **适用场景**
- 测试需要保证数据库干净
- 避免测试间的数据污染

#### **实现方式**
```java
@SpringBootTest
@Transactional // 每个测试方法后自动回滚
@Rollback // 明确指定回滚
class OrderServiceTransactionalTest {
    
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private OrderMapper orderMapper;
    
    @Test
    @DisplayName("测试事务回滚")
    void testTransactionRollback() {
        // Given: 查询初始订单数量
        int initialCount = orderMapper.countAll();
        
        // When: 创建订单
        CreateOrderDTO request = CreateOrderDTO.builder()
            .userId(1L)
            .amount(new BigDecimal("100"))
            .build();
        
        Result<OrderDTO> result = orderService.createOrder(request);
        
        // Then: 验证订单已创建
        assertThat(result.isSuccess()).isTrue();
        int afterCreateCount = orderMapper.countAll();
        assertThat(afterCreateCount).isEqualTo(initialCount + 1);
        
        // 测试结束后，事务会自动回滚，不会影响其他测试
    }
    
    @Test
    @DisplayName("验证数据已回滚")
    void verifyDataRolledBack() {
        // 这个测试验证上一个测试的数据确实被回滚了
        int count = orderMapper.countAll();
        // 由于上一个测试的事务已回滚，这里的数量应该是初始值
        assertThat(count).isEqualTo(0); // 假设初始无数据
    }
}
```

## 3. 针对您项目的建议

### 3.1 当前项目的数据库测试策略

基于您的项目结构，建议采用**分层测试策略**：

#### **第1层：Service层单元测试（Mock）**
```java
// 测试业务逻辑，Mock所有数据库操作
@ExtendWith(MockitoExtension.class)
class OrderServiceTest {
    @Mock private OrderMapper orderMapper;
    @Mock private AccountServiceRpcClient accountRpcClient;
    @InjectMocks private OrderService orderService;
    
    // 专注测试业务逻辑
}
```

#### **第2层：Mapper层测试（H2内存数据库）**
```java
// 测试SQL逻辑，使用H2内存数据库
@DataJpaTest
class OrderMapperTest {
    @Autowired private OrderMapper orderMapper;
    
    // 测试SQL语句、约束、索引等
}
```

#### **第3层：集成测试（可选，使用TestContainers）**
```java
// 完整流程测试，使用真实数据库
@SpringBootTest
@Testcontainers
class OrderServiceIntegrationTest {
    
    // 测试完整的业务流程
}
```

### 3.2 具体实施建议

#### **阶段1：从Mock开始（1-2天）**
```java
// 先写最简单的Mock测试
@Test
void createOrder_Success() {
    when(orderMapper.insert(any())).thenReturn(1);
    when(accountRpcClient.getAccount(any(), any())).thenReturn(Result.success(mockAccount()));
    
    Result<OrderDTO> result = orderService.createOrder(request);
    
    assertThat(result.isSuccess()).isTrue();
    verify(orderMapper).insert(any());
}
```

#### **阶段2：添加Repository测试（2-3天）**
```java
// 配置H2数据库，测试关键的Mapper方法
@DataJpaTest
class OrderMapperTest {
    // 测试复杂查询、批量操作等
}
```

#### **阶段3：集成测试（可选）**
```java
// 使用TestContainers验证完整流程
```

### 3.3 配置文件设置

#### **Maven依赖**
```xml
<dependencies>
    <!-- H2内存数据库 -->
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <scope>test</scope>
    </dependency>
    
    <!-- TestContainers（可选） -->
    <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>postgresql</artifactId>
        <scope>test</scope>
    </dependency>
    
    <!-- Spring Boot Test -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

## 4. 最佳实践总结

### 4.1 选择策略的决策树

```
需要测试数据库操作？
├── 否 → Mock所有数据库操作（纯单元测试）
└── 是 → 需要测试SQL逻辑？
    ├── 是 → 使用H2内存数据库（Repository测试）
    └── 否 → 需要测试特定数据库功能？
        ├── 是 → 使用TestContainers（集成测试）
        └── 否 → Mock数据库操作
```

### 4.2 推荐的实施顺序

1. **第1周**：Mock所有数据库操作，专注业务逻辑
2. **第2周**：添加关键Mapper的H2测试
3. **第3周**：考虑添加TestContainers集成测试

### 4.3 注意事项

- ✅ **Mock优先**：大部分单元测试应该Mock数据库
- ✅ **分层测试**：不同层级使用不同策略
- ✅ **快速反馈**：优先保证测试的执行速度
- ❌ **避免过度**：不要为了测试而测试
- ❌ **避免依赖**：测试之间不应该有数据依赖

这样的策略既能保证测试的有效性，又能保持良好的开发体验。您觉得这个方案如何？需要我详细解释某个特定的策略吗？