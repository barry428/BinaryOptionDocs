# OrderService 单元测试方案

## 1. 概述

本文档为`OrderService`类制定详细的单元测试方案。OrderService是订单服务的核心类，负责订单的创建、查询、取消和结算等关键业务逻辑。

## 2. 测试目标

确保OrderService的各个公共方法在各种场景下都能正确工作，包括：
- 正常业务流程
- 异常处理路径
- 边界条件处理
- 依赖服务的正确调用

## 3. 测试框架和工具

### 3.1 核心框架
- **JUnit 5**: Java单元测试标准框架
- **Spring Boot Test**: Spring Boot应用测试支持
- **Mockito**: Mock框架，用于模拟依赖对象

### 3.2 依赖配置
项目pom.xml已包含必要的测试依赖：
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
```

## 4. 测试类结构

### 4.1 测试类命名
- 主测试类: `OrderServiceTest`
- 测试配置类: `OrderServiceTestConfig`

### 4.2 测试目录结构
```
src/test/java/com/binaryoption/orderservice/service/
├── OrderServiceTest.java
└── config/
    └── OrderServiceTestConfig.java
```

## 5. Mock策略

### 5.1 依赖注入
使用`@MockBean`注解模拟所有外部依赖：

```java
@SpringBootTest
class OrderServiceTest {
    
    @Autowired
    private OrderService orderService;
    
    @MockBean
    private OrderMapper orderMapper;
    
    @MockBean
    private TradingRoundMapper tradingRoundMapper;
    
    @MockBean
    private UserRoundMapper userRoundMapper;
    
    @MockBean
    private UserRpcClient userRpcClient;
    
    @MockBean
    private AccountRpcClient accountRpcClient;
    
    @MockBean
    private BtseTransferRpcClient btseTransferRpcClient;
    
    @MockBean
    private RiskControlService riskControlService;
    
    @MockBean
    private OrderConverter orderConverter;
    
    @MockBean
    private FixtureService fixtureService;
    
    @MockBean
    private TradingRoundService tradingRoundService;
    
    @MockBean
    private SymbolService symbolService;
    
    @MockBean
    private OrderHedgeService orderHedgeService;
    
    @MockBean
    private OrderStatisticsService orderStatisticsService;
    
    @MockBean
    private OrderSettlementService orderSettlementService;
    
    @MockBean
    private UserRiskStatsService userRiskStatsService;
    
    @MockBean
    private OrderConfig orderConfig;
    
    @MockBean
    private MessageUtils messageUtils;
}
```

## 6. 核心方法测试方案

### 6.1 createOrder 方法测试

#### 6.1.1 测试要点
- 订单创建完整流程
- 风控检查逻辑
- 资金处理流程
- 异常处理路径

#### 6.1.2 测试用例

##### 正常创建订单（REAL账户）
```java
@Test
void shouldCreateRealOrderSuccessfully() {
    // Given
    OrderCreateRequestDTO request = TestDataFactory.createRealOrderRequest();
    
    // Mock依赖服务
    given(riskControlService.checkOrderRisk(any())).willReturn(RiskCheckResult.pass());
    given(tradingRoundService.getCurrentOrCreateRound(any())).willReturn(createTradingRound());
    given(fixtureService.selectFixtureForOrder(any(), any(), any(), any()))
        .willReturn(createFixtureSelectionResult());
    given(orderMapper.insert(any(Order.class))).willAnswer(invocation -> {
        Order order = invocation.getArgument(0);
        order.setId(1L);
        return 1;
    });
    given(btseTransferRpcClient.transferFromBtse(any(), any(), any(), any(), any()))
        .willReturn(Result.success("transferId"));
    given(accountRpcClient.atomicTransferOut(any(), any(), any(), any(), any(), any()))
        .willReturn(Result.success(true));
    given(orderConverter.toDTO(any(Order.class))).willReturn(createOrderDTO());
    
    // When
    Result<OrderDTO> result = orderService.createOrder(request);
    
    // Then
    assertThat(result.isSuccess()).isTrue();
    assertThat(result.getData()).isNotNull();
    
    // 验证调用顺序
    verify(orderMapper).insert(any(Order.class));
    verify(btseTransferRpcClient).transferFromBtse(any(), any(), any(), any(), any());
    verify(accountRpcClient).atomicTransferOut(any(), any(), any(), any(), any(), any());
    verify(tradingRoundService).updateRoundBetAmount(any(), any(), any());
}
```

##### 正常创建订单（DEMO账户）
```java
@Test
void shouldCreateDemoOrderSuccessfully() {
    // Given
    OrderCreateRequestDTO request = TestDataFactory.createDemoOrderRequest();
    
    // Mock依赖服务
    given(riskControlService.checkOrderRisk(any())).willReturn(RiskCheckResult.pass());
    given(tradingRoundService.getCurrentOrCreateRound(any())).willReturn(createTradingRound());
    given(fixtureService.selectFixtureForOrder(any(), any(), any(), any()))
        .willReturn(createFixtureSelectionResult());
    given(orderMapper.insert(any(Order.class))).willAnswer(invocation -> {
        Order order = invocation.getArgument(0);
        order.setId(1L);
        return 1;
    });
    given(accountRpcClient.atomicTransferOut(any(), any(), any(), any(), any(), any()))
        .willReturn(Result.success(true));
    given(orderConverter.toDTO(any(Order.class))).willReturn(createOrderDTO());
    
    // When
    Result<OrderDTO> result = orderService.createOrder(request);
    
    // Then
    assertThat(result.isSuccess()).isTrue();
    assertThat(result.getData()).isNotNull();
    
    // 验证BTSE转账未被调用
    verify(btseTransferRpcClient, never()).transferFromBtse(any(), any(), any(), any(), any());
    
    // 验证调用顺序
    verify(orderMapper).insert(any(Order.class));
    verify(accountRpcClient).atomicTransferOut(any(), any(), any(), any(), any(), any());
}
```

##### 风控检查失败
```java
@Test
void shouldReturnErrorWhenRiskControlFailed() {
    // Given
    OrderCreateRequestDTO request = TestDataFactory.createRealOrderRequest();
    
    // Mock风控检查失败
    given(riskControlService.checkOrderRisk(any())).willReturn(
        RiskCheckResult.fail("risk.control.failed", "风控检查失败"));
    given(messageUtils.getMessage(anyString(), any())).willReturn("风控检查失败");
    
    // When
    Result<OrderDTO> result = orderService.createOrder(request);
    
    // Then
    assertThat(result.isSuccess()).isFalse();
    assertThat(result.getCode()).isEqualTo(400);
    assertThat(result.getMessage()).isEqualTo("风控检查失败");
    
    // 验证订单未被创建
    verify(orderMapper, never()).insert(any(Order.class));
}
```

##### BTSE转账失败
```java
@Test
void shouldRollbackOrderWhenBtseTransferFailed() {
    // Given
    OrderCreateRequestDTO request = TestDataFactory.createRealOrderRequest();
    
    // Mock依赖服务
    given(riskControlService.checkOrderRisk(any())).willReturn(RiskCheckResult.pass());
    given(tradingRoundService.getCurrentOrCreateRound(any())).willReturn(createTradingRound());
    given(fixtureService.selectFixtureForOrder(any(), any(), any(), any()))
        .willReturn(createFixtureSelectionResult());
    given(orderMapper.insert(any(Order.class))).willAnswer(invocation -> {
        Order order = invocation.getArgument(0);
        order.setId(1L);
        return 1;
    });
    given(btseTransferRpcClient.transferFromBtse(any(), any(), any(), any(), any()))
        .willReturn(Result.error(400, "BTSE转账失败"));
    
    // When & Then
    assertThatThrownBy(() -> orderService.createOrder(request))
        .isInstanceOf(BusinessException.class);
    
    // 验证订单状态被回滚
    ArgumentCaptor<Order> orderCaptor = ArgumentCaptor.forClass(Order.class);
    verify(orderMapper, times(2)).update(orderCaptor.capture());
    Order updatedOrder = orderCaptor.getValue();
    assertThat(updatedOrder.getStatus()).isEqualTo("CANCELLED");
}
```

##### 账户余额不足
```java
@Test
void shouldReturnErrorWhenAccountBalanceInsufficient() {
    // Given
    OrderCreateRequestDTO request = TestDataFactory.createDemoOrderRequest();
    
    // Mock风控检查通过
    given(riskControlService.checkOrderRisk(any())).willReturn(RiskCheckResult.pass());
    
    // Mock账户余额不足
    given(accountRpcClient.getAccountBalance(any(), any()))
        .willReturn(Result.success(createInsufficientAccountDTO()));
    
    // When
    Result<OrderDTO> result = orderService.createOrder(request);
    
    // Then
    assertThat(result.isSuccess()).isFalse();
    assertThat(result.getCode()).isEqualTo(400);
    
    // 验证订单未被创建
    verify(orderMapper, never()).insert(any(Order.class));
}
```

### 6.2 getOrderById 方法测试

#### 6.2.1 测试要点
- 订单查询逻辑
- 订单不存在处理

#### 6.2.2 测试用例

##### 正常查询订单
```java
@Test
void shouldGetOrderByIdSuccessfully() {
    // Given
    Order order = createActiveOrder();
    OrderDTO orderDTO = createOrderDTO();
    
    given(orderMapper.findById(1L)).willReturn(order);
    given(orderConverter.toDTO(order)).willReturn(orderDTO);
    
    // When
    OrderDTO result = orderService.getOrderById(1L);
    
    // Then
    assertThat(result).isNotNull();
    assertThat(result.getId()).isEqualTo(orderDTO.getId());
    verify(orderMapper).findById(1L);
    verify(orderConverter).toDTO(order);
}
```

##### 订单不存在
```java
@Test
void shouldReturnNullWhenOrderNotFound() {
    // Given
    given(orderMapper.findById(999L)).willReturn(null);
    
    // When
    OrderDTO result = orderService.getOrderById(999L);
    
    // Then
    assertThat(result).isNull();
    verify(orderMapper).findById(999L);
    verify(orderConverter, never()).toDTO(any());
}
```

### 6.3 getUserOrders 方法测试

#### 6.3.1 测试要点
- 分页查询逻辑
- 数据转换处理

#### 6.3.2 测试用例

##### 分页查询用户订单
```java
@Test
void shouldGetUserOrdersWithPagination() {
    // Given
    Long userId = 1L;
    String accountType = "REAL";
    PageRequestDTO pageRequest = PageRequestDTO.of(1, 10);
    
    List<Order> orders = Arrays.asList(createActiveOrder(), createWinOrder());
    List<OrderDTO> orderDTOs = Arrays.asList(createOrderDTO(), createWinOrderDTO());
    
    given(orderMapper.findByUserIdAndAccountType(userId, accountType, 0, 10))
        .willReturn(orders);
    given(orderMapper.countByUserIdAndAccountType(userId, accountType))
        .willReturn(2L);
    given(orderConverter.toDTOList(orders)).willReturn(orderDTOs);
    
    // When
    PageResponseDTO<OrderDTO> result = orderService.getUserOrders(userId, accountType, pageRequest);
    
    // Then
    assertThat(result).isNotNull();
    assertThat(result.getTotal()).isEqualTo(2L);
    assertThat(result.getData()).hasSize(2);
    verify(orderMapper).findByUserIdAndAccountType(userId, accountType, 0, 10);
    verify(orderMapper).countByUserIdAndAccountType(userId, accountType);
    verify(orderConverter).toDTOList(orders);
}
```

### 6.4 cancelOrder 方法测试

#### 6.4.1 测试要点
- 订单取消逻辑（当前实现抛出异常）

#### 6.4.2 测试用例

##### 订单取消被禁止
```java
@Test
void shouldThrowExceptionWhenCancelOrder() {
    // Given
    Long orderId = 1L;
    Long userId = 1L;
    
    // When & Then
    assertThatThrownBy(() -> orderService.cancelOrder(orderId, userId))
        .isInstanceOf(BusinessException.class)
        .hasMessageContaining("order.cannot.cancel");
}
```

### 6.5 settleOrdersByRound 方法测试

#### 6.5.1 测试要点
- 委托给OrderSettlementService的逻辑

#### 6.5.2 测试用例

##### 委托结算服务
```java
@Test
void shouldDelegateToSettlementService() {
    // Given
    Long roundId = 1L;
    
    // When
    orderService.settleOrdersByRound(roundId);
    
    // Then
    verify(orderSettlementService).settleOrdersByRound(roundId);
}
```

## 7. 测试数据工厂

### 7.1 TestDataFactory 类
```java
public class TestDataFactory {
    
    public static OrderCreateRequestDTO createRealOrderRequest() {
        OrderCreateRequestDTO request = new OrderCreateRequestDTO();
        request.setUserId(1L);
        request.setAccountType("REAL");
        request.setSymbolId(1L);
        request.setDirection("UP");
        request.setAmount(new BigDecimal("100"));
        return request;
    }
    
    public static OrderCreateRequestDTO createDemoOrderRequest() {
        OrderCreateRequestDTO request = new OrderCreateRequestDTO();
        request.setUserId(1L);
        request.setAccountType("DEMO");
        request.setSymbolId(1L);
        request.setDirection("DOWN");
        request.setAmount(new BigDecimal("50"));
        return request;
    }
}
```

### 7.2 测试对象创建方法
```java
private TradingRound createTradingRound() {
    TradingRound round = new TradingRound();
    round.setId(1L);
    round.setSymbolId(1L);
    round.setRoundNo("20250918001");
    round.setStartTime(LocalDateTime.now());
    round.setEndTime(LocalDateTime.now().plusMinutes(5));
    round.setStatus("ACTIVE");
    return round;
}

private Order createActiveOrder() {
    Order order = new Order();
    order.setId(1L);
    order.setUserId(1L);
    order.setAccountType("REAL");
    order.setSymbolId(1L);
    order.setRoundId(1L);
    order.setDirection("UP");
    order.setAmount(new BigDecimal("100"));
    order.setOdds(new BigDecimal("1.85"));
    order.setStatus("ACTIVE");
    order.setCreateTime(LocalDateTime.now());
    return order;
}
```

## 8. 测试覆盖率目标

### 8.1 覆盖率指标
- **行覆盖率**: ≥ 90%
- **分支覆盖率**: ≥ 85%
- **方法覆盖率**: ≥ 100%

### 8.2 关键路径覆盖
确保覆盖以下关键路径：
1. 订单创建完整流程
2. 各种异常处理路径
3. 不同账户类型处理
4. 风控检查各种结果
5. 资金处理成功/失败场景
6. 所有公共方法调用

## 9. 最佳实践

### 9.1 测试命名规范
- 使用`shouldDoSomethingWhenCondition`格式
- 清晰描述测试场景和期望结果

### 9.2 测试组织
- 每个业务方法对应一个测试类或测试组
- 使用Given-When-Then结构组织测试代码
- 合理使用`@BeforeEach`和`@AfterEach`进行测试准备和清理

### 9.3 Mock验证
- 验证关键方法调用次数和参数
- 使用`verify()`验证交互而非仅验证状态
- 避免过度Mock，保持测试的可读性

## 10. 执行和报告

### 10.1 测试执行
```bash
# 执行OrderService单元测试
mvn test -Dtest=OrderServiceTest

# 生成测试报告
mvn surefire-report:report

# 检查测试覆盖率
mvn jacoco:report
```

### 10.2 持续集成
在CI/CD流水线中添加测试步骤：
```yaml
- name: Run OrderService Unit Tests
  run: mvn test -Dtest=OrderServiceTest
  
- name: Generate Test Coverage Report
  run: mvn jacoco:report
  
- name: Check Coverage Threshold
  run: |
    # 检查覆盖率是否达到阈值
    # 可以使用jacoco-maven-plugin的check目标
```