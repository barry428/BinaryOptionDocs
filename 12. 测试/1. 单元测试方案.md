# Order-Service 单元测试方案

## 1. 测试框架和工具选择

### 1.1 核心测试框架
```xml
<dependencies>
    <!-- JUnit 5 -->
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter</artifactId>
        <scope>test</scope>
    </dependency>
    
    <!-- Mockito -->
    <dependency>
        <groupId>org.mockito</groupId>
        <artifactId>mockito-core</artifactId>
        <scope>test</scope>
    </dependency>
    
    <!-- Spring Boot Test -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    
    <!-- AssertJ (更强大的断言) -->
    <dependency>
        <groupId>org.assertj</groupId>
        <artifactId>assertj-core</artifactId>
        <scope>test</scope>
    </dependency>
    
    <!-- TestContainers (数据库集成测试) -->
    <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>postgresql</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

### 1.2 测试分层策略
- **单元测试**: 测试单个类/方法的逻辑
- **集成测试**: 测试组件间的交互
- **Repository测试**: 测试数据库访问层
- **Controller测试**: 测试REST API

## 2. Order-Service 核心组件测试方案

### 2.1 Service层测试

#### 2.1.1 OrderService测试
```java
@ExtendWith(MockitoExtension.class)
class OrderServiceTest {
    
    @Mock
    private OrderMapper orderMapper;
    
    @Mock
    private AccountServiceRpcClient accountServiceRpcClient;
    
    @Mock
    private FixtureService fixtureService;
    
    @Mock
    private OrderConfig orderConfig;
    
    @Mock
    private TradingRoundService tradingRoundService;
    
    @Mock
    private OrderHedgeService orderHedgeService;
    
    @Mock
    private OrderStatisticsService orderStatisticsService;
    
    @Mock
    private OrderSettlementService orderSettlementService;
    
    @InjectMocks
    private OrderService orderService;
    
    @Test
    @DisplayName("创建DEMO账户订单 - 成功场景")
    void createOrder_DemoAccount_Success() {
        // Given
        CreateOrderDTO request = CreateOrderDTO.builder()
            .userId(1L)
            .symbolId(1L)
            .amount(new BigDecimal("100"))
            .direction("UP")
            .accountType("DEMO")
            .build();
        
        AccountDTO account = AccountDTO.builder()
            .id(1L)
            .userId(1L)
            .accountType("DEMO")
            .balance(new BigDecimal("1000"))
            .build();
        
        when(accountServiceRpcClient.getAccount(1L, "DEMO"))
            .thenReturn(Result.success(account));
        
        // When
        Result<OrderDTO> result = orderService.createOrder(request);
        
        // Then
        assertThat(result.isSuccess()).isTrue();
        verify(orderMapper).insert(any(Order.class));
        verify(accountServiceRpcClient).freezeBalance(any());
    }
    
    @Test
    @DisplayName("创建REAL账户订单 - 需要BTSE转账")
    void createOrder_RealAccount_WithBtseTransfer() {
        // 测试REAL账户的完整流程
    }
    
    @Test
    @DisplayName("订单结算 - WIN状态")
    void settleOrder_WinStatus() {
        // 测试WIN状态的结算逻辑
    }
    
    @Test
    @DisplayName("订单结算 - LOSE状态")
    void settleOrder_LoseStatus() {
        // 测试LOSE状态的结算逻辑
    }
}
```

#### 2.1.2 FixtureService测试
```java
@ExtendWith(MockitoExtension.class)
class FixtureServiceTest {
    
    @Mock
    private BtseRpcClient btseRpcClient;
    
    @Mock
    private SymbolService symbolService;
    
    @Mock
    private BtseSymbolConverter symbolConverter;
    
    @InjectMocks
    private FixtureService fixtureService;
    
    @Test
    @DisplayName("选择Fixture - 成功获取并计算赔率")
    void selectFixtureForOrder_Success() {
        // Given
        Long symbolId = 1L;
        String direction = "UP";
        LocalDateTime roundTime = LocalDateTime.now();
        Integer duration = 5;
        
        FixturesResponseDTO fixturesResponse = FixturesResponseDTO.builder()
            .symbol("BTC-USDT")
            .price(new BigDecimal("50000"))
            .open(List.of(
                FixtureDTO.builder()
                    .side("call")
                    .price(new BigDecimal("0.5"))
                    .expiration(roundTime.plusMinutes(5))
                    .build()
            ))
            .build();
        
        when(symbolService.getBtseSymbolById(symbolId)).thenReturn("BTC-USDT");
        when(btseRpcClient.getFixtures(any())).thenReturn(Result.success(fixturesResponse));
        
        // When
        FixtureService.FixtureSelectionResult result = 
            fixtureService.selectFixtureForOrder(symbolId, direction, roundTime, duration);
        
        // Then
        assertThat(result).isNotNull();
        assertThat(result.getOdds()).isEqualByComparingTo(new BigDecimal("2.00"));
        assertThat(result.getCurrentPrice()).isEqualByComparingTo(new BigDecimal("50000"));
    }
    
    @Test
    @DisplayName("执行对冲 - 成功场景")
    void performOrderHedge_Success() {
        // 测试对冲执行逻辑
    }
    
    @Test
    @DisplayName("Fixture API调用失败处理")
    void selectFixtureForOrder_ApiFailure() {
        // 测试API失败的异常处理
    }
}
```

#### 2.1.3 TradingRoundService测试
```java
@ExtendWith(MockitoExtension.class)
class TradingRoundServiceTest {
    
    @Mock
    private TradingRoundMapper tradingRoundMapper;
    
    @InjectMocks
    private TradingRoundService tradingRoundService;
    
    @Test
    @DisplayName("获取或创建轮次 - 新建轮次")
    void getOrCreateRoundForDuration_CreateNew() {
        // Given
        Long symbolId = 1L;
        Integer duration = 5;
        LocalDateTime now = LocalDateTime.now();
        
        when(tradingRoundMapper.selectCurrentRoundBySymbolAndDuration(
            eq(symbolId), eq(duration), any(), any()
        )).thenReturn(null);
        
        // When
        TradingRound round = tradingRoundService.getOrCreateRoundForDuration(symbolId, duration);
        
        // Then
        assertThat(round).isNotNull();
        verify(tradingRoundMapper).insert(any(TradingRound.class));
    }
    
    @Test
    @DisplayName("轮次状态自动更新 - OPEN到LOCKED")
    void updateRoundStatus_OpenToLocked() {
        // 测试轮次状态自动转换
    }
}
```

### 2.2 Controller层测试

#### 2.2.1 OrderController测试
```java
@WebMvcTest(OrderController.class)
class OrderControllerTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @MockBean
    private OrderService orderService;
    
    @Test
    @DisplayName("创建订单 - 参数验证")
    void createOrder_ValidationTest() throws Exception {
        CreateOrderDTO request = CreateOrderDTO.builder()
            .userId(null) // 缺少必填字段
            .amount(new BigDecimal("100"))
            .build();
        
        mockMvc.perform(post("/api/orders")
                .contentType(MediaType.APPLICATION_JSON)
                .content(JsonUtil.toJson(request)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.code").value(400));
    }
    
    @Test
    @DisplayName("创建订单 - 成功响应")
    void createOrder_Success() throws Exception {
        CreateOrderDTO request = CreateOrderDTO.builder()
            .userId(1L)
            .symbolId(1L)
            .amount(new BigDecimal("100"))
            .direction("UP")
            .accountType("DEMO")
            .build();
        
        OrderDTO response = OrderDTO.builder()
            .id(1L)
            .status("ACTIVE")
            .build();
        
        when(orderService.createOrder(any())).thenReturn(Result.success(response));
        
        mockMvc.perform(post("/api/orders")
                .contentType(MediaType.APPLICATION_JSON)
                .content(JsonUtil.toJson(request)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.success").value(true))
                .andExpect(jsonPath("$.data.id").value(1));
    }
}
```

### 2.3 Repository层测试

#### 2.3.1 使用TestContainers进行数据库测试
```java
@DataJpaTest
@AutoConfigureMockMvc
@TestContainers
class OrderMapperTest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:13")
            .withDatabaseName("test_db")
            .withUsername("test")
            .withPassword("test");
    
    @Autowired
    private OrderMapper orderMapper;
    
    @Test
    @DisplayName("插入订单并查询")
    void insertAndSelect() {
        // Given
        Order order = Order.builder()
            .userId(1L)
            .symbolId(1L)
            .amount(new BigDecimal("100"))
            .direction("UP")
            .status("ACTIVE")
            .build();
        
        // When
        orderMapper.insert(order);
        Order found = orderMapper.selectById(order.getId());
        
        // Then
        assertThat(found).isNotNull();
        assertThat(found.getUserId()).isEqualTo(1L);
        assertThat(found.getAmount()).isEqualByComparingTo(new BigDecimal("100"));
    }
    
    @Test
    @DisplayName("批量更新订单状态")
    void batchUpdateStatus() {
        // 测试批量更新功能
    }
}
```

## 3. 测试数据构建器（Test Data Builder）

### 3.1 创建测试数据工厂
```java
public class TestDataFactory {
    
    public static CreateOrderDTO.CreateOrderDTOBuilder defaultCreateOrderDTO() {
        return CreateOrderDTO.builder()
            .userId(1L)
            .symbolId(1L)
            .amount(new BigDecimal("100"))
            .direction("UP")
            .accountType("DEMO");
    }
    
    public static Order.OrderBuilder defaultOrder() {
        return Order.builder()
            .id(1L)
            .userId(1L)
            .symbolId(1L)
            .amount(new BigDecimal("100"))
            .direction("UP")
            .status("ACTIVE")
            .accountType("DEMO")
            .createdAt(LocalDateTime.now());
    }
    
    public static AccountDTO.AccountDTOBuilder defaultAccount() {
        return AccountDTO.builder()
            .id(1L)
            .userId(1L)
            .accountType("DEMO")
            .balance(new BigDecimal("10000"))
            .frozenBalance(BigDecimal.ZERO);
    }
    
    public static FixturesResponseDTO.FixturesResponseDTOBuilder defaultFixturesResponse() {
        return FixturesResponseDTO.builder()
            .symbol("BTC-USDT")
            .price(new BigDecimal("50000"))
            .open(List.of(
                FixtureDTO.builder()
                    .side("call")
                    .price(new BigDecimal("0.5"))
                    .strike(new BigDecimal("50000"))
                    .expiration(LocalDateTime.now().plusMinutes(5))
                    .build()
            ));
    }
}
```

## 4. 异步和定时任务测试

### 4.1 定时任务测试
```java
@SpringBootTest
class ScheduledTasksTest {
    
    @SpyBean
    private OrderSettlementService settlementService;
    
    @Test
    @DisplayName("结算任务执行测试")
    void testSettlementTask() {
        // Given
        await().atMost(Duration.ofSeconds(70))
            .untilAsserted(() -> {
                // Then
                verify(settlementService, atLeastOnce()).processSettlement();
            });
    }
}
```

## 5. 性能测试

### 5.1 使用JMH进行性能基准测试
```java
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.MILLISECONDS)
@State(Scope.Benchmark)
public class OrderServiceBenchmark {
    
    private OrderService orderService;
    
    @Setup
    public void setup() {
        // 初始化服务
    }
    
    @Benchmark
    public void testCreateOrder() {
        CreateOrderDTO request = TestDataFactory.defaultCreateOrderDTO().build();
        orderService.createOrder(request);
    }
}
```

## 6. 测试覆盖率要求

### 6.1 目标覆盖率
- **整体代码覆盖率**: ≥ 80%
- **Service层覆盖率**: ≥ 90%
- **关键业务逻辑**: 100%

### 6.2 关键测试场景
1. **订单创建**
   - DEMO账户正常下单
   - REAL账户下单（含BTSE转账）
   - 余额不足
   - 风控限制
   - 并发下单

2. **订单结算**
   - WIN状态结算
   - LOSE状态结算
   - DRAW状态处理
   - 批量结算
   - 结算失败重试

3. **Fixture处理**
   - 正常获取Fixture
   - API超时处理
   - 无可用Fixture
   - 赔率计算边界值

4. **对冲操作**
   - 成功对冲
   - 对冲失败处理
   - 重试机制

## 7. Mock策略

### 7.1 外部依赖Mock
```java
public class MockConfig {
    
    @Bean
    @Profile("test")
    public BtseRpcClient mockBtseRpcClient() {
        BtseRpcClient mock = Mockito.mock(BtseRpcClient.class);
        
        // 设置默认行为
        when(mock.getFixtures(any()))
            .thenReturn(Result.success(TestDataFactory.defaultFixturesResponse().build()));
        
        return mock;
    }
    
    @Bean
    @Profile("test")
    public AccountServiceRpcClient mockAccountServiceRpcClient() {
        AccountServiceRpcClient mock = Mockito.mock(AccountServiceRpcClient.class);
        
        when(mock.getAccount(anyLong(), anyString()))
            .thenReturn(Result.success(TestDataFactory.defaultAccount().build()));
        
        return mock;
    }
}
```

## 8. 测试执行和报告

### 8.1 Maven配置
```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-surefire-plugin</artifactId>
            <configuration>
                <includes>
                    <include>**/*Test.java</include>
                    <include>**/*Tests.java</include>
                </includes>
                <excludes>
                    <exclude>**/*IntegrationTest.java</exclude>
                </excludes>
            </configuration>
        </plugin>
        
        <plugin>
            <groupId>org.jacoco</groupId>
            <artifactId>jacoco-maven-plugin</artifactId>
            <configuration>
                <excludes>
                    <exclude>**/config/**</exclude>
                    <exclude>**/entity/**</exclude>
                    <exclude>**/dto/**</exclude>
                </excludes>
            </configuration>
        </plugin>
    </plugins>
</build>
```

### 8.2 测试命令
```bash
# 运行单元测试
mvn test

# 运行集成测试
mvn verify

# 生成覆盖率报告
mvn jacoco:report

# 运行特定测试类
mvn test -Dtest=OrderServiceTest

# 运行特定测试方法
mvn test -Dtest=OrderServiceTest#createOrder_DemoAccount_Success
```

## 9. 持续集成配置

### 9.1 GitHub Actions配置
```yaml
name: Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up JDK 11
      uses: actions/setup-java@v2
      with:
        java-version: '11'
        
    - name: Cache Maven dependencies
      uses: actions/cache@v2
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        
    - name: Run tests
      run: mvn clean test
      
    - name: Generate coverage report
      run: mvn jacoco:report
      
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v2
```

## 10. 测试最佳实践

### 10.1 测试命名规范
- 使用 `@DisplayName` 提供清晰的测试描述
- 方法名格式：`methodName_scenario_expectedResult`

### 10.2 测试组织
- 按功能分组测试
- 使用 `@Nested` 组织相关测试
- 每个测试只测试一个场景

### 10.3 断言最佳实践
- 使用AssertJ的流式断言
- 验证所有重要的副作用
- 避免过度断言

### 10.4 Mock使用原则
- 只Mock直接依赖
- 避免Mock过多层级
- 优先使用真实对象

## 11. 最小可行单元测试方案（MVP）

### 11.1 初步测试范围和程度建议

对于当前项目，**最初步的单元测试**应该重点关注：

#### **优先级1：核心业务方法（必须测试）**
覆盖率目标：**90%+**

1. **OrderService核心方法**
   - `createOrder()` - 订单创建逻辑
   - `settleOrder()` - 订单结算逻辑
   - `cancelOrder()` - 订单取消逻辑

2. **FixtureService核心方法**
   - `selectFixtureForOrder()` - Fixture选择
   - `calculateOddsFromFixturePrice()` - 赔率计算

3. **TradingRoundService核心方法**
   - `getOrCreateRoundForDuration()` - 轮次管理

#### **优先级2：工具类和计算方法（建议测试）**
覆盖率目标：**70%+**

1. **计算相关方法**
   - 赔率计算
   - 手续费计算
   - 盈亏计算

2. **数据转换方法**
   - DTO转换
   - 状态转换

#### **优先级3：Controller和Repository（可选）**
覆盖率目标：**50%+**

1. **主要API端点**
   - 订单创建API
   - 订单查询API

### 11.2 最小测试实现示例

#### **阶段1：只测试核心逻辑（1-2天）**

```java
// 1. 最简单的OrderService测试
@ExtendWith(MockitoExtension.class)
class OrderServiceMinimalTest {
    
    @Mock private OrderMapper orderMapper;
    @Mock private AccountServiceRpcClient accountRpcClient;
    @InjectMocks private OrderService orderService;
    
    @Test
    @DisplayName("创建DEMO订单 - 基本场景")
    void createOrder_DemoBasic() {
        // Given
        CreateOrderDTO request = CreateOrderDTO.builder()
            .userId(1L).symbolId(1L).amount(new BigDecimal("100"))
            .direction("UP").accountType("DEMO").build();
        
        when(accountRpcClient.getAccount(1L, "DEMO"))
            .thenReturn(Result.success(mockAccount()));
        
        // When & Then
        Result<OrderDTO> result = orderService.createOrder(request);
        assertThat(result.isSuccess()).isTrue();
    }
    
    // 只需要3-5个核心测试方法
}

// 2. 最简单的FixtureService测试  
@ExtendWith(MockitoExtension.class)
class FixtureServiceMinimalTest {
    
    @Test
    @DisplayName("赔率计算 - 基本场景")
    void calculateOdds_Basic() {
        FixtureService service = new FixtureService(null, null, null);
        
        // 使用反射调用私有方法，或者提取为public方法
        BigDecimal odds = service.calculateOddsFromFixturePrice(new BigDecimal("0.5"));
        
        assertThat(odds).isEqualByComparingTo(new BigDecimal("2.00"));
    }
}
```

#### **阶段2：增加边界条件（2-3天）**

```java
@Test
@DisplayName("创建订单 - 余额不足")
void createOrder_InsufficientBalance() {
    // 测试余额不足场景
}

@Test  
@DisplayName("创建订单 - 参数验证")
void createOrder_ValidationFailed() {
    // 测试参数验证失败
}

@Test
@DisplayName("赔率计算 - 边界值")
void calculateOdds_EdgeCases() {
    // 测试price为0、null、负数等边界情况
}
```

### 11.3 测试深度建议

#### **当前阶段：基础覆盖（推荐）**
- **时间投入**：1周
- **覆盖率目标**：Service层 60%+
- **测试内容**：
  - ✅ 主要业务流程的正常场景
  - ✅ 关键计算方法的边界值
  - ❌ 不测试：异常处理、并发、性能
  - ❌ 不测试：Controller、Repository
  - ❌ 不测试：复杂的Mock和集成

#### **vs 完整覆盖（暂不建议）**
- **时间投入**：3-4周
- **覆盖率目标**：80%+
- **测试内容**：所有层级、异常处理、并发、集成测试

### 11.4 具体实施建议

#### **第1天：环境搭建**
```xml
<!-- 只添加最基本的测试依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
```

#### **第2-3天：核心Service测试**
- OrderService: 3个核心方法
- FixtureService: 2个核心方法  
- TradingRoundService: 1个核心方法

#### **第4-5天：边界条件和异常**
- 参数验证失败
- 业务规则限制
- 外部调用失败

#### **第6-7天：调试和完善**
- 修复发现的bug
- 补充遗漏的场景
- 生成覆盖率报告

### 11.5 成功标准

#### **最小成功标准**
- [x] 能够运行测试且通过
- [x] 核心业务方法有基本测试
- [x] 发现并修复至少1个潜在bug
- [x] Service层覆盖率 > 50%

#### **理想成功标准**  
- [x] Service层覆盖率 > 70%
- [x] 包含边界条件测试
- [x] 有基本的Mock使用
- [x] 集成到Maven构建流程

### 11.6 什么时候停止

#### **当前阶段可以停止的信号**
1. ✅ 核心业务方法都有测试覆盖
2. ✅ 运行测试能发现明显的业务逻辑错误
3. ✅ 团队对测试框架有基本了解
4. ✅ 测试可以稳定运行，不是偶尔通过

#### **不需要追求的目标（当前阶段）**
- ❌ 100%覆盖率
- ❌ 复杂的集成测试
- ❌ 性能测试
- ❌ 所有边界条件
- ❌ 完美的Mock策略

### 11.7 投入产出比分析

| 测试程度 | 时间投入 | 覆盖率 | 发现bug能力 | 维护成本 | **推荐度** |
|---------|---------|--------|-------------|----------|-----------|
| **基础测试** | 1周 | 50-60% | 中等 | 低 | ⭐⭐⭐⭐⭐ |
| 标准测试 | 2-3周 | 70-80% | 高 | 中等 | ⭐⭐⭐ |
| 完整测试 | 4-6周 | 85%+ | 很高 | 高 | ⭐⭐ |

**结论**：当前项目建议采用**基础测试**策略，投入产出比最优。

## 12. 完整实施计划（推荐）

### **Day 1: 环境搭建**
```bash
# 1. 添加测试依赖到pom.xml
# 2. 创建测试目录结构
mkdir -p src/test/java/com/binaryoption/orderservice/service
mkdir -p src/test/resources

# 3. 运行第一个测试
mvn test
```

### **Day 2-3: 核心Service测试**
- ✅ OrderService.createOrder() - DEMO账户基本场景
- ✅ OrderService.settleOrder() - WIN/LOSE基本场景  
- ✅ FixtureService.calculateOddsFromFixturePrice() - 基本计算

**目标**: 3个核心方法有基本测试，能运行通过

### **Day 4-5: 边界条件**
- ✅ 余额不足场景
- ✅ 参数验证失败
- ✅ 外部API调用失败

**目标**: 每个核心方法有2-3个测试场景

### **Day 6-7: 完善和优化**
- ✅ 生成覆盖率报告
- ✅ 修复测试中发现的bug
- ✅ 简化Mock设置

**目标**: Service层覆盖率达到60%+

### **验收标准**
```bash
# 运行测试
mvn test

# 生成覆盖率报告  
mvn jacoco:report

# 检查报告
open target/site/jacoco/index.html
```

**期望结果**:
- ✅ 所有测试通过（绿色）
- ✅ OrderService覆盖率 > 60%
- ✅ FixtureService覆盖率 > 70%
- ✅ 发现并修复至少1个业务逻辑问题

## 13. 参考集成测试脚本的单元测试策略

### 13.1 从OAuth集成测试脚本学到的经验

通过分析 `simple-flow-test-oauth.sh`，我们发现了一个完整的业务流程测试，它测试了：

1. **OAuth认证和用户注册**
2. **账户管理**（DEMO/REAL余额检查）
3. **资金操作**（领取、转入、转出）
4. **订单流程**（创建、查询、结算）
5. **轮次管理**（获取、结算、查询）
6. **历史记录**（订单、转账）

### 13.2 单元测试可以借鉴的测试数据和场景

#### **13.2.1 测试数据标准化**
```java
public class IntegrationTestData {
    
    // 参考脚本中的测试用户ID生成策略
    public static final Long MOCK_USER_ID = 10000L + new Random().nextInt(90000); // 10000-99999
    public static final String TEST_USERNAME = "testuser_" + System.currentTimeMillis();
    public static final String TEST_TOKEN = "test_oauth_token_" + UUID.randomUUID();
    
    // 参考脚本中的订单金额
    public static final BigDecimal DEMO_ORDER_AMOUNT = new BigDecimal("10.00");
    public static final BigDecimal REAL_ORDER_AMOUNT = new BigDecimal("5.00");
    public static final BigDecimal TRANSFER_AMOUNT = new BigDecimal("20.00");
    
    // 测试账户初始状态
    public static AccountDTO createDemoAccount(Long userId) {
        return AccountDTO.builder()
            .userId(userId)
            .accountType("DEMO")
            .balance(new BigDecimal("10000")) // DEMO账户领取后的余额
            .frozenBalance(BigDecimal.ZERO)
            .build();
    }
    
    public static AccountDTO createRealAccount(Long userId) {
        return AccountDTO.builder()
            .userId(userId)
            .accountType("REAL")
            .balance(new BigDecimal("20.00")) // BTSE转入后的余额
            .frozenBalance(BigDecimal.ZERO)
            .build();
    }
}
```

#### **13.2.2 完整业务流程单元测试**
```java
@SpringBootTest
@TestMethodOrder(OrderAnnotation.class)
class OrderServiceCompleteFlowTest {
    
    @Autowired
    private OrderService orderService;
    
    @MockBean
    private AccountServiceRpcClient accountRpcClient;
    
    @MockBean
    private BtseRpcClient btseRpcClient;
    
    private static Long TEST_USER_ID;
    private static Long CURRENT_ROUND_ID;
    private static List<Long> DEMO_ORDER_IDS = new ArrayList<>();
    private static List<Long> REAL_ORDER_IDS = new ArrayList<>();
    
    @BeforeAll
    static void setupTestUser() {
        TEST_USER_ID = IntegrationTestData.MOCK_USER_ID;
        // 模拟获取当前轮次
        CURRENT_ROUND_ID = 1L;
    }
    
    @Test
    @Order(1)
    @DisplayName("步骤1: DEMO账户下单流程（参考脚本步骤6）")
    void testDemoOrderFlow() {
        // Setup: 模拟DEMO账户有足够余额
        when(accountRpcClient.getAccount(TEST_USER_ID, "DEMO"))
            .thenReturn(Result.success(IntegrationTestData.createDemoAccount(TEST_USER_ID)));
        
        // 参考脚本：下3个DEMO订单，交替UP/DOWN方向
        for (int i = 1; i <= 3; i++) {
            String direction = (i % 2 == 1) ? "UP" : "DOWN";
            
            CreateOrderDTO request = CreateOrderDTO.builder()
                .userId(TEST_USER_ID)
                .symbolId(1L)
                .amount(IntegrationTestData.DEMO_ORDER_AMOUNT)
                .direction(direction)
                .accountType("DEMO")
                .build();
            
            Result<OrderDTO> result = orderService.createOrder(request);
            
            assertThat(result.isSuccess()).isTrue();
            DEMO_ORDER_IDS.add(result.getData().getId());
        }
        
        assertThat(DEMO_ORDER_IDS).hasSize(3);
    }
    
    @Test
    @Order(2)
    @DisplayName("步骤2: REAL账户下单流程（参考脚本步骤8）")
    void testRealOrderFlow() {
        // Setup: 模拟REAL账户有BTSE转入的余额
        when(accountRpcClient.getAccount(TEST_USER_ID, "REAL"))
            .thenReturn(Result.success(IntegrationTestData.createRealAccount(TEST_USER_ID)));
        
        // 参考脚本：下3个REAL订单，与DEMO相反的方向
        for (int i = 1; i <= 3; i++) {
            String direction = (i % 2 == 1) ? "DOWN" : "UP"; // 与DEMO相反
            
            CreateOrderDTO request = CreateOrderDTO.builder()
                .userId(TEST_USER_ID)
                .symbolId(1L)
                .amount(IntegrationTestData.REAL_ORDER_AMOUNT)
                .direction(direction)
                .accountType("REAL")
                .build();
            
            Result<OrderDTO> result = orderService.createOrder(request);
            
            assertThat(result.isSuccess()).isTrue();
            REAL_ORDER_IDS.add(result.getData().getId());
        }
        
        assertThat(REAL_ORDER_IDS).hasSize(3);
    }
    
    @Test
    @Order(3)
    @DisplayName("步骤3: 订单结算流程（参考脚本步骤15）")
    void testOrderSettlement() {
        // 模拟Fixture数据（参考脚本中的结算逻辑）
        mockFixtureResponse();
        
        // 执行轮次结算
        Result<SettlementResultDTO> result = orderService.settleRoundOrders(CURRENT_ROUND_ID);
        
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getData().getSettledCount()).isEqualTo(6); // 3个DEMO + 3个REAL
    }
    
    @Test
    @Order(4)
    @DisplayName("步骤4: 查询轮次订单（参考脚本步骤13）")
    void testQueryRoundOrders() {
        // 查询DEMO轮次订单
        Result<RoundOrdersDTO> demoResult = orderService.getRoundOrders(CURRENT_ROUND_ID, "DEMO");
        assertThat(demoResult.isSuccess()).isTrue();
        assertThat(demoResult.getData().getOrders()).hasSize(3);
        
        // 查询REAL轮次订单  
        Result<RoundOrdersDTO> realResult = orderService.getRoundOrders(CURRENT_ROUND_ID, "REAL");
        assertThat(realResult.isSuccess()).isTrue();
        assertThat(realResult.getData().getOrders()).hasSize(3);
    }
    
    private void mockFixtureResponse() {
        FixturesResponseDTO fixturesResponse = FixturesResponseDTO.builder()
            .symbol("BTC-USDT")
            .price(new BigDecimal("50000")) // 结算价格
            .build();
        
        when(btseRpcClient.getFixtures(any()))
            .thenReturn(Result.success(fixturesResponse));
    }
}
```

#### **13.2.3 参考脚本的错误处理测试**
```java
@Test
@DisplayName("余额不足场景（参考脚本的边界处理）")
void testInsufficientBalance() {
    // 参考脚本：当REAL账户余额不足10 USDT时跳过转出
    AccountDTO insufficientAccount = AccountDTO.builder()
        .userId(TEST_USER_ID)
        .accountType("REAL")
        .balance(new BigDecimal("5.00")) // 不足
        .build();
    
    when(accountRpcClient.getAccount(TEST_USER_ID, "REAL"))
        .thenReturn(Result.success(insufficientAccount));
    
    CreateOrderDTO request = CreateOrderDTO.builder()
        .userId(TEST_USER_ID)
        .amount(new BigDecimal("10.00")) // 超过余额
        .accountType("REAL")
        .build();
    
    Result<OrderDTO> result = orderService.createOrder(request);
    
    assertThat(result.isError()).isTrue();
    assertThat(result.getMessage()).contains("余额不足");
}
```

### 13.3 参考脚本优化的测试建议

#### **13.3.1 简化版本（推荐开始）**
基于脚本的复杂度，我们可以先实现一个简化版本：

```java
@Test
@DisplayName("核心业务流程测试（简化版）")
void testCoreBusinessFlow() {
    // 1. 创建订单（参考脚本步骤6）
    Result<OrderDTO> orderResult = createTestOrder();
    assertThat(orderResult.isSuccess()).isTrue();
    
    // 2. 模拟轮次结算（参考脚本步骤15）
    Result<SettlementResultDTO> settlementResult = settleTestOrder(orderResult.getData().getId());
    assertThat(settlementResult.isSuccess()).isTrue();
    
    // 3. 验证最终状态
    verifyFinalOrderState(orderResult.getData().getId());
}
```

#### **13.3.2 测试数据生成工具**
```java
public class ScriptBasedTestDataGenerator {
    
    /**
     * 参考脚本生成OAuth用户数据
     */
    public static UserContextData generateOAuthUser() {
        long timestamp = System.currentTimeMillis();
        long mockUserId = 10000 + new Random().nextInt(90000);
        
        return UserContextData.builder()
            .username("testuser_" + timestamp)
            .mockUserId(mockUserId)
            .token("test_token_" + timestamp)
            .build();
    }
    
    /**
     * 参考脚本生成轮次数据
     */
    public static TradingRoundData generateTradingRound() {
        return TradingRoundData.builder()
            .symbolId(1L)
            .durationMinutes(5)
            .status("OPEN")
            .upAmount(BigDecimal.ZERO)
            .downAmount(BigDecimal.ZERO)
            .build();
    }
}
```

### 13.4 集成测试脚本vs单元测试对比

| 方面 | 集成测试脚本 | 单元测试建议 |
|-----|-------------|-------------|
| **范围** | 完整业务流程 | 单个方法/类 |
| **数据** | 真实API调用 | Mock数据 |
| **速度** | 慢（30秒+） | 快（<5秒） |
| **维护** | 依赖外部服务 | 独立运行 |
| **用途** | E2E验证 | 快速反馈 |

**建议策略**：
1. **日常开发**：使用单元测试快速验证逻辑
2. **集成验证**：定期运行脚本验证完整流程
3. **数据共享**：单元测试使用脚本中验证过的数据格式

### 13.5 最终建议

基于脚本分析，当前阶段的单元测试应该：

#### **✅ 必须覆盖（参考脚本核心流程）**
1. 订单创建逻辑（DEMO/REAL）
2. 订单结算逻辑（WIN/LOSE/DRAW）
3. 余额检查和冻结
4. 基本的Fixture选择

#### **⚠️ 可以简化（暂不必全面覆盖）**
1. OAuth认证流程（已有集成测试）
2. BTSE转账流程（已有集成测试）
3. 复杂的轮次管理（已有集成测试）
4. 历史查询功能（业务逻辑简单）

#### **❌ 暂不测试（集成测试已覆盖）**
1. API网关路由
2. Redis操作
3. 外部API调用时序
4. 数据库事务完整性

**结论**：参考脚本的测试方法，我们的单元测试应该专注于**业务逻辑核心**，而将**系统集成验证**留给集成测试脚本。

## 14. 常见问题处理

### 12.1 用户ID和接口调用处理

#### 12.1.1 用户上下文Mock
```java
@ExtendWith(MockitoExtension.class)
class OrderServiceWithUserContextTest {
    
    @Mock
    private OrderMapper orderMapper;
    
    @Mock
    private AccountServiceRpcClient accountServiceRpcClient;
    
    @InjectMocks
    private OrderService orderService;
    
    // 测试用户ID常量
    private static final Long TEST_USER_ID = 999999L;
    private static final Long TEST_ADMIN_USER_ID = 888888L;
    private static final String TEST_USERNAME = "test_user";
    
    @BeforeEach
    void setupUserContext() {
        // 方案1：使用ThreadLocal模拟用户上下文
        UserContext.setCurrentUser(new UserInfo(TEST_USER_ID, TEST_USERNAME));
    }
    
    @AfterEach
    void clearUserContext() {
        UserContext.clear();
    }
    
    @Test
    @DisplayName("创建订单 - 使用当前用户ID")
    void createOrder_WithCurrentUserId() {
        // Given - 不传userId，从上下文获取
        CreateOrderDTO request = CreateOrderDTO.builder()
            .symbolId(1L)
            .amount(new BigDecimal("100"))
            .direction("UP")
            .accountType("DEMO")
            .build();
        
        // Mock账户查询 - 使用测试用户ID
        AccountDTO account = AccountDTO.builder()
            .id(1L)
            .userId(TEST_USER_ID)
            .accountType("DEMO")
            .balance(new BigDecimal("1000"))
            .build();
        
        when(accountServiceRpcClient.getAccount(TEST_USER_ID, "DEMO"))
            .thenReturn(Result.success(account));
        
        // When
        Result<OrderDTO> result = orderService.createOrder(request);
        
        // Then
        assertThat(result.isSuccess()).isTrue();
        verify(orderMapper).insert(argThat(order -> 
            order.getUserId().equals(TEST_USER_ID)
        ));
    }
}
```

#### 12.1.2 接口调用Mock策略
```java
@SpringBootTest
class OrderServiceIntegrationTest {
    
    @MockBean
    private BtseRpcClient btseRpcClient;
    
    @MockBean
    private AccountServiceRpcClient accountServiceRpcClient;
    
    @Autowired
    private OrderService orderService;
    
    // 使用固定的测试数据
    private static class TestUsers {
        static final Long NORMAL_USER = 10001L;
        static final Long VIP_USER = 10002L;
        static final Long RESTRICTED_USER = 10003L;
    }
    
    @Test
    @DisplayName("RPC调用测试 - 正常用户")
    void testRpcCall_NormalUser() {
        // 为特定用户配置Mock响应
        setupMockForUser(TestUsers.NORMAL_USER, "DEMO", 
            new BigDecimal("10000"), new BigDecimal("0"));
        
        CreateOrderDTO request = CreateOrderDTO.builder()
            .userId(TestUsers.NORMAL_USER)
            .symbolId(1L)
            .amount(new BigDecimal("100"))
            .direction("UP")
            .accountType("DEMO")
            .build();
        
        Result<OrderDTO> result = orderService.createOrder(request);
        
        assertThat(result.isSuccess()).isTrue();
    }
    
    @Test
    @DisplayName("RPC调用测试 - VIP用户特殊处理")
    void testRpcCall_VipUser() {
        // VIP用户可能有不同的限制和费率
        setupMockForUser(TestUsers.VIP_USER, "REAL", 
            new BigDecimal("100000"), new BigDecimal("5000"));
        
        // 测试VIP用户特殊逻辑
    }
    
    private void setupMockForUser(Long userId, String accountType, 
                                  BigDecimal balance, BigDecimal frozen) {
        AccountDTO account = AccountDTO.builder()
            .id(userId)
            .userId(userId)
            .accountType(accountType)
            .balance(balance)
            .frozenBalance(frozen)
            .build();
        
        when(accountServiceRpcClient.getAccount(userId, accountType))
            .thenReturn(Result.success(account));
    }
}
```

#### 12.1.3 使用WireMock模拟外部API
```java
@SpringBootTest
@AutoConfigureMockMvc
class ExternalApiTest {
    
    @RegisterExtension
    static WireMockExtension wireMock = WireMockExtension.newInstance()
        .options(wireMockConfig().port(8089))
        .build();
    
    @Autowired
    private OrderService orderService;
    
    @Test
    @DisplayName("BTSE API调用模拟")
    void testBtseApiCall() {
        // 配置WireMock响应
        wireMock.stubFor(get(urlPathEqualTo("/api/fixtures"))
            .withQueryParam("symbol", equalTo("BTC-USDT"))
            .willReturn(aResponse()
                .withStatus(200)
                .withHeader("Content-Type", "application/json")
                .withBody("""
                    {
                        "symbol": "BTC-USDT",
                        "price": 50000,
                        "open": [{
                            "side": "call",
                            "price": 0.5,
                            "expiration": "2024-01-01 12:00:00"
                        }]
                    }
                    """)));
        
        // 执行测试
        FixtureService.FixtureSelectionResult result = 
            fixtureService.selectFixtureForOrder(1L, "UP", LocalDateTime.now(), 5);
        
        // 验证API被调用
        wireMock.verify(getRequestedFor(urlPathEqualTo("/api/fixtures")));
    }
}
```

#### 12.1.4 用户权限和角色测试
```java
@TestConfiguration
public class TestSecurityConfig {
    
    @Bean
    @Primary
    public SecurityContext mockSecurityContext() {
        return new MockSecurityContext();
    }
    
    public static class MockSecurityContext implements SecurityContext {
        private Long userId;
        private Set<String> roles;
        
        public void setUser(Long userId, String... roles) {
            this.userId = userId;
            this.roles = new HashSet<>(Arrays.asList(roles));
        }
        
        @Override
        public Long getCurrentUserId() {
            return userId != null ? userId : 1L; // 默认测试用户
        }
        
        @Override
        public boolean hasRole(String role) {
            return roles != null && roles.contains(role);
        }
    }
}

@SpringBootTest
class OrderServiceSecurityTest {
    
    @Autowired
    private TestSecurityConfig.MockSecurityContext securityContext;
    
    @Autowired
    private OrderService orderService;
    
    @Test
    @DisplayName("管理员用户可以查看所有订单")
    void testAdminCanViewAllOrders() {
        // 设置为管理员用户
        securityContext.setUser(1L, "ADMIN");
        
        Result<List<OrderDTO>> result = orderService.getAllOrders();
        
        assertThat(result.isSuccess()).isTrue();
    }
    
    @Test
    @DisplayName("普通用户只能查看自己的订单")
    void testNormalUserCanOnlyViewOwnOrders() {
        // 设置为普通用户
        Long userId = 100L;
        securityContext.setUser(userId, "USER");
        
        Result<List<OrderDTO>> result = orderService.getUserOrders(userId);
        
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getData())
            .allMatch(order -> order.getUserId().equals(userId));
    }
}
```

#### 12.1.5 批量用户测试（数据驱动测试）
```java
class UserParameterizedTest {
    
    @ParameterizedTest
    @CsvSource({
        "1, DEMO, 1000, 100, true",      // 正常用户，余额充足
        "2, DEMO, 50, 100, false",       // 余额不足
        "3, REAL, 1000, 100, true",      // REAL账户
        "4, DEMO, 1000, 10001, false",   // 超过最大限额
    })
    @DisplayName("不同用户场景的订单创建测试")
    void testCreateOrderForDifferentUsers(
            Long userId, String accountType, BigDecimal balance, 
            BigDecimal orderAmount, boolean expectedSuccess) {
        
        // Setup mock for each user
        AccountDTO account = AccountDTO.builder()
            .userId(userId)
            .accountType(accountType)
            .balance(balance)
            .build();
        
        when(accountServiceRpcClient.getAccount(userId, accountType))
            .thenReturn(Result.success(account));
        
        // Execute
        CreateOrderDTO request = CreateOrderDTO.builder()
            .userId(userId)
            .amount(orderAmount)
            .accountType(accountType)
            .symbolId(1L)
            .direction("UP")
            .build();
        
        Result<OrderDTO> result = orderService.createOrder(request);
        
        // Verify
        assertThat(result.isSuccess()).isEqualTo(expectedSuccess);
    }
}
```

#### 12.1.6 测试用户工厂
```java
public class TestUserFactory {
    
    private static final AtomicLong userIdGenerator = new AtomicLong(100000);
    
    /**
     * 创建测试用户，自动生成唯一ID
     */
    public static UserDTO createTestUser() {
        Long userId = userIdGenerator.incrementAndGet();
        return UserDTO.builder()
            .id(userId)
            .username("test_user_" + userId)
            .externalId("ext_" + userId)
            .status("ACTIVE")
            .createdAt(LocalDateTime.now())
            .build();
    }
    
    /**
     * 创建带账户的测试用户
     */
    public static TestUserWithAccounts createUserWithAccounts() {
        UserDTO user = createTestUser();
        
        AccountDTO demoAccount = AccountDTO.builder()
            .id(userIdGenerator.incrementAndGet())
            .userId(user.getId())
            .accountType("DEMO")
            .balance(new BigDecimal("10000"))
            .frozenBalance(BigDecimal.ZERO)
            .build();
        
        AccountDTO realAccount = AccountDTO.builder()
            .id(userIdGenerator.incrementAndGet())
            .userId(user.getId())
            .accountType("REAL")
            .balance(BigDecimal.ZERO)
            .frozenBalance(BigDecimal.ZERO)
            .build();
        
        return new TestUserWithAccounts(user, demoAccount, realAccount);
    }
    
    @Data
    @AllArgsConstructor
    public static class TestUserWithAccounts {
        private UserDTO user;
        private AccountDTO demoAccount;
        private AccountDTO realAccount;
    }
}

// 使用示例
@Test
void testWithGeneratedUser() {
    TestUserWithAccounts testData = TestUserFactory.createUserWithAccounts();
    
    when(userService.getUser(testData.getUser().getId()))
        .thenReturn(Result.success(testData.getUser()));
    
    when(accountServiceRpcClient.getAccount(
        testData.getUser().getId(), "DEMO"))
        .thenReturn(Result.success(testData.getDemoAccount()));
    
    // 执行测试...
}
```

#### 12.1.7 接口调用录制和回放
```java
@Component
@Profile("test")
public class RpcCallRecorder {
    
    private final Map<String, Object> recordings = new ConcurrentHashMap<>();
    
    /**
     * 录制模式 - 记录真实调用
     */
    public <T> T recordCall(String key, Supplier<T> actualCall) {
        if (isRecordingMode()) {
            T result = actualCall.get();
            recordings.put(key, result);
            saveRecording(key, result);
            return result;
        } else {
            // 回放模式
            return loadRecording(key);
        }
    }
    
    private boolean isRecordingMode() {
        return "record".equals(System.getProperty("test.mode"));
    }
    
    private void saveRecording(String key, Object result) {
        // 保存到文件，供后续测试使用
        String fileName = "src/test/resources/recordings/" + key + ".json";
        JsonUtil.writeToFile(fileName, result);
    }
    
    @SuppressWarnings("unchecked")
    private <T> T loadRecording(String key) {
        String fileName = "src/test/resources/recordings/" + key + ".json";
        return (T) JsonUtil.readFromFile(fileName);
    }
}

// 使用示例
@Test
void testWithRecordedData() {
    Result<FixturesResponseDTO> result = rpcCallRecorder.recordCall(
        "fixtures_btc_usdt_" + TEST_USER_ID,
        () -> btseRpcClient.getFixtures(request)
    );
    
    assertThat(result.isSuccess()).isTrue();
}
```

### 12.2 时间相关测试
```java
@Test
void testWithFixedTime() {
    // 使用固定时间
    Clock fixedClock = Clock.fixed(Instant.parse("2024-01-01T00:00:00Z"), ZoneOffset.UTC);
    LocalDateTime fixedTime = LocalDateTime.now(fixedClock);
    
    // 或使用Mockito
    try (MockedStatic<LocalDateTime> mockedTime = mockStatic(LocalDateTime.class)) {
        mockedTime.when(LocalDateTime::now).thenReturn(fixedTime);
        // 测试代码
    }
}
```

### 12.2 并发测试
```java
@Test
void testConcurrentOrderCreation() throws InterruptedException {
    int threadCount = 10;
    CountDownLatch latch = new CountDownLatch(threadCount);
    ExecutorService executor = Executors.newFixedThreadPool(threadCount);
    
    for (int i = 0; i < threadCount; i++) {
        executor.submit(() -> {
            try {
                orderService.createOrder(TestDataFactory.defaultCreateOrderDTO().build());
            } finally {
                latch.countDown();
            }
        });
    }
    
    latch.await();
    // 验证结果
}
```

### 12.3 异常测试
```java
@Test
void testExceptionHandling() {
    when(btseRpcClient.getFixtures(any()))
        .thenReturn(Result.error(500, "API Error"));
    
    assertThatThrownBy(() -> fixtureService.selectFixtureForOrder(1L, "UP", LocalDateTime.now(), 5))
        .isInstanceOf(BusinessException.class)
        .hasMessageContaining("fixture.api.failed");
}
```