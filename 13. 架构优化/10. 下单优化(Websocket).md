# 下单优化 - WebSocket报价订阅方案

## 1. 背景与目标

### 1.1 当前问题
- **Fixture API调用延迟**：每次下单需要调用fixture API获取价格，增加约100-150ms延迟
- **串行依赖**：价格获取是下单流程的强依赖，无法与其他操作并行
- **网络开销**：频繁的HTTP请求增加网络负担
- **价格时效性**：HTTP获取的价格可能已过时

### 1.2 优化目标
- 将下单API响应时间从500ms降至200ms以内
- 提供实时价格数据，确保价格时效性
- 减少HTTP请求，降低网络开销
- 支持批量订单的高效处理

## 2. 技术方案

### 2.1 架构设计

#### 方案一：Order Service直连BTSE WebSocket
```
        BTSE WebSocket
              │
              ▼
    ┌─────────────────┐
    │  Order Service  │
    │  (Price Cache)  │
    └─────────────────┘
              │
              ▼
      Cached Price
       for Orders
       
优势：
- 无需依赖其他服务
- 减少网络跳转
- 降低故障点
- 架构最简单
```

#### 方案二：Market Service + Redis（推荐）
```
    BTSE WebSocket
          │
          ▼
┌─────────────────┐     write     ┌───────────┐     read      ┌─────────────────┐
│ Market Service  │ ───────────► │   Redis   │ ◄─────────── │  Order Service  │
│ (Price Writer)  │               │  (Cache)  │               │ (Price Reader)  │
└─────────────────┘               └───────────┘               └─────────────────┘

优势：
- 解耦：Market和Order服务独立
- 可扩展：多个服务可共享价格数据
- 持久化：Redis数据不会因重启丢失
- 高性能：Redis读写都极快
- 统一缓存：所有价格数据集中管理
```

### 2.2 核心组件

## 方案一实现：直连BTSE WebSocket

#### 2.2.1 Order Service - 直连BTSE WebSocket客户端

```java
package com.binaryoption.orderservice.ws;

import lombok.extern.slf4j.Slf4j;
import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import org.springframework.stereotype.Component;
import javax.annotation.PostConstruct;
import java.net.URI;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Slf4j
@Component
public class BtseMarketWebSocketClient extends WebSocketClient {
    
    private static final String BTSE_WS_URL = "wss://ws.btse.com/ws/futures";
    private static final long RECONNECT_DELAY = 5000;
    private static final long HEARTBEAT_INTERVAL = 30000;
    
    // 价格缓存
    private final Map<String, PriceData> priceCache = new ConcurrentHashMap<>();
    private final Map<String, FixtureData> fixtureCache = new ConcurrentHashMap<>();
    
    // 调度器
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);
    
    public BtseMarketWebSocketClient() {
        super(URI.create(BTSE_WS_URL));
    }
    
    @PostConstruct
    public void init() {
        // 连接BTSE
        connect();
        
        // 心跳保活
        scheduler.scheduleWithFixedDelay(this::sendPing, 
            HEARTBEAT_INTERVAL, HEARTBEAT_INTERVAL, TimeUnit.MILLISECONDS);
            
        // 价格过期清理
        scheduler.scheduleWithFixedDelay(this::cleanStaleData, 
            60000, 60000, TimeUnit.MILLISECONDS);
    }
    
    @Override
    public void onOpen(ServerHandshake handshake) {
        log.info("Connected to BTSE WebSocket");
        
        // 订阅所需的交易对
        subscribeToSymbols();
    }
    
    private void subscribeToSymbols() {
        // 订阅价格数据
        String subscribe = """
            {
                "op": "subscribe",
                "args": [
                    "orderBookL2:BTCPFC",
                    "orderBookL2:ETHPFC",
                    "ticker:BTCPFC",
                    "ticker:ETHPFC"
                ]
            }
            """;
        send(subscribe);
    }
    
    @OnMessage
    public void onMessage(String message) {
        try {
            MarketMessage msg = objectMapper.readValue(message, MarketMessage.class);
            
            switch (msg.getType()) {
                case "price":
                    updatePriceCache(msg.getSymbol(), msg.getPrice());
                    break;
                case "fixture":
                    updateFixtureCache(msg.getSymbol(), msg.getFixtures());
                    break;
                default:
                    log.debug("Unknown message type: {}", msg.getType());
            }
        } catch (Exception e) {
            log.error("Error processing market message", e);
        }
    }
    
    /**
     * 获取实时价格（替代fixture API调用）
     */
    public PriceData getCurrentPrice(String symbol) {
        PriceData price = priceCache.get(symbol);
        
        // 检查价格时效性（超过5秒认为过期）
        if (price == null || System.currentTimeMillis() - price.getTimestamp() > 5000) {
            log.warn("Price for {} is stale or missing, falling back to API", symbol);
            // 降级到API调用
            return fallbackToFixtureApi(symbol);
        }
        
        return price;
    }
    
    /**
     * 获取fixture数据
     */
    public FixtureData getCurrentFixture(String symbol) {
        FixtureData fixture = fixtureCache.get(symbol);
        
        if (fixture == null || isStale(fixture)) {
            return fallbackToFixtureApi(symbol);
        }
        
        return fixture;
    }
}
```

    @Override
    public void onMessage(String message) {
        try {
            JsonNode data = objectMapper.readTree(message);
            
            // 处理BTSE价格数据
            if (data.has("data") && data.has("topic")) {
                String topic = data.get("topic").asText();
                
                if (topic.startsWith("ticker:")) {
                    processTicker(data);
                } else if (topic.startsWith("orderBookL2:")) {
                    processOrderBook(data);
                }
            }
        } catch (Exception e) {
            log.error("Error processing BTSE message: {}", message, e);
        }
    }
    
    private void processTicker(JsonNode data) {
        JsonNode tickerData = data.get("data");
        String symbol = extractSymbol(data.get("topic").asText());
        
        PriceData priceData = PriceData.builder()
            .symbol(symbol)
            .price(new BigDecimal(tickerData.get("price").asText()))
            .volume(new BigDecimal(tickerData.get("volume").asText()))
            .timestamp(System.currentTimeMillis())
            .build();
            
        priceCache.put(symbol, priceData);
        log.debug("Updated price for {}: {}", symbol, priceData.getPrice());
    }
    
    private void processOrderBook(JsonNode data) {
        String symbol = extractSymbol(data.get("topic").asText());
        JsonNode bookData = data.get("data");
        
        // 构建fixture数据
        List<FixtureDTO> fixtures = buildFixturesFromOrderBook(bookData);
        
        FixtureData fixtureData = FixtureData.builder()
            .symbol(symbol)
            .fixtures(fixtures)
            .timestamp(System.currentTimeMillis())
            .build();
            
        fixtureCache.put(symbol, fixtureData);
    }
    
    @Override
    public void onClose(int code, String reason, boolean remote) {
        log.warn("BTSE WebSocket closed: {} - {}", code, reason);
        
        // 自动重连
        scheduler.schedule(this::reconnect, RECONNECT_DELAY, TimeUnit.MILLISECONDS);
    }
    
    @Override
    public void onError(Exception ex) {
        log.error("BTSE WebSocket error", ex);
        
        // 重连
        scheduler.schedule(this::reconnect, RECONNECT_DELAY, TimeUnit.MILLISECONDS);
    }
    
    /**
     * 获取实时价格（替代fixture API调用）
     */
    public PriceData getCurrentPrice(String symbol) {
        PriceData price = priceCache.get(symbol);
        
        // 检查价格时效性（超过5秒认为过期）
        if (price == null || System.currentTimeMillis() - price.getTimestamp() > 5000) {
            log.warn("Price for {} is stale or missing, falling back to API", symbol);
            return fallbackToFixtureApi(symbol);
        }
        
        return price;
    }
    
    private void reconnect() {
        if (!isOpen()) {
            try {
                reconnectBlocking();
                log.info("Successfully reconnected to BTSE WebSocket");
            } catch (Exception e) {
                log.error("Failed to reconnect", e);
                scheduler.schedule(this::reconnect, RECONNECT_DELAY * 2, TimeUnit.MILLISECONDS);
            }
        }
    }
}
```

## 方案二实现：Market Service + Redis（推荐）

#### 2.2.2 Market Service - 价格写入Redis

```java
@Component
public class RedisPriceWriter {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String PRICE_KEY_PREFIX = "market:price:";
    private static final String FIXTURE_KEY_PREFIX = "market:fixture:";
    private static final long PRICE_TTL = 10; // 10秒过期
    
    public void updatePrice(String symbol, BigDecimal price) {
        PriceData priceData = PriceData.builder()
            .symbol(symbol)
            .price(price)
            .timestamp(System.currentTimeMillis())
            .build();
            
        String key = PRICE_KEY_PREFIX + symbol;
        redisTemplate.opsForValue().set(key, priceData, PRICE_TTL, TimeUnit.SECONDS);
        
        // 发布价格更新事件（可选）
        redisTemplate.convertAndSend("price_updates", priceData);
    }
    
    public void updateFixture(String symbol, List<FixtureDTO> fixtures) {
        FixtureData fixtureData = FixtureData.builder()
            .symbol(symbol)
            .fixtures(fixtures)
            .timestamp(System.currentTimeMillis())
            .build();
            
        String key = FIXTURE_KEY_PREFIX + symbol;
        redisTemplate.opsForValue().set(key, fixtureData, PRICE_TTL, TimeUnit.SECONDS);
    }
}
```

#### 2.2.3 Order Service - 从Redis读取价格

```java
@Component
public class RedisPriceReader {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private final Map<String, PriceData> localCache = new ConcurrentHashMap<>();
    
    /**
     * 获取实时价格（多级缓存策略）
     */
    public PriceData getCurrentPrice(String symbol) {
        // L1缓存：本地缓存（最快）
        PriceData cached = localCache.get(symbol);
        if (cached != null && !isStale(cached, 2000)) { // 2秒内有效
            return cached;
        }
        
        // L2缓存：Redis缓存
        String key = PRICE_KEY_PREFIX + symbol;
        PriceData redisPrice = (PriceData) redisTemplate.opsForValue().get(key);
        
        if (redisPrice != null && !isStale(redisPrice, 5000)) { // 5秒内有效
            localCache.put(symbol, redisPrice); // 更新本地缓存
            return redisPrice;
        }
        
        // 降级：调用API
        log.warn("Price for {} not found in cache, falling back to API", symbol);
        return fallbackToFixtureApi(symbol);
    }
    
    /**
     * 批量获取价格（适合批量下单）
     */
    public Map<String, PriceData> getCurrentPrices(List<String> symbols) {
        List<String> keys = symbols.stream()
            .map(symbol -> PRICE_KEY_PREFIX + symbol)
            .collect(Collectors.toList());
            
        List<Object> values = redisTemplate.opsForValue().multiGet(keys);
        
        Map<String, PriceData> result = new HashMap<>();
        for (int i = 0; i < symbols.size(); i++) {
            String symbol = symbols.get(i);
            PriceData price = (PriceData) values.get(i);
            
            if (price != null && !isStale(price, 5000)) {
                result.put(symbol, price);
                localCache.put(symbol, price);
            }
        }
        
        return result;
    }
}
```

#### 2.2.4 Redis事件订阅（可选优化）

```java
@Component
public class PriceEventSubscriber {
    
    @Autowired
    private RedisPriceReader priceReader;
    
    @EventListener
    @RedisListener(topics = "price_updates")
    public void onPriceUpdate(PriceData priceData) {
        // 实时更新本地缓存
        priceReader.updateLocalCache(priceData.getSymbol(), priceData);
        
        // 可选：触发其他业务逻辑
        notifyPriceChange(priceData);
    }
}
```

### 2.3 价格缓存策略

```java
@Component
public class PriceCacheManager {
    
    // 多级缓存
    private final Map<String, PriceData> l1Cache = new ConcurrentHashMap<>();  // 热点数据
    private final Cache<String, PriceData> l2Cache;  // Caffeine缓存
    
    public PriceCacheManager() {
        this.l2Cache = Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(5, TimeUnit.SECONDS)
            .build();
    }
    
    public void updatePrice(String symbol, BigDecimal price, List<FixtureDTO> fixtures) {
        PriceData data = PriceData.builder()
            .symbol(symbol)
            .price(price)
            .fixtures(fixtures)
            .timestamp(System.currentTimeMillis())
            .build();
        
        // 更新L1缓存（热点数据）
        if (isHotSymbol(symbol)) {
            l1Cache.put(symbol, data);
        }
        
        // 更新L2缓存
        l2Cache.put(symbol, data);
    }
    
    public PriceData getPrice(String symbol) {
        // 先查L1
        PriceData data = l1Cache.get(symbol);
        if (data != null && !isStale(data)) {
            return data;
        }
        
        // 再查L2
        data = l2Cache.getIfPresent(symbol);
        if (data != null && !isStale(data)) {
            // 提升到L1
            if (isHotSymbol(symbol)) {
                l1Cache.put(symbol, data);
            }
            return data;
        }
        
        return null;
    }
}
```

## 3. 下单流程优化

### 3.1 优化前流程
```
1. 验证用户 (50ms)
2. 验证账户余额 (50ms)  
3. 获取价格/fixture (150ms) ← 瓶颈
4. 创建订单 (30ms)
5. BTSE转账 (150ms)
6. 其他处理 (70ms)
总计: ~500ms
```

### 3.2 优化后流程
```
1. 并行验证:
   - 验证用户
   - 验证账户余额     } 并行执行 (50ms)
   - 从缓存获取价格
   
2. 创建订单 (30ms)
3. BTSE转账 (150ms)
4. 异步处理其他操作
总计: ~230ms
```

### 3.3 代码实现

```java
@Service
public class OptimizedOrderService {
    
    @Autowired
    private MarketPriceWebSocketClient priceClient;
    
    @Transactional
    public Result<OrderDTO> createOrder(OrderCreateRequestDTO request) {
        // 并行获取所需数据
        CompletableFuture<UserDTO> userFuture = CompletableFuture.supplyAsync(() -> 
            validateUser(request.getUserId()));
            
        CompletableFuture<AccountDTO> accountFuture = CompletableFuture.supplyAsync(() -> 
            validateAccountBalance(request.getUserId(), request.getAccountType(), request.getAmount()));
            
        CompletableFuture<PriceData> priceFuture = CompletableFuture.supplyAsync(() -> 
            priceClient.getCurrentPrice(request.getSymbol()));
        
        // 等待所有验证完成
        CompletableFuture.allOf(userFuture, accountFuture, priceFuture).join();
        
        UserDTO user = userFuture.join();
        AccountDTO account = accountFuture.join();
        PriceData priceData = priceFuture.join();
        
        // 快速创建订单
        Order order = createOrderWithCachedPrice(request, priceData);
        
        // BTSE转账（仍需同步）
        if (BusinessConstants.AccountType.REAL.equals(request.getAccountType())) {
            executeBtseTransfer(order);
        }
        
        // 异步处理非关键操作
        CompletableFuture.runAsync(() -> {
            updateRiskStats(order);
            executeHedge(order);
            sendNotifications(order);
        });
        
        return Result.success(orderConverter.toDTO(order));
    }
}
```

## 4. 容错与降级

### 4.1 连接断开处理
```java
@Component
public class ConnectionHealthMonitor {
    
    private volatile boolean wsConnected = false;
    private long lastHeartbeat = System.currentTimeMillis();
    
    @Scheduled(fixedDelay = 5000)
    public void checkConnection() {
        if (!wsConnected || System.currentTimeMillis() - lastHeartbeat > 10000) {
            log.warn("WebSocket connection unhealthy, attempting reconnect");
            reconnect();
        }
    }
    
    private void reconnect() {
        // 指数退避重连
        int retries = 0;
        while (!wsConnected && retries < 5) {
            try {
                Thread.sleep((long) Math.pow(2, retries) * 1000);
                marketPriceClient.connect();
                wsConnected = true;
            } catch (Exception e) {
                retries++;
            }
        }
        
        if (!wsConnected) {
            // 切换到降级模式
            enableFallbackMode();
        }
    }
}
```

### 4.2 降级策略
```java
public class FallbackPriceProvider {
    
    @CircuitBreaker(name = "fixture-api", fallbackMethod = "getCachedPrice")
    public PriceData getPrice(String symbol) {
        // 尝试从WebSocket缓存获取
        PriceData cached = priceCache.get(symbol);
        if (cached != null && !isStale(cached, 10000)) { // 容忍10秒过期
            return cached;
        }
        
        // 降级到HTTP API
        return fixtureService.getCurrentPrice(symbol);
    }
    
    public PriceData getCachedPrice(String symbol, Exception ex) {
        // 最后的降级：返回最近的价格
        PriceData lastKnown = lastKnownPrices.get(symbol);
        if (lastKnown != null) {
            log.warn("Using last known price for {}, age: {}ms", 
                symbol, System.currentTimeMillis() - lastKnown.getTimestamp());
            return lastKnown;
        }
        
        throw new ServiceUnavailableException("Price service unavailable");
    }
}
```

## 5. 监控指标

### 5.1 关键指标
```java
@Component
public class PriceMetrics {
    
    private final MeterRegistry meterRegistry;
    
    // WebSocket连接状态
    private final Gauge wsConnectionGauge;
    
    // 价格缓存命中率
    private final Counter cacheHits;
    private final Counter cacheMisses;
    
    // 价格延迟
    private final Timer priceLatency;
    
    // 降级次数
    private final Counter fallbackCount;
    
    public void recordPriceUpdate(String symbol, long latency) {
        priceLatency.record(latency, TimeUnit.MILLISECONDS);
        
        Tags tags = Tags.of("symbol", symbol);
        meterRegistry.gauge("price.age", tags, latency);
    }
    
    public void recordCacheHit(String symbol) {
        cacheHits.increment();
        meterRegistry.counter("cache.hit.rate", "symbol", symbol).increment();
    }
}
```

### 5.2 监控大盘
```
┌──────────────────────────────────────┐
│        Price Service Dashboard        │
├──────────────────────────────────────┤
│ WebSocket Status: ● Connected         │
│ Cache Hit Rate: 95.2%                │
│ Avg Price Age: 823ms                 │
│ Fallback Rate: 0.1%                  │
│                                      │
│ Symbol    │ Price │ Age  │ Source   │
│ BTC-USDT  │ 67532 │ 0.2s │ WS       │
│ ETH-USDT  │ 3421  │ 0.3s │ WS       │
│ BNB-USDT  │ 512   │ 0.1s │ WS       │
└──────────────────────────────────────┘
```

## 6. 实施计划

### 第一阶段：基础设施（1周）
- [ ] Market Service增加内部WebSocket端点
- [ ] Order Service实现WebSocket客户端
- [ ] 基础价格缓存实现

### 第二阶段：集成优化（1周）
- [ ] 改造下单流程使用缓存价格
- [ ] 实现降级和容错机制
- [ ] 添加监控指标

### 第三阶段：性能优化（3天）
- [ ] 多级缓存优化
- [ ] 连接池调优
- [ ] 压力测试和调优

### 第四阶段：上线验证（2天）
- [ ] 灰度发布
- [ ] 性能对比测试
- [ ] 全量上线

## 7. 预期收益

### 7.1 性能提升
- **下单延迟**：500ms → 200-250ms（降低50%+）
- **价格时效性**：从秒级提升到毫秒级
- **系统吞吐量**：提升30%以上

### 7.2 成本降低
- **网络开销**：减少90%的fixture API调用
- **CPU使用率**：降低HTTP请求处理开销
- **数据库压力**：减少价格查询压力

### 7.3 用户体验
- **下单响应更快**：用户感知明显
- **价格更准确**：实时价格，减少滑点
- **高峰期体验**：WebSocket长连接更稳定

## 8. 风险与对策

| 风险 | 影响 | 对策 |
|------|------|------|
| WebSocket连接不稳定 | 价格更新中断 | 自动重连+降级到API |
| 价格缓存过期 | 使用过期价格 | 严格的TTL+时效性检查 |
| 内存占用增加 | 系统资源压力 | 多级缓存+LRU淘汰 |
| 服务间依赖增强 | 故障传播 | 熔断器+降级策略 |

## 9. 方案对比

| 特性 | 方案一：直连BTSE | 方案二：Redis缓存 |
|------|------------------|------------------|
| **架构复杂度** | 最简单 | 适中 |
| **服务依赖** | 无 | 依赖Redis |
| **可扩展性** | 低（单服务） | 高（多服务共享） |
| **故障隔离** | 差（WebSocket故障影响下单） | 好（Market故障不影响已缓存价格） |
| **数据持久化** | 无 | 有（Redis） |
| **运维复杂度** | 低 | 中等 |
| **性能** | 极高 | 高 |

## 10. 推荐方案

**推荐方案二（Market Service + Redis）**，理由：
1. **更好的架构分离**：价格获取和订单处理职责分离
2. **高可扩展性**：多个服务可共享价格数据
3. **更强的容错性**：Market Service故障不会立即影响Order Service
4. **运维友好**：Redis集群提供高可用性
5. **数据一致性**：所有服务使用统一的价格源

## 11. 总结

通过引入缓存机制替代实时API调用，我们可以：
1. 显著降低下单延迟（50%+）
2. 提供毫秒级实时价格
3. 减少外部API调用
4. 提升整体系统性能

推荐使用Redis方案，平衡了性能提升和系统架构的合理性，通过多级缓存和降级策略确保系统稳定性。