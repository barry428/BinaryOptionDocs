# 开发环境读写分离配置方案

## 一、方案概述

### 1.1 开发环境特点
- **单数据库**：只有一个数据库实例
- **目标**：验证读写分离逻辑，但不需要真正的主从复制
- **方案**：主库和从库配置为同一个数据库，通过日志监控路由效果

### 1.2 技术实现
```yaml
# 核心思路：两个数据源指向同一个数据库
spring:
  datasource:
    master: 
      jdbc-url: jdbc:postgresql://localhost:5433/binary_option  # 同一个库
    slave:  
      jdbc-url: jdbc:postgresql://localhost:5433/binary_option  # 同一个库
```

## 二、详细配置

### 2.1 开发环境配置文件

#### 📄 `option-common-service/src/main/resources/application-dev.yml`
```yaml
spring:
  datasource:
    # 主库配置
    master:
      jdbc-url: jdbc:postgresql://localhost:5433/binary_option
      username: postgres
      password: root
      driver-class-name: org.postgresql.Driver
      hikari:
        pool-name: MasterHikariPool-DEV
        minimum-idle: 5
        maximum-pool-size: 10
        connection-timeout: 30000
        
    # 从库配置（指向同一个数据库）
    slave:
      jdbc-url: jdbc:postgresql://localhost:5433/binary_option  # 👈 同一个数据库
      username: postgres
      password: root
      driver-class-name: org.postgresql.Driver
      hikari:
        pool-name: SlaveHikariPool-DEV
        minimum-idle: 3
        maximum-pool-size: 8
        connection-timeout: 30000

# 读写分离配置
datasource:
  read-write-separation:
    enabled: true                    # 启用读写分离逻辑
    fallback-to-master: true

# 日志配置 - 详细显示数据源切换
logging:
  level:
    com.binaryoption.commonutils.datasource: DEBUG  # 显示数据源切换日志
    com.zaxxer.hikari: DEBUG                         # 显示连接池日志
    root: INFO
```

#### 📄 `option-order-service/src/main/resources/application-dev.yml`
```yaml
# 与 common-service 相同的配置
spring:
  datasource:
    master:
      jdbc-url: jdbc:postgresql://localhost:5433/binary_option
      username: postgres
      password: root
      driver-class-name: org.postgresql.Driver
      hikari:
        pool-name: MasterHikariPool-OrderService-DEV
        minimum-idle: 5
        maximum-pool-size: 10
        
    slave:
      jdbc-url: jdbc:postgresql://localhost:5433/binary_option  # 👈 同一个数据库
      username: postgres
      password: root
      driver-class-name: org.postgresql.Driver
      hikari:
        pool-name: SlaveHikariPool-OrderService-DEV
        minimum-idle: 3
        maximum-pool-size: 8

datasource:
  read-write-separation:
    enabled: true
    fallback-to-master: true

logging:
  level:
    com.binaryoption.commonutils.datasource: DEBUG
    com.zaxxer.hikari: DEBUG
```

### 2.2 增强的日志配置

#### 📄 `logback-spring.xml` 增强配置
```xml
<!-- 在现有的 logback-spring.xml 中添加以下配置 -->

<!-- 数据源切换专用日志 -->
<logger name="com.binaryoption.commonutils.datasource" level="DEBUG" additivity="false">
    <appender-ref ref="CONSOLE"/>
    <appender-ref ref="APPLICATION_FILE"/>
</logger>

<!-- HikariCP 连接池日志 -->
<logger name="com.zaxxer.hikari" level="DEBUG" additivity="false">
    <appender-ref ref="CONSOLE"/>
    <appender-ref ref="APPLICATION_FILE"/>
</logger>

<!-- 为开发环境添加彩色输出 -->
<springProfile name="dev">
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %highlight(%-5level) %cyan(%logger{36}) - %msg%n</pattern>
        </encoder>
    </appender>
</springProfile>
```

## 三、监控和验证

### 3.1 日志输出示例

#### **查询操作日志**
```log
# 执行查询时的日志输出
14:23:45.123 [http-nio-8081-exec-1] DEBUG c.b.c.d.ReadWriteDataSourceAspect - Method [getOrder] uses SLAVE datasource
14:23:45.124 [http-nio-8081-exec-1] DEBUG c.b.c.d.DynamicDataSource - Current DataSource: SLAVE
14:23:45.125 [HikariPool-SlaveHikariPool-DEV] DEBUG com.zaxxer.hikari.HikariDataSource - SlaveHikariPool-DEV - Starting...
14:23:45.126 [HikariPool-SlaveHikariPool-DEV] DEBUG com.zaxxer.hikari.HikariDataSource - SlaveHikariPool-DEV - Start completed.
14:23:45.135 [http-nio-8081-exec-1] INFO  c.b.c.s.OrderService - [TIMING] OrderService getOrder 12ms
```

#### **写操作日志**
```log
# 执行写操作时的日志输出
14:25:32.456 [http-nio-8081-exec-2] DEBUG c.b.c.d.ReadWriteDataSourceAspect - Method [createOrder] uses MASTER datasource
14:25:32.457 [http-nio-8081-exec-2] DEBUG c.b.c.d.DynamicDataSource - Current DataSource: MASTER
14:25:32.458 [HikariPool-MasterHikariPool-DEV] DEBUG com.zaxxer.hikari.HikariDataSource - MasterHikariPool-DEV - Starting...
14:25:32.459 [HikariPool-MasterHikariPool-DEV] DEBUG com.zaxxer.hikari.HikariDataSource - MasterHikariPool-DEV - Start completed.
14:25:32.478 [http-nio-8081-exec-2] INFO  c.b.c.s.OrderService - [TIMING] OrderService createOrder 25ms
```

### 3.2 验证脚本

#### 📄 `test-scripts/verify-datasource-routing.sh`
```bash
#!/bin/bash

echo "=== 读写分离路由验证脚本 ==="

# 配置
source common/config-dev.sh

# 1. 执行查询操作，检查日志
echo "1. 测试查询操作（应该使用 SLAVE）"
curl -s "$API_BASE/api/order/1" > /dev/null
sleep 1

echo "2. 测试创建操作（应该使用 MASTER）"
curl -s -X POST "$API_BASE/api/order" \
  -H "Content-Type: application/json" \
  -d '{"amount": 100, "direction": "UP"}' > /dev/null
sleep 1

echo "3. 分析最近的日志"
echo "=== SLAVE 数据源使用情况 ==="
tail -n 100 logs/option-order-service-application.log | grep "uses SLAVE datasource" | tail -5

echo "=== MASTER 数据源使用情况 ==="
tail -n 100 logs/option-order-service-application.log | grep "uses MASTER datasource" | tail -5

echo "=== 连接池使用情况 ==="
tail -n 100 logs/option-order-service-application.log | grep "HikariPool.*DEV" | tail -10
```

### 3.3 实时监控脚本

#### 📄 `test-scripts/monitor-datasource-realtime.sh`
```bash
#!/bin/bash

echo "=== 实时监控数据源路由 ==="
echo "按 Ctrl+C 停止监控"

# 实时跟踪日志
tail -f logs/option-*-application.log | grep --line-buffered -E "(uses SLAVE|uses MASTER|HikariPool.*DEV)" | while read line; do
    timestamp=$(date '+%H:%M:%S')
    
    if echo "$line" | grep -q "uses SLAVE"; then
        echo "[$timestamp] 🔵 READ  -> SLAVE: $line"
    elif echo "$line" | grep -q "uses MASTER"; then
        echo "[$timestamp] 🔴 WRITE -> MASTER: $line"
    elif echo "$line" | grep -q "HikariPool"; then
        echo "[$timestamp] 🔗 POOL: $line"
    fi
done
```

## 四、连接池区分策略

### 4.1 通过连接池名称区分

```yaml
# 即使指向同一个数据库，也使用不同的连接池名称
spring:
  datasource:
    master:
      hikari:
        pool-name: "MasterPool-${spring.application.name}-DEV"  # 主库连接池
    slave:
      hikari:
        pool-name: "SlavePool-${spring.application.name}-DEV"   # 从库连接池
```

### 4.2 连接池监控

```java
// 可以添加监控Bean来跟踪连接池使用情况
@Component
@ConditionalOnProperty(name = "spring.profiles.active", havingValue = "dev")
public class DevDataSourceMonitor {
    
    @Autowired
    @Qualifier("masterDataSource")
    private HikariDataSource masterDataSource;
    
    @Autowired
    @Qualifier("slaveDataSource")  
    private HikariDataSource slaveDataSource;
    
    @Scheduled(fixedDelay = 30000) // 每30秒输出一次
    public void logConnectionPoolStats() {
        log.info("=== 连接池使用情况 ===");
        log.info("Master Pool: active={}, idle={}, total={}", 
            masterDataSource.getHikariPoolMXBean().getActiveConnections(),
            masterDataSource.getHikariPoolMXBean().getIdleConnections(),
            masterDataSource.getHikariPoolMXBean().getTotalConnections());
            
        log.info("Slave Pool: active={}, idle={}, total={}",
            slaveDataSource.getHikariPoolMXBean().getActiveConnections(), 
            slaveDataSource.getHikariPoolMXBean().getIdleConnections(),
            slaveDataSource.getHikariPoolMXBean().getTotalConnections());
    }
}
```

## 五、生产环境切换

### 5.1 配置环境区分

#### **开发环境** (`application-dev.yml`)
```yaml
spring:
  datasource:
    master:
      jdbc-url: jdbc:postgresql://localhost:5433/binary_option      # 同一个库
    slave:
      jdbc-url: jdbc:postgresql://localhost:5433/binary_option      # 同一个库
```

#### **生产环境** (`application-prod.yml`)
```yaml
spring:
  datasource:
    master:
      jdbc-url: jdbc:postgresql://prod-master:5432/binary_option    # 真正的主库
    slave:
      jdbc-url: jdbc:postgresql://prod-slave:5432/binary_option     # 真正的从库
```

### 5.2 平滑切换

```yaml
# 可以通过配置开关控制
datasource:
  read-write-separation:
    enabled: true
    dev-mode: true  # 开发模式：主从指向同一个库
```

## 六、测试场景

### 6.1 功能验证测试

```bash
# 1. 查询操作测试
echo "测试查询操作..."
curl "$API_BASE/api/account/balance?userId=1"
# 期望日志：uses SLAVE datasource

# 2. 写操作测试  
echo "测试写操作..."
curl -X POST "$API_BASE/api/order" -d '{"amount":100}'
# 期望日志：uses MASTER datasource

# 3. 混合操作测试
echo "测试混合操作..."
curl -X PUT "$API_BASE/api/order/1/status" -d '{"status":"SETTLED"}'
# 期望日志：uses MASTER datasource（因为包含写操作）
```

### 6.2 压力测试

```bash
# 并发测试，观察连接池使用
for i in {1..50}; do
    curl -s "$API_BASE/api/order/list" &
done
wait

# 检查日志中的连接池使用情况
grep "SlavePool.*DEV" logs/*.log | wc -l
```

## 七、优势总结

### ✅ **开发环境优势**
1. **无需主从复制**：只需要一个数据库实例
2. **逻辑验证**：可以完整验证读写分离的路由逻辑
3. **日志清晰**：通过连接池名称清楚看到路由效果
4. **成本低**：无需额外的数据库资源

### ✅ **生产就绪**
1. **配置兼容**：生产环境只需要修改数据库连接地址
2. **逻辑一致**：开发和生产使用完全相同的路由逻辑
3. **测试充分**：开发环境已经验证了所有路由场景

### ✅ **监控完善**
1. **实时日志**：清楚看到每个操作使用的数据源
2. **连接池监控**：可以观察到不同连接池的使用情况
3. **性能指标**：为生产环境性能优化提供基础数据

**这个方案既实用又经济，完美适合开发环境的需求！**