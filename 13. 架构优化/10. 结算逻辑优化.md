# 结算逻辑优化 - 添加"结算中"状态

## 一、需求背景

### 当前问题
1. 结算过程可能失败，导致订单状态不明确
2. 用户在结算期间无法看到正在处理的订单
3. 可能引起用户对资金安全的担忧

### 解决方案
1. 为 `bo_user_round` 表添加 `SETTLING`（结算中）状态
2. 结算开始时立即更新状态，让用户可见
3. 历史订单查询包含结算中的记录
4. 即使结算失败，用户也能看到订单处于处理中

## 二、影响范围分析

### 需要修改的文件树形结构
```
BinaryOption/
├── option-order-service/
│   ├── src/main/java/com/binaryoption/orderservice/
│   │   ├── service/
│   │   │   └── OrderSettlementService.java       # 修改结算逻辑，添加时间戳更新
│   │   └── mapper/
│   │       └── UserRoundMapper.java              # 添加updateLastSettleTimeByRoundId方法
│   └── src/main/resources/mapper/
│       ├── UserRoundMapper.xml                   # 添加批量时间更新SQL
│       └── OrderMapper.xml                       # 修改查询条件包含PENDING状态
```

## 三、详细修改方案

### 3.1 核心思路调整

基于您的建议，发现原有的 `findHistoryRoundIdsByUser` 已经基于 `last_settle_time IS NOT NULL` 进行判断，设计非常优雅。

**最简方案**：
- 在结算开始时立即更新 `last_settle_time`
- 用户查询时基于时间戳判断，无需状态管理
- 只需修改两个地方：结算逻辑 + 订单查询条件

### 3.2 修改settleOrdersByRound方法

**文件**: `OrderSettlementService.java`

**修改点**:
1. 方法开始时，立即更新 `last_settle_time` 让用户能看到"结算中"状态

```java
@Transactional
public void settleOrdersByRound(Long roundId) {
    // 1. 验证并获取轮次
    TradingRound round = validateAndGetRound(roundId);
    
    // 2. 【新增】立即更新last_settle_time，让用户能看到该轮次
    updateUserRoundsSettleTime(roundId);
    
    // 3. 获取或确定结算价格
    BigDecimal roundSettlePrice = getOrDetermineSettlementPrice(round);
    
    // 4. 批量结算订单  
    List<Order> orders = orderMapper.findPendingOrdersByRound(roundId);
    BatchSettlementResult settlementResult = batchSettleOrders(orders, roundSettlePrice, round);
    
    // 5. 执行结算后处理任务（这里会再次更新统计数据）
    processPostSettlementTasks(roundId, settlementResult);
    
    // 6. 记录结算完成日志
    logSettlementCompletion(roundId, roundSettlePrice, orders.size(), settlementResult);
}

// 新增方法：更新结算时间
private void updateUserRoundsSettleTime(Long roundId) {
    LocalDateTime now = LocalDateTime.now();
    // 批量更新该轮次所有用户的last_settle_time
    userRoundMapper.updateLastSettleTimeByRoundId(roundId, now);
    log.info("Updated last_settle_time for round: {} at {}", roundId, now);
}
```

### 3.3 findHistoryRoundIdsByUser方法无需修改

**文件**: `UserRoundMapper.xml`

**原SQL**:
```xml
<select id="findHistoryRoundIdsByUser">
    SELECT round_id
    FROM bo_user_round
    WHERE user_id = #{userId}
    AND last_settle_time IS NOT NULL  <!-- 已经基于时间判断，无需修改 -->
    ORDER BY last_settle_time DESC
    LIMIT #{limit} OFFSET #{offset}
</select>
```

**分析**: 
- 原SQL使用 `last_settle_time IS NOT NULL` 作为判断条件
- 只要在结算开始时更新 `last_settle_time`，用户就能立即看到该轮次
- **无需修改此方法**，设计已经足够优雅

### 3.4 修改findByUserIdAndRoundIds方法

**文件**: `OrderMapper.xml`

**当前SQL**:
```xml
<select id="findByUserIdAndRoundIds">
    SELECT * FROM bo_option_order
    WHERE user_id = #{userId}
    AND round_id IN
    <foreach collection="roundIds" item="roundId" separator="," open="(" close=")">
        #{roundId}
    </foreach>
    AND status IN ('WIN', 'LOSE', 'DRAW')  <!-- 当前只包含已结算状态 -->
    ORDER BY create_time DESC
</select>
```

**修改后**:
```xml
<select id="findByUserIdAndRoundIds">
    SELECT * FROM bo_option_order
    WHERE user_id = #{userId}
    AND round_id IN
    <foreach collection="roundIds" item="roundId" separator="," open="(" close=")">
        #{roundId}
    </foreach>
    AND status IN ('ACTIVE', 'PENDING', 'WIN', 'LOSE', 'DRAW')  <!-- 添加结算中的订单状态 -->
    ORDER BY create_time DESC
</select>
```

### 3.5 需要添加的UserRoundMapper方法

**文件**: `UserRoundMapper.java` 和 `UserRoundMapper.xml`

**新增方法接口**:
```java
/**
 * 批量更新轮次的last_settle_time
 */
void updateLastSettleTimeByRoundId(@Param("roundId") Long roundId, 
                                  @Param("settleTime") LocalDateTime settleTime);
```

**新增SQL实现**:
```xml
<!-- 批量更新指定轮次所有用户的结算时间 -->
<update id="updateLastSettleTimeByRoundId">
    UPDATE bo_user_round 
    SET last_settle_time = #{settleTime}
    WHERE round_id = #{roundId}
    AND last_settle_time IS NULL
</update>
```

## 四、异常处理策略

### 4.1 结算失败处理

结算失败时，`last_settle_time` 已经被设置，用户能看到该轮次，但订单仍为 `ACTIVE/PENDING` 状态，用户可以理解为"结算中"。

```java
@Transactional
public void settleOrdersByRound(Long roundId) {
    try {
        // 1-2. 验证轮次并更新时间戳（已完成）
        updateUserRoundsSettleTime(roundId);
        
        // 3-6. 结算逻辑...
    } catch (Exception e) {
        // 结算失败时，时间戳已设置，用户能看到轮次
        // 订单保持PENDING状态，表示结算中
        log.error("Settlement failed for round: {}, users can see orders in history", roundId, e);
        throw e;
    }
}
```

### 4.2 补偿机制

利用现有的 `executeFailedSettlementRetryTask` 定时任务，它已经能处理结算失败的情况。

## 五、前端配合修改

### 5.0 PNL弹窗逻辑调整

**问题**：由于结算开始时就更新 `last_settle_time`，结算中的轮次会出现在历史记录中，可能导致PNL弹窗错误显示

**解决方案**：在PNL弹窗逻辑中，检查订单是否真正已结算完成

**修改位置**: `binaryoption-fe/src/views/Index.vue`

```javascript
// 现有的检查逻辑需要增强
if (res.data && res.data.records && res.data.records.length > 0) {
  roundData = res.data.records.find((record: any) => String(record.roundId) === String(oldRoundId))
  
  if (roundData && roundData.totalOrders > 0) {
    // 【新增】检查轮次中的订单是否真正已结算完成
    // 如果所有订单都是PENDING/ACTIVE状态，说明还在结算中，不应该弹PNL
    const hasSettledOrders = roundData.orders && roundData.orders.some(order => 
      ['WIN', 'LOSE', 'DRAW'].includes(order.status)
    )
    
    if (hasSettledOrders) {
      console.log(`成功找到轮次${oldRoundId}的已结算数据，有${roundData.totalOrders}个订单`)
      break // 找到真正已结算的数据，跳出重试循环
    } else {
      console.log(`轮次${oldRoundId}存在但订单尚未结算完成，继续等待...`)
      roundData = null // 重置为null，继续重试
    }
  } else if (roundData) {
    console.log(`轮次${oldRoundId}存在但没有订单`)
    break // 轮次存在但没订单，也算找到了，跳出循环
  }
}
```

**备选方案**（如果上述方案不可行）：
```javascript
// 通过检查profit数据来判断是否已真正结算
if (roundData && roundData.totalOrders > 0) {
  // 检查是否有有效的profit数据（非0非null）
  const hasValidProfit = roundData.totalProfit > 0 || roundData.totalLoss > 0
  
  if (hasValidProfit) {
    console.log(`轮次${oldRoundId}已结算，净盈亏: ${roundData.netProfit}`)
    break
  } else {
    console.log(`轮次${oldRoundId}存在但尚未产生盈亏数据，继续等待...`)
    roundData = null
  }
}
```

## 五、前端配合修改

### 5.1 历史订单列表页（轮次聚合）

**修改位置**: 历史订单轮次列表组件

**当前显示**: `profit/loss(usdt) +50`

**修改逻辑**:
```javascript
// 判断轮次是否为结算中状态
const isSettling = (roundData) => {
  // 如果轮次有last_settle_time但订单都是PENDING状态，则为结算中
  return roundData.orders.every(order => 
    order.status === 'PENDING' || order.status === 'ACTIVE'
  ) && roundData.lastSettleTime !== null;
};

// 显示逻辑
const RoundProfitDisplay = ({ roundData }) => {
  if (isSettling(roundData)) {
    return <span>In Settlement</span>;
  }
  
  // 原有的profit/loss显示逻辑
  const profit = calculateRoundProfit(roundData);
  return (
    <span className={profit >= 0 ? 'profit' : 'loss'}>
      {profit >= 0 ? '+' : ''}{profit} USDT
    </span>
  );
};
```


### 5.2 历史订单轮次详情页

**修改位置**: 轮次详情页面

**修改点1**: Profit/Loss 显示
```javascript
const RoundDetailHeader = ({ roundData }) => {
  const isSettling = roundData.orders.every(order => 
    order.status === 'PENDING' || order.status === 'ACTIVE'
  );
  
  return (
    <div className="round-detail-header">
      {/* 其他信息 */}
      
      <div className="profit-section">
        {isSettling ? (
          <div className="settling-info">
            <span className="label">Status:</span>
            <span>In Settlement</span>
          </div>
        ) : (
          <div className="profit-info">
            <span className="label">Profit/Loss:</span>
            <span className={`amount ${profit >= 0 ? 'profit' : 'loss'}`}>
              {profit >= 0 ? '+' : ''}{profit} USDT
            </span>
          </div>
        )}
      </div>
    </div>
  );
};
```

**修改点2**: End Price 显示
```javascript
const RoundDetailInfo = ({ roundData }) => {
  const isSettling = roundData.orders.every(order => 
    order.status === 'PENDING' || order.status === 'ACTIVE'
  );
  
  return (
    <div className="round-info">
      <div className="info-item">
        <span className="label">Start Price:</span>
        <span className="value">{roundData.startPrice}</span>
      </div>
      
      <div className="info-item">
        <span className="label">End Price:</span>
        <span className="value">
          {isSettling ? '-' : roundData.endPrice}
        </span>
      </div>
      
      <div className="info-item">
        <span className="label">Duration:</span>
        <span className="value">{roundData.duration} min</span>
      </div>
    </div>
  );
};
```

### 5.3 自动刷新策略

```javascript
// 页面级别的自动刷新逻辑
const HistoryOrdersPage = () => {
  const [refreshInterval, setRefreshInterval] = useState(30000); // 默认30秒
  
  useEffect(() => {
    // 检查是否有结算中的轮次
    const hasSettlingRounds = roundsData.some(round => 
      round.orders.every(order => 
        order.status === 'PENDING' || order.status === 'ACTIVE'
      ) && round.lastSettleTime !== null
    );
    
    if (hasSettlingRounds) {
      // 有结算中轮次时，5秒刷新
      setRefreshInterval(5000);
      console.log('Found settling rounds, increased refresh rate');
    } else {
      // 无结算中轮次时，恢复正常30秒刷新
      setRefreshInterval(30000);
    }
  }, [roundsData]);
  
  // 自动刷新逻辑
  useEffect(() => {
    const timer = setInterval(() => {
      refreshData();
    }, refreshInterval);
    
    return () => clearInterval(timer);
  }, [refreshInterval]);
};
```


## 六、测试场景

### 6.1 正常结算流程
1. 创建订单并等待轮次结束
2. 触发结算，验证 `last_settle_time` 立即更新
3. 用户查询历史订单，能看到该轮次（订单状态为PENDING）
4. 结算完成，订单状态更新为 WIN/LOSE/DRAW

### 6.2 结算失败场景
1. 模拟结算过程中的异常
2. 验证 `last_settle_time` 已设置，用户能看到轮次
3. 订单保持 PENDING 状态，用户理解为"结算中"
4. 补偿机制重试结算

### 6.3 并发结算场景
1. 多个轮次同时结算
2. 验证各轮次时间戳独立更新
3. 用户查询不受影响

## 七、回滚方案

如需回滚此功能，只需：
1. 移除 `OrderSettlementService.updateUserRoundsSettleTime()` 方法调用
2. 恢复 `findByUserIdAndRoundIds` 的原始查询条件
3. 删除新增的 `updateLastSettleTimeByRoundId` 方法

无需数据库变更，影响最小。

## 八、监控指标

### 需要监控的关键指标
1. PENDING状态订单持续时间分布
2. 结算失败率
3. 补偿任务成功率
4. 用户查询响应时间

### 告警规则
- 单个轮次PENDING状态超过5分钟
- 结算失败率超过1%
- 大量订单积压在PENDING状态

---

**更新日期**: 2025-11-11
**作者**: Claude
**状态**: 待实施