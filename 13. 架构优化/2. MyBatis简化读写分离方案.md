# MyBatis 简化读写分离方案

## 1. 核心思路

**原则：事务级别的读写分离**
- 如果当前请求/事务包含任何写操作（INSERT/UPDATE/DELETE），整个请求都走主库
- 纯读请求走从库
- 实现简单，避免主从延迟导致的数据不一致问题

## 2. 快速实现方案

### 2.1 方案一：基于 @Transactional 注解（最简单）

#### **Step 1: 配置双数据源**

```yaml
# application.yml
spring:
  datasource:
    # 主库配置
    master:
      url: jdbc:mysql://localhost:3306/binary_option?useSSL=false
      username: root
      password: root
      driver-class-name: com.mysql.cj.jdbc.Driver
      hikari:
        pool-name: MasterPool
        maximum-pool-size: 20
        
    # 从库配置  
    slave:
      url: jdbc:mysql://localhost:3307/binary_option?useSSL=false
      username: root
      password: root
      driver-class-name: com.mysql.cj.jdbc.Driver
      hikari:
        pool-name: SlavePool
        maximum-pool-size: 30
```

#### **Step 2: 动态数据源实现**

```java
// 1. 数据源路由
public class DynamicDataSource extends AbstractRoutingDataSource {
    
    private static final ThreadLocal<Boolean> IS_MASTER = ThreadLocal.withInitial(() -> true);
    
    @Override
    protected Object determineCurrentLookupKey() {
        return IS_MASTER.get() ? "master" : "slave";
    }
    
    public static void useMaster() {
        IS_MASTER.set(true);
    }
    
    public static void useSlave() {
        IS_MASTER.set(false);
    }
    
    public static void clear() {
        IS_MASTER.remove();
    }
}
```

#### **Step 3: 简化的AOP切面**

```java
@Aspect
@Component
@Order(0)  // 确保在事务切面之前执行
public class ReadWriteDataSourceAspect {
    
    /**
     * 所有 Service 方法拦截
     */
    @Around("execution(* com.binaryoption..service..*(..))")
    public Object determineDataSource(ProceedingJoinPoint joinPoint) throws Throwable {
        try {
            // 获取方法上的事务注解
            MethodSignature signature = (MethodSignature) joinPoint.getSignature();
            Method method = signature.getMethod();
            
            Transactional transactional = method.getAnnotation(Transactional.class);
            if (transactional == null) {
                // 尝试从类上获取
                transactional = joinPoint.getTarget().getClass().getAnnotation(Transactional.class);
            }
            
            // 判断数据源
            if (transactional != null && transactional.readOnly()) {
                // 只读事务 -> 从库
                DynamicDataSource.useSlave();
                log.debug("Using SLAVE for method: {}", method.getName());
            } else {
                // 写事务或无事务标记 -> 主库（保守策略）
                DynamicDataSource.useMaster();
                log.debug("Using MASTER for method: {}", method.getName());
            }
            
            return joinPoint.proceed();
            
        } finally {
            DynamicDataSource.clear();
        }
    }
}
```

#### **Step 4: Service层使用**

```java
@Service
public class OrderService {
    
    @Autowired
    private OrderMapper orderMapper;
    
    /**
     * 创建订单 - 自动走主库
     */
    @Transactional(rollbackFor = Exception.class)
    public Result<OrderDTO> createOrder(CreateOrderDTO request) {
        // 包含写操作，自动使用主库
        Order order = new Order();
        orderMapper.insert(order);
        return Result.success(convertToDTO(order));
    }
    
    /**
     * 查询订单 - 走从库
     */
    @Transactional(readOnly = true)  // 标记为只读
    public Result<OrderDTO> getOrder(Long orderId) {
        // 纯读操作，自动使用从库
        Order order = orderMapper.selectById(orderId);
        return Result.success(convertToDTO(order));
    }
    
    /**
     * 查询订单列表 - 走从库
     */
    @Transactional(readOnly = true)
    public Result<List<OrderDTO>> getOrderList(OrderQueryDTO query) {
        // 纯读操作，使用从库
        List<Order> orders = orderMapper.selectByCondition(query);
        return Result.success(convertToDTO(orders));
    }
    
    /**
     * 更新订单并返回 - 全程走主库
     */
    @Transactional(rollbackFor = Exception.class)
    public Result<OrderDTO> updateOrder(UpdateOrderDTO request) {
        // 有写操作，整个事务都走主库
        Order order = orderMapper.selectById(request.getId()); // 走主库
        order.setStatus(request.getStatus());
        orderMapper.update(order); // 走主库
        
        // 再次查询也走主库，避免主从延迟
        order = orderMapper.selectById(request.getId()); // 走主库
        return Result.success(convertToDTO(order));
    }
}
```

### 2.2 方案二：基于MyBatis插件（更智能）

#### **MyBatis拦截器实现**

```java
@Intercepts({
    @Signature(type = Executor.class, method = "update", args = {MappedStatement.class, Object.class}),
    @Signature(type = Executor.class, method = "query", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})
})
@Component
public class ReadWriteInterceptor implements Interceptor {
    
    // 记录当前线程是否执行过写操作
    private static final ThreadLocal<Boolean> HAS_WRITE = ThreadLocal.withInitial(() -> false);
    
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        String methodName = invocation.getMethod().getName();
        
        if ("update".equals(methodName)) {
            // 执行写操作，标记当前线程
            HAS_WRITE.set(true);
            DynamicDataSource.useMaster();
            log.debug("Write operation detected, using MASTER");
            
        } else if ("query".equals(methodName)) {
            // 查询操作
            if (HAS_WRITE.get()) {
                // 当前线程已有写操作，继续使用主库
                DynamicDataSource.useMaster();
                log.debug("Query after write, using MASTER");
            } else {
                // 纯查询，使用从库
                DynamicDataSource.useSlave();
                log.debug("Pure query, using SLAVE");
            }
        }
        
        try {
            return invocation.proceed();
        } finally {
            // 如果是事务结束，清理标记
            if (isTransactionEnd()) {
                HAS_WRITE.remove();
                DynamicDataSource.clear();
            }
        }
    }
    
    private boolean isTransactionEnd() {
        // 通过 TransactionSynchronizationManager 判断事务是否结束
        return !TransactionSynchronizationManager.isActualTransactionActive();
    }
}
```

### 2.3 配置类整合

```java
@Configuration
@MapperScan("com.binaryoption.*.mapper")
public class DataSourceConfig {
    
    @Bean
    @ConfigurationProperties("spring.datasource.master")
    public DataSource masterDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    @ConfigurationProperties("spring.datasource.slave")
    public DataSource slaveDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    @Primary
    public DataSource dynamicDataSource() {
        DynamicDataSource dynamicDataSource = new DynamicDataSource();
        
        Map<Object, Object> dataSourceMap = new HashMap<>();
        dataSourceMap.put("master", masterDataSource());
        dataSourceMap.put("slave", slaveDataSource());
        
        dynamicDataSource.setTargetDataSources(dataSourceMap);
        dynamicDataSource.setDefaultTargetDataSource(masterDataSource());
        
        return dynamicDataSource;
    }
    
    @Bean
    public SqlSessionFactory sqlSessionFactory(@Qualifier("dynamicDataSource") DataSource dataSource) throws Exception {
        SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
        sessionFactory.setDataSource(dataSource);
        sessionFactory.setMapperLocations(
            new PathMatchingResourcePatternResolver().getResources("classpath:mapper/*.xml")
        );
        
        // 添加插件（如果使用方案二）
        // sessionFactory.setPlugins(new Interceptor[]{new ReadWriteInterceptor()});
        
        return sessionFactory.getObject();
    }
}
```

## 3. 快速实施步骤（1-2天完成）

### Day 1: 基础搭建
```bash
# 1. 添加配置（30分钟）
- 修改 application.yml，添加主从数据源配置

# 2. 创建核心类（1小时）
- DynamicDataSource.java
- ReadWriteDataSourceAspect.java
- DataSourceConfig.java

# 3. 测试验证（2小时）
- 单元测试验证数据源切换
- 日志确认主从分离是否生效
```

### Day 2: 业务改造
```bash
# 1. Service层标记（2-3小时）
- 为所有查询方法添加 @Transactional(readOnly = true)
- 确保写操作方法有 @Transactional

# 2. 关键业务验证（2小时）
- OrderService 核心流程测试
- AccountService 余额相关测试
- 确保数据一致性
```

## 4. 最简化实施（仅需修改3个文件）

如果要最快速度实现，只需要：

### 文件1: application.yml
```yaml
spring:
  datasource:
    master:
      url: jdbc:mysql://master:3306/binary_option
    slave:  
      url: jdbc:mysql://slave:3307/binary_option
```

### 文件2: DataSourceConfig.java
```java
@Configuration
public class SimpleReadWriteConfig {
    
    @Bean
    @Primary
    public DataSource dataSource() {
        // 简单的路由数据源
        Map<Object, Object> targetDataSources = new HashMap<>();
        targetDataSources.put("master", masterDataSource());
        targetDataSources.put("slave", slaveDataSource());
        
        AbstractRoutingDataSource routingDataSource = new AbstractRoutingDataSource() {
            @Override
            protected Object determineCurrentLookupKey() {
                // 简单规则：看方法名
                String methodName = getCurrentMethodName();
                if (methodName != null && 
                    (methodName.startsWith("get") || 
                     methodName.startsWith("find") || 
                     methodName.startsWith("select") || 
                     methodName.startsWith("query"))) {
                    return "slave";
                }
                return "master";
            }
        };
        
        routingDataSource.setTargetDataSources(targetDataSources);
        routingDataSource.setDefaultTargetDataSource(masterDataSource());
        return routingDataSource;
    }
}
```

### 文件3: 标记Service方法
```java
// 只需要给纯查询方法加注解
@Transactional(readOnly = true)
public OrderDTO getOrder(Long id) { ... }

@Transactional(readOnly = true)  
public List<OrderDTO> getOrderList() { ... }

// 写操作不需要改，默认走主库
@Transactional
public void createOrder(OrderDTO order) { ... }
```

## 5. 注意事项

### 5.1 必须注意的坑
```java
// ❌ 错误：在一个方法内先查询后更新
@Transactional(readOnly = true)  // 标记为只读，会走从库
public void updateOrderStatus(Long orderId, String status) {
    Order order = orderMapper.selectById(orderId); // 从库
    order.setStatus(status);
    orderMapper.update(order); // 还是从库，会报错！
}

// ✅ 正确：包含写操作就不要标记 readOnly
@Transactional
public void updateOrderStatus(Long orderId, String status) {
    Order order = orderMapper.selectById(orderId); // 主库
    order.setStatus(status);
    orderMapper.update(order); // 主库
}
```

### 5.2 主从延迟处理
```java
// 对于必须立即读取的场景，强制使用主库
@Transactional
public OrderDTO createAndReturn(CreateOrderDTO request) {
    // 创建订单
    Order order = new Order();
    orderMapper.insert(order);
    
    // 立即查询返回（走主库，避免延迟）
    return orderMapper.selectById(order.getId());
}
```

## 6. 性能收益预估

基于您的系统特点：
- **读写比例**：估计 7:3（查询占70%）
- **性能提升**：查询性能提升 40-60%
- **主库负载**：减少 50-70%
- **实施成本**：1-2天完成

## 7. 推荐方案

**建议采用方案一（基于 @Transactional）**，原因：
1. 实现最简单，改动最少
2. 与Spring事务完美结合
3. 代码可读性好
4. 容易排查问题

只需要：
1. 配置双数据源（30分钟）
2. 添加3个Java类（1小时）
3. Service方法加 `@Transactional(readOnly=true)`（2小时）

这样就完成了读写分离！